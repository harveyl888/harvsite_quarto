[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "I’m a passionate data scientist who works in the Pharmaceutical Industry. I love both science and technology and the blurry interface between them.\nI spent many years at Sanofi working in areas such as property prediction, laboratory automation and omics biomarker analysis. I am currently working at Novartis as a data scientist within biostatistics.\nI also help run R/Pharma, an organization dedicated to promoting data science (primarily through R) within the Pharma and Biotech industries.\nI’ve been programming for around 40 years now and have experience in more than 20 languages and many operating systems, including several extinct ones! Currently, much of my programming favors R with python thrown in where applicable."
  },
  {
    "objectID": "posts/2016/2016-12-20-R_notebooks_collapse/index.html",
    "href": "posts/2016/2016-12-20-R_notebooks_collapse/index.html",
    "title": "R-Notebooks Collapse Button",
    "section": "",
    "text": "I’ve taken to using R Notebooks for many of the tasks that I used to write in R Markdown. Advantages are that code chunks can be executed independently, leading to easier management and debugging, and that the output is still a usable document.\nThere are times, however, when I would like to include a large table or multiple plots but don’t want them to take up too much of the output document. For tables this can easily be accomplished using a datatable but for more complex tables or multiple plots placing them in a collapsible div attached to a button works well. In the code chunk below, formattable is used to format the iris dataset.\n\nlibrary(htmltools)\nlibrary(formattable)\nHTML('&lt;div class=\"row\"&gt;\n        &lt;div class=\"col-md-12\"&gt;\n          &lt;button type=\"button\" class=\"btn btn-warning btn-sm code-folding-btn\" data-toggle=\"collapse\" data-target=\"#table_iris\" aria-expanded=\"false\"&gt;\n            &lt;span&gt;Iris Data&lt;/span&gt;\n          &lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n&lt;div id=\"table_iris\" class=\"collapse\"&gt;')\nas.htmlwidget(formattable(iris,\n                          list(Sepal.Length = color_tile(\"white\", \"lightpink\"),\n                          Sepal.Width = color_tile(\"white\", \"lightgreen\"),\n                          Petal.Length = color_tile(\"white\", \"lightpink\"),\n                          Petal.Width = color_tile(\"white\", \"lightgreen\"))), \n                          width = '30%')\nHTML('&lt;/div&gt;')"
  },
  {
    "objectID": "posts/2016/2016-11-23-why_blog/index.html",
    "href": "posts/2016/2016-11-23-why_blog/index.html",
    "title": "Why blog? Why now?",
    "section": "",
    "text": "So why write a blog and why write it now?\nI’m not a writer. I won’t even pretend to be a writer. That’s something reserved for my wife (she is actually a professional writer). I do, however, spend quite a bit of time writing code and it’s now time to articulate some thoughts and share code. I’m also getting to the point where I find myself going through the same thought process to solve a problem and, in the spirit of DRY programming, I’d like to keep a record so that I can save some time. Quite frankly it’s a selfish thing I’m doing here but feel free to join the ride.\nThis site is created using Jekyll along with a theme called Skinny Bones and hosted on Github pages (I’m a huge fan of all things Github)."
  },
  {
    "objectID": "posts/2018/2018-08-05-cron_python_slack/index.html",
    "href": "posts/2018/2018-08-05-cron_python_slack/index.html",
    "title": "cron, python and slack - a beautiful combination",
    "section": "",
    "text": "This year I’m trying out slack as a platform for out fantasy football league. It provides channels for banter, keeping track of transfers and, with the use of rss feeds, up to date information. In addition I’ve set up a channel dedicated to injuries tied to an incoming webhook. The injury channel works by running a small python code on a server via a weekly cron job. The python code scrapes a site that lists current Premiership injuries and suspensions, reformats the output and then pushes it out to the slack channel. This results in a simple solution that updates a channel weekly.\n# -*- coding: utf-8 -*-\nimport pandas as pd\nfrom bs4 import BeautifulSoup\nimport requests\nimport json\n\nurl = \"https://www.fantasyfootballscout.co.uk/fantasy-football-injuries/\"\nwebhook = ## provided webhook url\n\n\nresponse = requests.get(url)\n\nsoup = BeautifulSoup(response.text, \"html5lib\")\n\ntable = soup.find('table', attrs={'class':'ffs-ib-full-content'})\ntable_body = table.find('tbody')\n\ndata = []\n\nrows = table_body.find_all('tr')\nfor row in rows:\n    cols = row.find_all('td')\n    cols = [ele.text.strip() for ele in cols]\n    data.append([ele for ele in cols if ele]) # Get rid of empty values\n\nstatus = {\"Injured\": \":inj-injured:\", \n          \"Available\": \":inj-available:\",\n          \"Unavailable\": \":inj-unavailable:\",\n          \"Knock\": \":inj-knock:\",\n          \"On Loan\": \":inj-on-loan:\",\n          \"Suspended\": \":inj-disciplinary:\",\n          \"Doubt 25%\": \":inj-doubt-25:\", \n          \"Doubt 50%\": \":inj-doubt-50:\", \n          \"Doubt 75%\": \":inj-doubt-75:\"}\n\np1 = pd.DataFrame(data, columns = ['Name', 'Club', 'Status', 'Return Date', 'Latest News', 'Last Updated'])\np1['status_icon'] = p1['Status'].replace(status)\np1['out'] = p1['status_icon'] + ' ' + p1['Name'] + ' ' + p1['Club']\n\n# build the payload\npayload = {}\npayload['username'] = 'injury-bot'\npayload['channel'] = '#injuries'\n\nattachments = []\nattachments.append({\"fallback\":\"Link to injury website: &lt;https://www.fantasyfootballscout.co.uk/fantasy-football-injuries/|full injury table&gt;\"})\nattachments.append({\"pretext\":\"Link to injury website: &lt;https://www.fantasyfootballscout.co.uk/fantasy-football-injuries/|full injury table&gt;\"})\n\nfield_inj = {}\nfield_inj['title'] = 'Injury Table'\nfield_inj['value'] = '\\n'.join(p1['out'].tolist())\nfield_inj['short'] = False\n\nattachments.append({\"fields\": [field_inj]})\npayload['attachments'] = attachments\n\nrequests.post(webhook, data = json.dumps(payload))"
  },
  {
    "objectID": "posts/2018/2018-07-13-css_variables/index.html",
    "href": "posts/2018/2018-07-13-css_variables/index.html",
    "title": "Using CSS Variables with Shiny",
    "section": "",
    "text": "Method One - Does not work with IE\nCSS variables are a powerful way to make wholesale changes to the style throughout an entire document. They are set using a custom notation --variable_name and accessed throughout the document using var(--variable_name). With a little javascript these variables can be used in Shiny apps and updated as needed. The example below contains three files: a shiny app (app.R), the CSS styling (style.css) and the associated javascript functions which update the CSS variables (var_change.js). The CSS and javascript files are stored in the www folder. This method works well under Chrome but does not work with Internet Explorer (css variables do not work under IE). Later on in this post we’ll see how to perform the same wholesale changes but with IE.\n\napp.R\n\nlibrary(shiny)\n\nintial_size &lt;- 20\nintial_color &lt;- 'orange'\n\nserver &lt;- function(input, output, session) {\n  \n  session$sendCustomMessage(\"col_change\", intial_color)\n  session$sendCustomMessage(\"size_change\", intial_size)\n  \n  observeEvent(input$but1, {\n    session$sendCustomMessage(\"col_change\", \"green\")\n  })\n  \n  observe({\n    session$sendCustomMessage(\"size_change\", input$sld1)\n  })\n}\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"style.css\"),\n    tags$script(src=\"var_change.js\")\n  ),\n  actionButton('but1', 'change color'),\n  sliderInput('sld1', 'change size', value = 20, min = 1, max = 100, step = 1),\n  h1(\"Heading 1\"),\n  h2(\"Heading 2\"),\n  h3(\"Heading 3\")\n)\n\nshinyApp(ui, server)\n\n\n\nstyle.css\n:root {\n  --heading-color: black;\n  --heading-size: 12px;\n}\n\nh1 {\n  color: var(--heading-color);\n  font-size: var(--heading-size);\n}\n\nh2 {\n  color: var(--heading-color);\n}\n\nh3 {\n  color: var(--heading-color);\n}\n\n\nvar_change.js\nShiny.addCustomMessageHandler(\"col_change\", col_change);\nShiny.addCustomMessageHandler(\"size_change\", size_change);\n\nfunction col_change(x) {\n  document.documentElement.style.setProperty('--heading-color', x);\n}\n\nfunction size_change(x) {\n  document.documentElement.style.setProperty('--heading-size', x + \"px\");\n}\n\n\n\nMethod Two - Not as elegant but does work with IE\n\napp.R\n\nlibrary(shiny)\n\nintial_size &lt;- 20\nintial_color &lt;- 'orange'\n\nserver &lt;- function(input, output, session) {\n  \n  session$sendCustomMessage(\"col_change\", intial_color)\n  session$sendCustomMessage(\"size_change\", intial_size)\n  \n  observeEvent(input$but1, {\n    session$sendCustomMessage(\"col_change\", \"green\")\n  })\n  \n  observe({\n    session$sendCustomMessage(\"size_change\", input$sld1)\n  })\n}\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"style.css\"),\n    tags$script(src=\"var_change.js\")\n  ),\n  actionButton('but1', 'change color'),\n  sliderInput('sld1', 'change size', value = 20, min = 1, max = 100, step = 1),\n  h1(\"Heading 1\", class = \"header_col_change header_size_change\"),\n  h2(\"Heading 2\", class = \"header_col_change\"),\n  h3(\"Heading 3\", class = \"header_col_change\")\n)\n\nshinyApp(ui, server)\n\n\n\nstyle.css\n\nheader_col_change {\n  color: black;\n}\n\nheader_size_change {\n  font-size: 12;\n}\n\n\nvar_change.js\nShiny.addCustomMessageHandler(\"col_change\", col_change);\nShiny.addCustomMessageHandler(\"size_change\", size_change);\n\nfunction col_change(x) {\n  $(\".header_col_change\").css('color', x)\n}\n\nfunction size_change(x) {\n  $(\".header_size_change\").css('fontSize', x)\n}"
  },
  {
    "objectID": "posts/2018/2018-05-23-r_package_update/index.html",
    "href": "posts/2018/2018-05-23-r_package_update/index.html",
    "title": "R 3.5.0 Package Update",
    "section": "",
    "text": "After our IT colleagues updated R to version 3.5.0 I found that I have many packages duplicated between the system library and my user library. This short piece of code lists all packages with their version for all libraries. It helps identify those that can be removed from the user library or updated.\n\n## assess user and system packages\n##\n\nlibrary(purrr)\nlibrary(dplyr)\n\ndf.all &lt;- as.data.frame(installed.packages()[,c(1:4, 16)], stringsAsFactors = FALSE)\ndf.split &lt;- split.data.frame(df.all, df.all$LibPath)\ndf.wide &lt;- reduce(df.split, full_join, by = 'Package')\nnames(df.wide) &lt;- c('Package', paste0(rep(c('libpath_', 'version_', 'priority_', 'built_'), length(df.split)), rep(seq(length(df.split)), each = 4)))\n\n## in library 2 but not 1\ndf.user_lib &lt;- df.wide %&gt;%\n  filter(is.na(libpath_1) & !is.na(libpath_2))\n\n## in both library 1 and 2\ndf.libs12 &lt;- df.wide %&gt;%\n  filter(!is.na(libpath_1) & !is.na(libpath_2))"
  },
  {
    "objectID": "posts/2018/2018-10-11-DT_callback_shiny_module/index.html",
    "href": "posts/2018/2018-10-11-DT_callback_shiny_module/index.html",
    "title": "Datatable Callback in Shiny Module",
    "section": "",
    "text": "Using shiny modules a large shiny application can be broken down into manageable chunks. Modules work well with most aspects of shiny code but care needs to be taken when referencing inputs. This is especially true when javascript is used within a module. Here’s a piece of code which uses a callback in a datatable to capture the current and previous row (something I use to allow automatic updating of a database when a row is changed). The important point is to remember to use session$ns in the server code whenever referencing an input created in the module.\n\nCode outside of a modules\n\n## callback to capture current and previous row - allows automatic updating of database when a new row is selected\ncallback = JS(\n  \"table.on('click.dt', 'tr', function() {\n    $(this).toggleClass('active');\n    if (typeof(current_row) === 'undefined') {\n      Shiny.onInputChange('assay_previous_row', null);\n    } else {\n      Shiny.onInputChange('assay_previous_row', current_row);\n    }\n    current_row = table.rows('.selected').data()[0][0];\n    Shiny.onInputChange('assay_selected_row', current_row);\n  });\"\n)\n\n\n\nCode within a shiny modules\n\n## callback to capture current and previous row - allows automatic updating of database when a new row is selected\ncallback = JS(paste0(\n  \"table.on('click.dt', 'tr', function() {\n    $(this).toggleClass('active');\n    if (typeof(current_row) === 'undefined') {\n      Shiny.onInputChange('\", session$ns('assay_previous_row'), \"', null);\n    } else {\n      Shiny.onInputChange('\", session$ns('assay_previous_row'), \"', current_row);\n    }\n    current_row = table.rows('.selected').data()[0][0];\n    Shiny.onInputChange('\", session$ns('assay_selected_row'), \"', current_row);\n  });\"\n))\n\nThis aproach can also be applied for functions within tables. For example here’s code for a delete button within a table.\n\n\nCode outside of a modules\n\ndelete = as.character(actionButton(paste0('newassaydelete_', newassay$counter), label = NULL, icon = icon('trash'), onclick = paste0('Shiny.onInputChange(\\\"delete_new_assay\\\", this.id)'), style=\"color: #fff; background-color: #cc0000; border-color: #660000\"))\n\n\n\nCode within a shiny modules\n\ndelete = as.character(actionButton(session$ns(paste0('newassaydelete_', newassay$counter)), label = NULL, icon = icon('trash'), onclick = paste0('Shiny.onInputChange(\\\"', session$ns('delete_new_assay'), '\\\", this.id)'), style=\"color: #fff; background-color: #cc0000; border-color: #660000\"))"
  },
  {
    "objectID": "posts/2021/2021-07-16-magrittr/index.html",
    "href": "posts/2021/2021-07-16-magrittr/index.html",
    "title": "Implementing magrittr",
    "section": "",
    "text": "magrittr is the pipe, commonly used in tidyverse packages, that enables simple sequencing of operators. The simple forward pipe replaces f(x, y) with x %&gt;% f(y). Code becomes much more readable when chaining multiple pipes together.\nIt’s very simple to use this in any package. the usethis package provides a command usethis::use_pipe() which takes care of everything for you. Once run, the magrittr pipe operator will be exported and available for users.\n\nadd_number &lt;- function(x, y) {\n  return(x + y)\n}\n\n3 %&gt;% \n  add_number(5) %&gt;% \n  add_number(2)\n\n[1] 10"
  },
  {
    "objectID": "posts/2021/2021-05-03-move_to_hugo/index.html",
    "href": "posts/2021/2021-05-03-move_to_hugo/index.html",
    "title": "A Switch to Hugo",
    "section": "",
    "text": "I don’t know why this took so long but I finally switched this blog from Jekyll to Hugo. Not that there’s anything wrong with Jekyll but I’ve been experimenting with Hugo a lot over the last year and I feel more comfortable with it. This is built on the clarity theme, a beautiful theme for blogging."
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html",
    "title": "Multiwindow App",
    "section": "",
    "text": "This is an initial concept of a framework for multiwindow shiny apps. Shiny is a great R package for building an interactive, web-based, graphical UI using R. It does, however, suffer from some limitations. One of these is the fact that a Shiny app runs in a single browser window. To make a more complex interface we can extend the browser window to full screen and add tab panels or scrollbars. Another concept is to break parts of the app into separate apps, each with their own window, separate but linked through a single data source (a single source of truth).\nIn this prototype, one app pushes data to a json file and two others read the data from this file using a reactiveFileReader. The reactiveFileReader ensures that any changes made to the data updates the apps that are dependent upon it. One additional shiny app (launcher) is responsible for opening and closing all other apps."
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html#launcherapp.r",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html#launcherapp.r",
    "title": "Multiwindow App",
    "section": "launcher/app.R",
    "text": "launcher/app.R\n\n## App lauuncher\n## This app manages all others\n\n\nlibrary(shiny)\nlibrary(shinyWidgets)\n\nserver &lt;- function(input, output, session) {\n  \n  ## create a temp folder with access permissions\n  jsonfile &lt;- tempfile(fileext = \".json\")\n  \n  ## replace this with the shiny server URL (subfolder = mutiwindow)\n  url_base &lt;- ###\n  \n  ## define app windows\n  app_windows &lt;- data.frame(\n    name = c(\"app_options\", \"app_graphics\", \"app_details\"),\n    app = c(\"app_options\", \"app_graphics\", \"app_details\"),\n    height = c(0.25, 0.4, 0.25),\n    width = c(0.095, 0.2, 0.095),\n    left = c(0.02, 0.02, 0.125),\n    top = c(0.02, 0.33, 0.02),\n    closable = c(TRUE, TRUE, TRUE),\n    stringsAsFactors = FALSE\n  )\n  app_windows$url &lt;- paste0(url_base, app_windows$app, \"/?file=\", jsonfile)\n  \n  \n  ## launch all apps\n  for (i in 1:nrow(app_windows)) {\n    session$sendCustomMessage(\"launch_app\", app_windows[i, ])\n  }\n  \n  observe({\n    req(!is.null(input$txt_com_file))\n    session$sendCustomMessage(\"disable\", \"txt_com_file\")\n  })\n  \n  output$ui_communications &lt;- renderUI({\n    column(10, offset = 1, textInput(\"txt_com_file\", label = \"Communications File\", width = \"100%\", value = jsonfile))\n  })\n  \n  \n  # app_options ------------------------------------------------------------------\n  \n  ## options UI\n  output$ui_app_options &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_options\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: setting options\")),\n      column(2, offset = 1, actionBttn(\"but_close_all\", label = \"Close All\", style = \"simple\", color = \"danger\", size = \"sm\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_options))\n    if (!app_windows[1, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_options\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_options, {\n    if (input$swt_app_options == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[1, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[1, ])\n    }\n  })\n\n\n  # app_graphics ------------------------------------------------------------------\n  \n  ## graphics UI\n  output$ui_app_graphics &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_graphics\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: plotting graphics\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_graphics))\n    if (!app_windows[2, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_graphics\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_graphics, {\n    if (input$swt_app_graphics == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[2, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[2, ])\n    }\n  })\n\n\n  # app_details ------------------------------------------------------------------\n  \n  ## details UI\n  output$ui_app_details &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_details\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: setting details\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_details))\n    if (!app_windows[3, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_details\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_details, {\n    if (input$swt_app_details == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[3, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[3, ])\n    }\n  })\n  \n  ## close all apps\n  observeEvent(input$but_close_all, {\n    for (i in 1:nrow(app_windows)) {\n      session$sendCustomMessage(\"close_app\", app_windows[i, ])\n    }\n  })\n\n}\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(type = \"text/javascript\", src = \"script.js\")\n  ),\n  br(),\n  br(),\n  fluidRow(column(10, offset = 1, \n                  panel(status = \"primary\", heading = \"App Launcher\",\n                        panel(status = \"danger\", heading = \"Communications\",\n                              uiOutput(\"ui_communications\")\n                        ),\n                        br(),\n                        panel(status = \"danger\", heading = \"App Windows\",\n                              fluidRow(uiOutput(\"ui_app_options\")),\n                              fluidRow(uiOutput(\"ui_app_graphics\")),\n                              fluidRow(uiOutput(\"ui_app_details\"))\n                        )\n                  )\n  ))\n)\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html#launcherwwwscript.js",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html#launcherwwwscript.js",
    "title": "Multiwindow App",
    "section": "launcher/www/script.js",
    "text": "launcher/www/script.js\n\nvar shiny_app_options = \"\";\nvar shiny_app_graphics = \"\";\nvar shiny_app_details = \"\";\n\n// launch a shiny app in a minimal window\n// window opens with a specified size at a specified screen location (based on fraction of total screen width and height)\nShiny.addCustomMessageHandler('launch_app', function(x) {\n  scr_height = window.screen.height;\n  scr_width = window.screen.width;\n  window_height = scr_height * x.height;\n  window_width = scr_width * x.width;\n  window_left = scr_width * x.left;\n  window_top = scr_height * x.top;\n  window_options = \"height=\" + window_height + \", width=\" + window_width + \", left=\" + window_left + \", top=\" + window_top;\n  \n  if (x.name == \"app_options\") {\n    shiny_app_options = window.open(x.url, x.name, window_options);\n  } else if (x.name == \"app_graphics\") {\n    shiny_app_graphics = window.open(x.url, x.name, window_options);\n  } else if (x.name == \"app_details\") {\n    shiny_app_details = window.open(x.url, x.name, window_options);\n  }\n});\n\n// close a shiny app\nShiny.addCustomMessageHandler('close_app', function(x) {\n  console.log(x.name);\n  // can't pass window name as variable to close so have to hardcode :(\n  if (x.name == \"app_options\") {\n    console.log('close app_options');\n    shiny_app_options.close();\n  } else if (x.name == \"app_graphics\") {\n    console.log('close app_graphics');\n    shiny_app_graphics.close();\n  } else if (x.name == \"app_details\") {\n    console.log('close app_details');\n    shiny_app_details.close();\n  }\n});\n\n// disable a shiny input\nShiny.addCustomMessageHandler('disable', function(id) {\n  var input_type = $(\"#\" + id).prop(\"type\");\n  if (input_type.startsWith(\"select\")) {\n    $(\"#\" + id)[0].selectize.disable();\n  } else {\n    $(\"#\" + id).prop(\"disabled\", true);\n  }\n});"
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html#app_optionsapp.r",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html#app_optionsapp.r",
    "title": "Multiwindow App",
    "section": "app_options/app.R",
    "text": "app_options/app.R\n\n## app_options\n## A simple app that offers a series of options\n\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  filename &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$file)) {\n      query$file\n    } else {\n      \"\"\n    }\n  })\n  \n  output$ui_axes &lt;- renderUI({\n    req(input$sel_data)\n    ## select x and y parameters from numeric columns\n    df &lt;- get(input$sel_data)\n    columns &lt;- names(df)[sapply(df, class) == \"numeric\"]\n    tagList(\n      selectizeInput(\"sel_x\", \"X parameter\", choices = columns),\n      selectizeInput(\"sel_y\", \"Y parameter\", choices = columns)\n    )\n  })\n  \n  ## write file when updating parameter\n  observeEvent(input$sel_data, {\n    write_file()\n  })\n  \n  observeEvent(input$sel_x, {\n    write_file()\n  })\n  \n  observeEvent(input$sel_y, {\n    write_file()\n  })\n  \n  ## write a file\n  write_file &lt;- function() {\n    if (filename() != \"\") {\n      output &lt;- list(\n        data = input$sel_data,\n        x = input$sel_x,\n        y = input$sel_y\n      )\n      json_out &lt;- toJSON(output, auto_unbox = TRUE, null = \"null\")\n      con &lt;- file(filename(), open = \"wt\")\n      writeLines(json_out, con)\n      close(con)\n    }\n  }\n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Options\", status = \"primary\",\n        selectizeInput(\"sel_data\", \"dataset\", choices = c(\"iris\", \"mtcars\")),\n        uiOutput(\"ui_axes\")\n        )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html#app_graphicsapp.r",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html#app_graphicsapp.r",
    "title": "Multiwindow App",
    "section": "app_graphics/app.R",
    "text": "app_graphics/app.R\n\n## app_graphics\n## A simple app that draws a ggplot\n\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(ggplot2)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  filename &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$file)) {\n      query$file\n    } else {\n      \"\"\n    }\n  })\n  \n  ## retrieve data from file\n  json_data &lt;- reactiveFileReader(2000, session, filePath = filename, readFunc = function(filePath) {\n    tryCatch({\n      con &lt;- file(filePath)\n      file_contents &lt;- readLines(con)\n      close(con)\n      file_contents\n    },\n    error = function(e) NA\n    )\n  })\n  \n  output$plt &lt;- renderPlot({\n    req(json_data())\n    \n    ## check all plotting parameters are present\n    params &lt;- c(\"data\", \"x\", \"y\")\n    data &lt;- fromJSON(json_data())\n    if (all(sapply(params, function(x) !is.null(data[[x]])))) {\n      ggplot(get(data[[\"data\"]]), aes(x = .data[[data[[\"x\"]]]], y = .data[[data[[\"y\"]]]])) +\n        geom_point() +\n        labs(title = paste0(\"Plot data = \", data[[\"data\"]]),\n             x = data[[\"x\"]], \n             y = data[[\"y\"]])\n    }\n\n  })\n  \n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Graphics\", status = \"primary\",\n        plotOutput(\"plt\")\n  )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html#app_detailsapp.r",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html#app_detailsapp.r",
    "title": "Multiwindow App",
    "section": "app_details/app.R",
    "text": "app_details/app.R\n\n## app_details\n## A simple app that lists some details\n\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  filename &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$file)) {\n      query$file\n    } else {\n      \"\"\n    }\n  })\n  \n  ## retrieve data from file\n  json_data &lt;- reactiveFileReader(2000, session, filePath = filename, readFunc = function(filePath) {\n    tryCatch({\n      con &lt;- file(filePath)\n      file_contents &lt;- readLines(con)\n      close(con)\n      file_contents\n    },\n    error = function(e) NA\n    )\n  })\n  \n  output$txt_details &lt;- renderPrint({\n    prettify(json_data())\n  })\n  \n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Output\", status = \"primary\",\n        verbatimTextOutput(\"txt_details\")\n  )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html",
    "href": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html",
    "title": "Passing a Mixture of Reactive and Non-Reactives to a Shiny Module",
    "section": "",
    "text": "Generally there is no issue in sending a list of parameters (reactive and non-reactive) to a shiny module. Here’s an example where a shiny module would be called multiple times, programatically, where the reactive nature of the parameters may be variable (reactive in one instance but not in another). One way to deal with this is to read in the list of parameters and convert the non-reactive ones to reactive. Those originally reactive, remain so and therefore update on a change. In the examples below a single reactive or non-reactive list is passed from the parent shiny app to a shiny module. The concept works for a single or multiple inputs."
  },
  {
    "objectID": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-1---this-shiny-module-will-fail",
    "href": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-1---this-shiny-module-will-fail",
    "title": "Passing a Mixture of Reactive and Non-Reactives to a Shiny Module",
    "section": "Example 1 - this shiny module will fail",
    "text": "Example 1 - this shiny module will fail\nThis version of the shiny module fill fail - it expects a reactive but is passed a non-reactive.\n\nlibrary(shiny)\n\nappmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  verbatimTextOutput(ns(\"txt\"))\n}\n\nappmod &lt;- function(input, output, session, inputlist) {\n\n  output$txt &lt;- renderPrint({\n    message(\"Updating renderPrint\")\n    print(inputlist()[[\"val1\"]])\n    print(inputlist()[[\"val2\"]])\n  })\n\n}\n\nui &lt;- fluidPage(\n  appmod_UI(\"mod1\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  callModule(appmod, \"mod1\", inputlist = list(val1 = \"value 1\", val2 = \"value 2\"))\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-2---reacive-expected-and-reactive-passed",
    "href": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-2---reacive-expected-and-reactive-passed",
    "title": "Passing a Mixture of Reactive and Non-Reactives to a Shiny Module",
    "section": "Example 2 - reacive expected and reactive passed",
    "text": "Example 2 - reacive expected and reactive passed\nThis is a simple example of a shiny module that will work. It expects a reactive which is exactly what is passed to the module.\n\nlibrary(shiny)\n\nappmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  verbatimTextOutput(ns(\"txt\"))\n}\n\nappmod &lt;- function(input, output, session, inputlist) {\n\n  message(\"Starting shiny module\")\n\n  if (is.reactive(inputlist)) {\n    message(\"Returning inputlist\")\n    inputlist_1 &lt;- inputlist\n  } else {\n    message(\"Returning reactive inputlist\")\n    inputlist_1 &lt;- reactive(inputlist)\n  }\n\n  output$txt &lt;- renderPrint({\n    message(\"Updating renderPrint\")\n    print(inputlist_1()[[\"val1\"]])\n    print(inputlist_1()[[\"val2\"]])\n  })\n\n}\n\nui &lt;- fluidPage(\n  appmod_UI(\"mod1\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  callModule(appmod, \"mod1\", inputlist = reactive(list(val1 = \"value 1\", val2 = \"value 2\")))\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-3---reacive-expected-and-non-reactive-passed",
    "href": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-3---reacive-expected-and-non-reactive-passed",
    "title": "Passing a Mixture of Reactive and Non-Reactives to a Shiny Module",
    "section": "Example 3 - reacive expected and non-reactive passed",
    "text": "Example 3 - reacive expected and non-reactive passed\nAnother example of a shiny module that will work. In this case the non-reactive passed to the shiny module is converted into a reactive.\n\nlibrary(shiny)\n\nappmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  verbatimTextOutput(ns(\"txt\"))\n}\n\nappmod &lt;- function(input, output, session, inputlist) {\n\n  message(\"Starting shiny module\")\n\n  if (is.reactive(inputlist)) {\n    message(\"Returning inputlist\")\n    inputlist_1 &lt;- inputlist\n  } else {\n    message(\"Returning reactive inputlist\")\n    inputlist_1 &lt;- reactive(inputlist)\n  }\n\n  output$txt &lt;- renderPrint({\n    message(\"Updating renderPrint\")\n    print(inputlist_1()[[\"val1\"]])\n    print(inputlist_1()[[\"val2\"]])\n  })\n}\n\nui &lt;- fluidPage(\n  appmod_UI(\"mod1\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  callModule(appmod, \"mod1\", inputlist = list(val1 = \"value 1\", val2 = \"value 2\"))\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-4---reacive-expected-and-non-reactive-passed",
    "href": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-4---reacive-expected-and-non-reactive-passed",
    "title": "Passing a Mixture of Reactive and Non-Reactives to a Shiny Module",
    "section": "Example 4 - reacive expected and non-reactive passed",
    "text": "Example 4 - reacive expected and non-reactive passed\nFinal example of a shiny module that will work. In this case a reactive is passed and then changed (forcing an update in the shiny module).\n\nlibrary(shiny)\n\nappmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  verbatimTextOutput(ns(\"txt\"))\n}\n\nappmod &lt;- function(input, output, session, inputlist) {\n\n  message(\"Starting shiny module\")\n\n  if (is.reactive(inputlist)) {\n    message(\"Returning inputlist\")\n    inputlist_1 &lt;- inputlist\n  } else {\n    message(\"Returning reactive inputlist\")\n    inputlist_1 &lt;- reactive(inputlist)\n  }\n\n  output$txt &lt;- renderPrint({\n    message(\"Updating renderPrint\")\n    print(inputlist_1()[[\"val1\"]])\n    print(inputlist_1()[[\"val2\"]])\n  })\n\n\n}\n\nui &lt;- fluidPage(\n  appmod_UI(\"mod1\"),\n  actionButton(\"but_update\", \"Update Values\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  rv &lt;- reactiveValues(\n    i = list()\n  )\n\n  observe({\n    message(\"Define initial values\")\n    rv$i &lt;- list(val1 = \"value 1\", val2 = \"value 2\")\n  })\n\n  callModule(appmod, \"mod1\", inputlist = reactive(rv$i))\n\n  observeEvent(input$but_update, {\n    message(\"Button press\")\n    rv$i[[\"val1\"]] &lt;- \"value 3\"\n  })\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-11-30-learnr_distill/index.html",
    "href": "posts/2021/2021-11-30-learnr_distill/index.html",
    "title": "Embedding {learnr} in {distill}",
    "section": "",
    "text": "{learnr} is an R package from RStudio which uses R Markdown to create interactive tutorials. Once completed, the tutorial can be published via shiny server or RStudio Connect. As a {learnr} markdown file contains its own yaml header it cannot be directly included in a website built by distill. It can, however, be included if it is hosted (shiny server or RStudio Connect) and embedded using iframe\n\n```{r, layout=\"l-screen-inset\"}\nhtmltools::tags$iframe(src = \"&lt;RSCONNECT URL&gt;\", height = \"600px\", width = \"100%\", `data-external` = \"1\")\n```\n\nwhere  is the url of the {learnr} tutorial. The use of data-external is related to the way that pandoc processes iframe tags (see https://community.rstudio.com/t/insert-raw-html-iframe-into-rmarkdown/94334 and https://pandoc.org/MANUAL.html#option–self-contained)."
  },
  {
    "objectID": "posts/2021/2021-10-10-R6_shiny_mod/index.html",
    "href": "posts/2021/2021-10-10-R6_shiny_mod/index.html",
    "title": "Connecting shiny modules through R6",
    "section": "",
    "text": "Here’s a simple example of working with a reactive R6 in a shiny app. It is inspired by a post to RStudio Community (https://community.rstudio.com/t/good-way-to-create-a-reactive-aware-r6-class/84890) and uses the code provided by Winston Chang to create an R6 class that is reactive. The example code is located in https://github.com/harveyl888/reactive_R6.\nI can see two advantages and one disadvantage to using a reactive R6 class in a shiny app.\n\n\n\nA single class instance can be shared between all shiny modules. This is particularly useful when working with shiny modules that are interdependent - ie content in module A is dependent on modules B and C, content in module B is dependent on modules A and C and content in module C is dependent on modules A and B. Using a reactive class means that we would simply send the class instance to each module. Any changes made to the class would automatically update in all shiny modules.\nThe R6 class instance itself can be saved and read back in at a later date, essentially providing a snapshot. Saving and reimporting the class instance is a great way to keep a set of complex data together.\n\n\n\n\n\nSince updating the class triggers a refresh, some reactive outputs may be updated when their content has not changed. This is due to the class itself being reactive.\n\nIn this post I’ll demonstrate a reactive R6 class called Analysis using a simple PCA and clustering example."
  },
  {
    "objectID": "posts/2021/2021-10-10-R6_shiny_mod/index.html#introduction",
    "href": "posts/2021/2021-10-10-R6_shiny_mod/index.html#introduction",
    "title": "Connecting shiny modules through R6",
    "section": "",
    "text": "Here’s a simple example of working with a reactive R6 in a shiny app. It is inspired by a post to RStudio Community (https://community.rstudio.com/t/good-way-to-create-a-reactive-aware-r6-class/84890) and uses the code provided by Winston Chang to create an R6 class that is reactive. The example code is located in https://github.com/harveyl888/reactive_R6.\nI can see two advantages and one disadvantage to using a reactive R6 class in a shiny app.\n\n\n\nA single class instance can be shared between all shiny modules. This is particularly useful when working with shiny modules that are interdependent - ie content in module A is dependent on modules B and C, content in module B is dependent on modules A and C and content in module C is dependent on modules A and B. Using a reactive class means that we would simply send the class instance to each module. Any changes made to the class would automatically update in all shiny modules.\nThe R6 class instance itself can be saved and read back in at a later date, essentially providing a snapshot. Saving and reimporting the class instance is a great way to keep a set of complex data together.\n\n\n\n\n\nSince updating the class triggers a refresh, some reactive outputs may be updated when their content has not changed. This is due to the class itself being reactive.\n\nIn this post I’ll demonstrate a reactive R6 class called Analysis using a simple PCA and clustering example."
  },
  {
    "objectID": "posts/2021/2021-10-10-R6_shiny_mod/index.html#the-reactive-class",
    "href": "posts/2021/2021-10-10-R6_shiny_mod/index.html#the-reactive-class",
    "title": "Connecting shiny modules through R6",
    "section": "The Reactive Class",
    "text": "The Reactive Class\nThe main part of the code is the reactive class. Our class is built up from the code in the RStudio Community article when the class is initialized as reactive using Analysis$new(data=mydata)$reactive() (chaining), or by running the reactive() method on an initialized class instance, a couple of things occur:\n\na reactiveVal, reactiveDep is created, linked to a counter, which increases when the private invalidate() method is called.\na reactive expression, reactiveExpr is created which updates when reactiveDep changes.\n\nThe skeleton for the reactive R6 class is shown below:\n\nAnalysis &lt;- R6Class(\"Analysis\",\n                               public = list(\n                                   initialize = function(data = NULL) {\n                                       private$reactiveDep &lt;- function(x) NULL\n                                    },\n                                    reactive = function() {\n                                        # Ensure the reactive stuff is initialized.\n                                        if (is.null(private$reactiveExpr)) {\n                                            private$reactiveDep &lt;- reactiveVal(0)\n                                            private$reactiveExpr &lt;- reactive({\n                                                private$reactiveDep()\n                                                self\n                                            })\n                                        }\n                                        private$reactiveExpr\n                                    },\n                               ),\n                               private = list(\n                                   reactiveDep = NULL,\n                                   reactiveExpr = NULL,\n                                   invalidate = function() {\n                                       private$count &lt;- private$count + 1\n                                       private$reactiveDep(private$count)\n                                       invisible()\n                                    },\n                                    count = 0\n                               )\n                    )\n\nThe invalidate method can be used to invalidate the reactive class. This is used when calling other methods that update the class contents. Invalidating the class forces an update in the shiny app of anything that is dependent on the class instance. In our example, the Analysis class contains the following reactive methods:\nfilter(), pca(), cluster() and set_clusters()\nand the following non-reactive methods:\nimport(), get_data() and print()."
  },
  {
    "objectID": "posts/2021/2021-10-10-R6_shiny_mod/index.html#use-in-shiny-app",
    "href": "posts/2021/2021-10-10-R6_shiny_mod/index.html#use-in-shiny-app",
    "title": "Connecting shiny modules through R6",
    "section": "Use in Shiny App",
    "text": "Use in Shiny App\nOne use of this class is in a complex shiny app with many shiny modules. Using a reactive class simplifies the data that needs to be passed between the modules. This is particularly true when there are multiple dependencies. In this case, we define our class and assign it to a reactiveValue which is then shared between shiny modules. When the class instance is updated it is reflected in all the shiny modules; no data need be returned from one class and passed to another. The class instance is defined in the app.R server function as follows:\n\ndata &lt;- iris\n\nrv &lt;- reactiveValues(\n    analysis = NULL\n)\n\nobserve({\n    analysis &lt;- Analysis$new(data)\n    analysis$pca()\n    analysis$cluster()\n    rv$analysis &lt;- analysis$reactive()\n})\n\nHere, a class instance is initiated using iris data, PCA and clustering methods are run and the result is stored in a reactiveValue which is then passed to each of the shiny modules.\ngraph TB\n  subgraph rv$analysis\n    app.R --&gt; mod_data.R;\n    app.R --&gt; mod_multivariate.R;\n    app.R --&gt; mod_cluster.R;\n  end\nEach shiny module sits in a different tab which look as follows:\n\n\n\nUpon changing the data (for example filtering), the reactive class is updated, triggering updates of all dependent outputs in all shiny modules:"
  },
  {
    "objectID": "posts/2021/2021-10-10-R6_shiny_mod/index.html#conclusion",
    "href": "posts/2021/2021-10-10-R6_shiny_mod/index.html#conclusion",
    "title": "Connecting shiny modules through R6",
    "section": "Conclusion",
    "text": "Conclusion\nReactive R6 classes in shiny apps provides a useful way to share complex data and parameters across multiple interdependent shiny modules. Example code can be found in https://github.com/harveyl888/reactive_R6."
  },
  {
    "objectID": "posts/2019/2019-02-19-shiny_notifications/index.html",
    "href": "posts/2019/2019-02-19-shiny_notifications/index.html",
    "title": "Alerts in Chrome and IE",
    "section": "",
    "text": "The sendSweetAlert function from the shinyWidgets package is a great way to communicate behavior to an end-user. As of version 0.4.9 shinyWidgets now uses SweetAlert2 which is no longer compatible with Internet Explorer thus breaking historical apps which use this feature. This is due to the fact that IE does not support arrow functions.\nOne workaround is to switch from using sweetalert to using shiny’s built in showNotification function. This function works under both Chrome and IE but is not as customizable or beautiful as sweetalert. Another alternative is to identify the browser and provide a sweetalert if running Chrome or shiny notification if not. This is achieved by using javascript to assign a shiny INPUT (input$chrome) variable and using this value to determine whch type of notification to show.\n\nIncluded in UI\n\ntags$script(HTML(\n      '$(document).on(\"shiny:sessioninitialized\", function(event) {\n      var runningChrome = /Chrome/.test(navigator.userAgent);\n      Shiny.setInputValue(\"chrome\", runningChrome);\n    });'\n\n\n\nIncluded in server\n\nshow_alert &lt;- function(session = getDefaultReactiveDomain(), chrome_browser = FALSE, title = NULL, text = NULL, type = 'error', btn_labels = NULL) {\n  if (!type %in% c('info', 'success', 'warning', 'error')) type &lt;- 'info'\n  if (chrome_browser) {\n    if (!is.null(btn_labels)) {\n      sendSweetAlert(session = session, title = title, text = text, type = type, btn_labels = btn_labels, closeOnClickOutside = TRUE)\n    } else {\n      sendSweetAlert(session = session, title = title, text = text, type = type, closeOnClickOutside = TRUE)\n    }\n  } else {\n    text &lt;- str_replace(text, '\\\\n', '&lt;br&gt;')\n    if (type == 'info') type &lt;- 'default'\n    if (type == 'success') type &lt;- 'message'\n    showNotification(session = session, ui = title, action = HTML(text), type = type)\n  }\n}\n\nThe show_alert function takes a session variable, chrome_browser logical and some additional pararmeters to build a notification."
  },
  {
    "objectID": "posts/2019/2019-12-26-check_cas/index.html",
    "href": "posts/2019/2019-12-26-check_cas/index.html",
    "title": "Checking internal consistency of CAS numbers",
    "section": "",
    "text": "CAS numbers consist of three numbers separated by dashes. The first comprises of two to seven digits, the second is two digits and the third is one digit. The last number is, in fact, a check digit for the rest of the code. It’s simple to check if a CAS number contains an error by calculating a checksum as follows:\n\nRemove the last digit and all dashes\nReverse the rest of the digits\nMultiply the first digit by one, the second by two, and so on\nSum the multiplied values\nTake the modulo of ten of this sum\nThis should equal the check digit\n\nFor example, the CAS number for ethanol is 64-17-5.\nChecking: (7 x 1) + (1 x 2) + (4 x 3) + (6 x 4) = 45. 45 mod 10 = 5 (which is the check digit).\nAs a function in R this is:\n\ncas_check &lt;- function(cas) {\n  cas_split &lt;- strsplit(cas, '-')[[1]]\n  cas_validation &lt;- as.numeric(cas_split[3])\n  cas_to_check &lt;- as.numeric(rev(strsplit(paste0(cas_split[1], cas_split[2]), '')[[1]]))\n  cas_sum &lt;- sum(cas_to_check * seq(length(cas_to_check)))\n  return(cas_sum %% 10 == cas_validation)\n}\n\n\ncas_check(\"64-17-5\")\n\n[1] TRUE"
  },
  {
    "objectID": "posts/2019/2019-08-26-extract_pdf/index.html",
    "href": "posts/2019/2019-08-26-extract_pdf/index.html",
    "title": "Extracting data from LCMS PDF",
    "section": "",
    "text": "Here’s an example of using R to extract tabular content and metadata from a series of pdf files and push the data into a single table. The concept is fairly straightforward - read in PDF and convert to text, parse each line and use regular expressions to extract pertinent information.\nThree types of data are returned:\n\npeak data. Peak number, retention time, type, width, area and name. In fact all columns will be extracted from the table along with the column identifiers and units.\nmetadata. In this case injection date, data file name and sample name are pulled from the pdfs.\nfile data. The pdf file name and page containing the peak table.\n\nThe pdftools library is used to read in the PDF files.\n\nUnwanted or Missing spaces\nSo why use column identifiers from the table header instead of just splitting table columns using a delimeter such as a tab? Unfortunately tabular information is lost when the pdf is imported and any tabs are converted into spaces. A space character column delimeter could be used if all columns are populated and the sample names did not contain spaces. For these tables, however, the Type column is not always populated and the Name column can contain spaces. Therefore there is no way to be sure that we are accurately identifying the end of one column and beginning of another using delimeters.\nAn additional issue arises because when the pdf is imported some unexpected formatting issues can arise, particularly with respect to unwanted or missing spaces. To account for this when parsing the table we can nudge forward or back to identify spaces between values. This can be seen in the alignment of line 3 of the table below (pdf vs parsed text).\n\n\n\nPDF Version\n\n\n\n\n\nParsed Version\n\n\n\n\nCode\n\n## table_extract\n## extract table contents along with headers\n## this allows sample names to be retrieved too\n## uses heading underline separators to determine column widths\n\nlibrary(pdftools)\nlibrary(stringr)\nlibrary(dplyr)\n\nfolder &lt;- 'test_01'\n\n## identify files\nf_names &lt;- list.files(path = folder, pattern = '.pdf', full.names = TRUE)\n\n## loop over all files\nl.df &lt;- lapply(f_names, function(f) {\n  \n  txt &lt;- pdf_text(f)\n  \n  ## split text at carriage return\n  txt1 &lt;- strsplit(txt, '\\r\\n')\n  \n  ## loop over lines and retrieve table contents\n  l &lt;- list()\n  l_all &lt;- list()\n  read_table &lt;- FALSE\n  for (i in 1:length(txt1)) { # loop through pages\n    for (j in 1:length(txt1[[i]])) { # loop through lines\n      line &lt;- txt1[[i]][j]\n      \n      if (str_detect(line, 'Totals :')) { # end of record\n        read_table &lt;- FALSE\n        df.data &lt;- as.data.frame(do.call(rbind, l_data), stringsAsFactors = FALSE)\n        df.data$date &lt;- l[['date']]\n        df.data$data_file &lt;- l[['data_file']]\n        df.data$sample_name &lt;- l[['sample_name']]\n        df.data$pdf_file &lt;- basename(f)\n        df.data$page &lt;- i\n        l[['data']] &lt;- df.data\n        l_all[[length(l_all) + 1]] &lt;- l\n        l &lt;- list()  ## reset list\n      } else if  (str_detect(line, 'Injection Date')) { # found inj date\n        inj_date &lt;- as.POSIXct(str_extract(line, '\\\\d+/\\\\d+/\\\\d+ \\\\d+:\\\\d+:\\\\d+ [A|P]M'), format = '%m/%d/%Y %I:%M:%S %p')\n        l$date &lt;- inj_date\n        l_data &lt;- list()\n      } else if (str_detect(line, 'Peak RetTime')) { # found table\n        table_headers &lt;- line   ## save table headers for later use\n        read_table &lt;- TRUE\n      } else if (str_detect(line, 'Data File')) {\n        l[['data_file']] &lt;- basename(txt1[[2]][1])\n      } else if (str_detect(line, 'Sample Name:')) {\n        l[['sample_name']] &lt;- str_replace(line, 'Sample Name: ', '')\n      }\n      \n      if (read_table) {\n        \n        if (str_detect(line, '\\\\[min\\\\]')) { # found second header line\n          table_headers_2 &lt;- line   ## save table headers for later use\n        }\n        \n        if (!str_detect(line, '\\\\[min\\\\]') & !str_detect(line, 'Peak RetTime')) {\n          if (str_detect(line, '--|--')) { ## found separator line\n            locate_separators &lt;- str_locate_all(line, '\\\\|')\n            locate_separators &lt;- c(1, locate_separators[[1]][,1], nchar(line))\n            txt_headings &lt;- sapply(seq_along(locate_separators[-1]), function(x) {\n              trimws(substring(table_headers, locate_separators[x], locate_separators[x+1]))\n            })\n            \n            txt_headings_2 &lt;- sapply(seq_along(locate_separators[-1]), function(x) {\n              trimws(substring(table_headers_2, locate_separators[x], locate_separators[x+1]))\n            })\n            \n            txt_headings &lt;- sapply(seq_along(txt_headings), function(x) {\n              if (nchar(txt_headings_2[x]) &gt; 0) {\n                sprintf('%s (%s)', txt_headings[x], txt_headings_2[x])\n              } else {\n                txt_headings[x]\n              }\n            })\n            \n          } else {  ## found data\n            \n            ## add a space to the end of the line\n            ## necessary for identifying end-of-data points\n            line &lt;- paste0(line, ' ')\n            \n            data &lt;- sapply(seq_along(locate_separators[-1]), function(x) {\n              \n              ## sometimes text pull needs to start a few characters back\n              ## (due to import conversion of tabs to spaces)\n              start_pos &lt;- locate_separators[x]\n              end_pos &lt;- locate_separators[x+1]\n              \n              if (substring(line, start_pos, start_pos) != ' ') {\n                found_space &lt;- FALSE\n                while (!found_space & start_pos &gt; 2) {\n                  start_pos &lt;- start_pos - 1\n                  if (substring(line, start_pos, start_pos) == ' ') found_space &lt;- TRUE\n                }\n              }\n              \n              if (substring(line, end_pos, end_pos) != ' ') {\n                found_space &lt;- FALSE\n                while (!found_space & end_pos &gt; 2) {\n                  end_pos &lt;- end_pos - 1\n                  if (substring(line, end_pos, end_pos) == ' ') found_space &lt;- TRUE\n                }\n              }\n              \n              trimws(substring(line, start_pos, end_pos))\n            })\n            l_data[[length(l_data) + 1]] &lt;- setNames(data, txt_headings)\n          }\n        }\n      }\n    }\n  }\n  \n  ## join tables\n  df &lt;- do.call(rbind, lapply(l_all, function(x) x$data))\n  \n  ## convert table columns to numeric\n  for (n in names(df)) {\n    if (all(grepl(\"^(-|\\\\+)?((\\\\.?\\\\d+)|(\\\\d+\\\\.\\\\d+)|(\\\\d+\\\\.?)|(\\\\d*\\\\.*\\\\d+[E|e](-|\\\\+)\\\\d+))$\", df[[n]]))) {\n      df[[n]] &lt;- as.numeric(df[[n]])\n    }\n  }\n  df\n})\n\ndf_all &lt;- do.call(rbind, l.df)\n\nwrite.csv(df_all, 'table_out.csv', row.names = FALSE)\n\n\n\nInput File Example"
  },
  {
    "objectID": "posts/2019/2019-12-14-cas_from_pdf/index.html",
    "href": "posts/2019/2019-12-14-cas_from_pdf/index.html",
    "title": "CAS from pdf",
    "section": "",
    "text": "It’s relatively easy to extract CAS numbers from a PDF. I’ve used this to scrape chemical catalogs, subsequently using the CAS numbers to look up additional information through PubChem. CAS numbers are easier to scrape than most other chemical information, such as name, formula or catalog number, as they follow a specific format.\nIt can be accomplished using a couple of lines of code in R (or collapsed into a single line if you prefer). The code below returns all CAS numbers from a file, f.\n\npdf_to_cas &lt;- function(f) {\n  txt &lt;- pdftools::pdf_text(f)\n  cas_numbers &lt;- trimws(unlist(stringr::str_extract_all(txt, '[0-9]+[\\u2011|-][0-9]{2}[\\u2011|-][0-9](?![0-9])')))\n  return(cas_numbers)\n}\n\nThe regular expression [0-9]+[\\u2011|-][0-9]{2}[\\u2011|-][0-9](?![0-9]) can be broken down as follows:\n\n\n\n\n\n\n\n[0-9]+\none or more digits\n\n\n[\\u2011|-]\na dash or an unbreaking hyphen\n\n\n[0-9]{2}-\nexactly two digits\n\n\n[\\u2011|-]\na dash or an unbreaking hyphen\n\n\n[0-9](?![0-9])\na single digit followed by anything other than a digit using a negative lookahead"
  },
  {
    "objectID": "posts/2019/2019-03-15-visnetwork_continuous/index.html",
    "href": "posts/2019/2019-03-15-visnetwork_continuous/index.html",
    "title": "visNetwork Continuous Colors",
    "section": "",
    "text": "visNetwork is a fantastic library used to make interactive network graphs in R. It has many features to style nodes and edges but lacks a way to fill nodes using a continuous variable. ThIs can readily be achieved by using findInterval to map a continuous variable to the closest color on a color scale. In the example below a random data set is generated with a probability between zero a one attached to each node. Color is then assigned from a palette of 101 shades of blue. The resultant graph illustrates the effect of coloring using a continuous variable - higher probabilities are darker (label = node number and probability).\n\n## visNetwork continuous color\n\nlibrary(visNetwork)\nlibrary(igraph)\nlibrary(dplyr)\nlibrary(RColorBrewer)\n\n## define number of nodes, edges and colors\n\nn_nodes &lt;- 100\nn_edges &lt;- 200\nn_cols &lt;- 101\npal &lt;- colorRampPalette(brewer.pal(9, 'Blues'))(n_cols)\n\n## create graph from random edges\n## p is a variable for color coding from 0 to 1\n\ndf.nodes &lt;- data.frame(id = seq(n_nodes), p = runif(seq(n_nodes))) %&gt;%\n  mutate(label = sprintf('n %i (%0.2f)', id, p)) %&gt;%\n  mutate(c_ref = findInterval(p, seq(from = 0, to = 1, length.out = n_cols))) %&gt;%\n  mutate(color = pal[c_ref])\n  \ndf.edges &lt;- data.frame(from = sample(seq(n_nodes), n_edges, replace = TRUE), to = sample(seq(n_nodes), n_edges, replace = TRUE))\n\nvisNetwork(nodes = df.nodes ,edges = df.edges) %&gt;%\n  visIgraphLayout()"
  },
  {
    "objectID": "posts/2019/2019-01-31-formattable/index.html",
    "href": "posts/2019/2019-01-31-formattable/index.html",
    "title": "Formattable - color data according to RSD",
    "section": "",
    "text": "Formattable is a powerful R library used to format tables. There are many built-in functions which allow a user to style tables using color, bars ad icons. In addition you can create your own custom formatters. Below is an example of how to color a data frame using information from a second data frame. Average values are colored red if the RSD is greater than 0.15 and green if it is below.\nThis was developed in order to represent a large table of data color-coded accordng to RSD so that the analyst could quickly identify potential sources of systematic error.\n\n\n\ntable of data\n\n\n\n\n\ntable of RSDs\n\n\n\n\n\ntable of data color-coded according to RSDs\n\n\n\nCode\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(formattable)\n\n## generate some dummy data\n\ndf_dummy &lt;- data.frame(sample = rep(sprintf('sample_%02i', 1:10), 4),\n                       value_A = rnorm(40, 100, 5),\n                       value_B = rnorm(40, 100, 15),\n                       value_C = rnorm(40, 100, 25),\n                       stringsAsFactors = FALSE)\n\n## calculate stats\n\ndf_stats &lt;- df_dummy %&gt;%\n  gather(ref, value, -sample) %&gt;%\n  group_by(sample, ref) %&gt;%\n  summarise(avg = mean(value), \n            stdev = sd(value)) %&gt;%\n  mutate(rsd = stdev / avg)\n\n## pull out a table of average results\n\ndf_avg &lt;- df_stats %&gt;%\n  select(sample, ref, avg) %&gt;%\n  spread(ref, avg)\n\n## pull out a table of RSDs\n\ndf_rsd &lt;- df_stats %&gt;%\n  select(sample, ref, rsd) %&gt;%\n  spread(ref, rsd)\n\n## create a series of formatters, one for each data column\n\nfmt &lt;- lapply(1:(ncol(df_rsd)-1), function(y) {\n  d &lt;- df_rsd[[y + 1]]\n  colors &lt;- sapply(d, function(x) ifelse(x &lt;= 0.15, '#81C784', '#e57373'))\n  \n  formatter(\"span\", \n            style = style(display = 'block',\n                          padding = '0 4px',\n                          `border-radius` = '4px',\n                          `background-color` = colors))\n})\n\n## name list items \n\nl.fmt &lt;- setNames(lapply(1:(ncol(df_avg)-1), function(x) fmt[[x]]), names(df_avg)[2:ncol(df_avg)])\n\n## create table\n\nformattable(df_avg, l.fmt)"
  },
  {
    "objectID": "posts/2017/2017-10-26-plotly_errorbars/index.html",
    "href": "posts/2017/2017-10-26-plotly_errorbars/index.html",
    "title": "Plotly Error Bar Hack",
    "section": "",
    "text": "Plotly is a great plotting library that I’ve started to use extensively in part due to the ease in connecting graphs together under R. There is, however, a bug when using error bars in conjunction with a group variable - error bars are not drawn in the correct order. This can be fixed with a hack by adding each group as an individual trace.\n\nlibrary(plotly)\nlibrary(dplyr)\nlibrary(tidyr)\n\n## Raw data\ndf &lt;- data.frame(sample = rep(paste0('sample ', 1:5), 4),\n                 x = rnorm(20),\n                 group = rep(paste0('group ', 1:2), each = 10),\n                 stringsAsFactors = FALSE\n)\n\n## Stats table\ndf2 &lt;- df %&gt;%\n  group_by(sample, group) %&gt;%\n  summarise(avg = mean(x), sd = sd(x)) %&gt;%  ungroup()\n\ndf2\n\n# A tibble: 10 × 4\n   sample   group      avg    sd\n   &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 sample 1 group 1  1.38  0.733\n 2 sample 1 group 2  1.23  0.344\n 3 sample 2 group 1 -1.04  0.649\n 4 sample 2 group 2  0.162 0.387\n 5 sample 3 group 1 -0.142 2.08 \n 6 sample 3 group 2  0.272 0.284\n 7 sample 4 group 1  0.769 1.54 \n 8 sample 4 group 2 -0.238 0.100\n 9 sample 5 group 1  0.715 0.568\n10 sample 5 group 2  0.340 0.378\n\n\n\n## Plotly barchart with error bars.  Error bars are incorrectly assigned\np1 &lt;- plot_ly(df2, x = ~sample, y = ~avg, color = ~group, type = 'bar', error_y = list(array = ~df2$sd))\np1\n\n\n\n\n\n\n## Create individual columns for group data and errors\ndf3 &lt;- df2 %&gt;%\n  gather(key, value, -c(sample, group)) %&gt;%\n  mutate(ref = paste0(group, ifelse(key == 'sd', '_sd', ''))) %&gt;%\n  select(-group, -key) %&gt;%\n  spread(ref, value)\n\ndf3\n\n# A tibble: 5 × 5\n  sample   `group 1` `group 1_sd` `group 2` `group 2_sd`\n  &lt;chr&gt;        &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1 sample 1     1.38         0.733     1.23         0.344\n2 sample 2    -1.04         0.649     0.162        0.387\n3 sample 3    -0.142        2.08      0.272        0.284\n4 sample 4     0.769        1.54     -0.238        0.100\n5 sample 5     0.715        0.568     0.340        0.378\n\n\n\n## Plotly barchart displays error bars correctly\np2 &lt;- plot_ly(df3, type = 'bar')\nfor (g in unique(df2$group)) {\n  p2 &lt;- add_trace(p2, x = df3[['sample']], y = df3[[g]], name = g, color = g, error_y = list(array = df3[[paste0(g, '_sd')]]))\n}\np2"
  },
  {
    "objectID": "posts/2017/2017-05-24-multidplyr/index.html",
    "href": "posts/2017/2017-05-24-multidplyr/index.html",
    "title": "parallel dplyr",
    "section": "",
    "text": "I’m a big fan of the R packages in the tidyverse and dplyr in particular for performing routine data analysis. I’m currently working on a project that requires fitting dose-repsonse curves to data. All works well when the amount of data is small but as the dataset grows so does the computational time. Fortunately there’s a library (multidplyr) to perform dplyr operations under parallel conditions. By way of example we’ll create a set of dummy data and compare curve fitting using dplyr and multidplyr.\nThe dataset used is the spinach dataset that comes with the drc package. It’s a data frame containing 105 observations in 5 groups. Each group consists of 7 concentrations run in triplicate. To compare dplyr and multidplyr we’ll take these measurements and copy them 1000 times with some jitter."
  },
  {
    "objectID": "posts/2017/2017-05-24-multidplyr/index.html#introduction",
    "href": "posts/2017/2017-05-24-multidplyr/index.html#introduction",
    "title": "parallel dplyr",
    "section": "",
    "text": "I’m a big fan of the R packages in the tidyverse and dplyr in particular for performing routine data analysis. I’m currently working on a project that requires fitting dose-repsonse curves to data. All works well when the amount of data is small but as the dataset grows so does the computational time. Fortunately there’s a library (multidplyr) to perform dplyr operations under parallel conditions. By way of example we’ll create a set of dummy data and compare curve fitting using dplyr and multidplyr.\nThe dataset used is the spinach dataset that comes with the drc package. It’s a data frame containing 105 observations in 5 groups. Each group consists of 7 concentrations run in triplicate. To compare dplyr and multidplyr we’ll take these measurements and copy them 1000 times with some jitter."
  },
  {
    "objectID": "posts/2017/2017-05-24-multidplyr/index.html#code",
    "href": "posts/2017/2017-05-24-multidplyr/index.html#code",
    "title": "parallel dplyr",
    "section": "Code",
    "text": "Code\n\n## Libraries\nlibrary(drc)\nlibrary(dplyr)\nlibrary(multidplyr)\nlibrary(microbenchmark)\nlibrary(ggplot2)\nlibrary(tidyr)\n\n## Create a dummy dataset\ndata &lt;- spinach\nfor (i in 1:1000) {\n  addData &lt;- spinach\n  addData$CURVE &lt;- addData$CURVE + 5 * i\n  addData$SLOPE &lt;- sapply(addData$SLOPE, function(x) jitter(x, factor = 10))\n  data &lt;- rbind(data, addData)\n}\n\n## Define some functions\nmakeFit &lt;- function(d) {\n  tryCatch(drm(SLOPE ~ DOSE, data = d, fct = LL.4()), error = function(e) NA)\n}\n\nfit_dplyr &lt;- function(data, n) {\n  data %&gt;%\n    filter(CURVE &lt;= n) %&gt;%\n    group_by(CURVE) %&gt;%\n    do(fit = makeFit(.))\n}\n\nfit_multidplyr &lt;- function(data, n) {\n  data %&gt;%\n    filter(CURVE &lt;= n) %&gt;%\n    partition(CURVE) %&gt;%\n    cluster_copy(makeFit) %&gt;%\n    cluster_library('drc') %&gt;%\n    do(fit = makeFit(.)) %&gt;%\n    collect(unique_indexes = 'CURVE')\n}\n\n## Benchmark our data\nmicrobenchmark(fit_dplyr(data, 10), times = 3)\nmicrobenchmark(fit_dplyr(data, 100), times = 3)\nmicrobenchmark(fit_dplyr(data, 1000), times = 3)\nmicrobenchmark(fit_dplyr(data, 5000), times = 3)\nmicrobenchmark(fit_multidplyr(data, 10), times = 3)\nmicrobenchmark(fit_multidplyr(data, 100), times = 3)\nmicrobenchmark(fit_multidplyr(data, 1000), times = 3)\nmicrobenchmark(fit_multidplyr(data, 5000), times = 3)\n\n## Conclude with a table and graph\ndf.graph &lt;- data.frame(n = rep(c(10, 100, 1000, 5000), 2), library=rep(c('dplyr', 'multidplyr'), each=4), timing=c(0.20, 3.04, 39.07, 212.89, 0.13, 1.13, 10.13, 49.29))\n\nggplot(df.graph, aes(x=n, y=timing, colour=library)) +\n  geom_point(size = 2) +\n  geom_line() +\n  labs(x = 'number of groups', y = 'timing (seconds)')\n\ndf.table &lt;- df.graph %&gt;%\n  spread(library, timing) %&gt;%\n  mutate(enhancement = round(dplyr / multidplyr, 2))"
  },
  {
    "objectID": "posts/2017/2017-05-24-multidplyr/index.html#conclusion",
    "href": "posts/2017/2017-05-24-multidplyr/index.html#conclusion",
    "title": "parallel dplyr",
    "section": "Conclusion",
    "text": "Conclusion\nIn this case, multidplyr runs up to 4.3 times faster on a 16 core PC. The speed enchancement increases with increasing size of the dataset.\n\n\n\nn\ndplyr (secs)\nmultidplyr (secs)\n\n\n\n\n10\n0.20\n0.13\n\n\n100\n3.04\n1.13\n\n\n1000\n39.07\n10.13\n\n\n5000\n212.89\n49.29"
  },
  {
    "objectID": "posts/2017/2017-04-06_querybuilder/index.html",
    "href": "posts/2017/2017-04-06_querybuilder/index.html",
    "title": "queryBuilder",
    "section": "",
    "text": "queryBuilder is an htmlwidget wrapper for jQuery queryBuilder, a fantastic jQuery plugin to create queries and filters. The htmlwidget generates a dplyr string that can be used to filter a data frame within a shiny app. In addition I’m playing with some experimental features to expand functionality. The first is a way to filter on up/down trend, something that I’ve used in metabolomics studies. The second is a group comparison feature, something that’s achieved by switching out the html on the fly - toggling between a textbox and a combobox. An example of the group comparison filter can be found on codepen and the htmlwidget is hosted on github."
  },
  {
    "objectID": "posts/2017/2017-02-21-in_the_cloud/index.html",
    "href": "posts/2017/2017-02-21-in_the_cloud/index.html",
    "title": "In The Cloud",
    "section": "",
    "text": "About 2 years ago my beloved Asus G60VX died. I loved that laptop. We’d been through a lot together and enjoyed five wonderful years. After a brief mourn I had a long think about the future and decided to move to a Chromebook. Precisely an Acer C270. I’ve moved from 15”x10” (16” screen), 7.3lbs to 11”x8” (11.6” screen), 2.8lbs. The Asus would run for an hour on its 6-cell battery whereas the Chromebook can hold a charge for 8 hours. For storage I mostly use Google drive and for programming I use Codeanywhere and Digital Ocean droplets (along with firessh, caret and pixlr). Total cost is minimal. Everything I run or test is hosted remotely and internet is freely available almost everywhere - the few times I’ve been unable to connect, my cellphone has proved to be an adequate hotspot.\nIf anything ever happens to my chromebook I could transition to another machine and continue where I left off as if nothing happened. I’m totally cloud-based and loving it!"
  },
  {
    "objectID": "posts/2017/2017-02-06-split_apply_combine/index.html",
    "href": "posts/2017/2017-02-06-split_apply_combine/index.html",
    "title": "Split-Apply-Combine",
    "section": "",
    "text": "A common task when working with data is split-apply-combine – splitting a dataset up, applying a function and then recombining the results. It’s often performed in creating summary tables around a factor.\nFirst let’s define the data to be used. I’m interested in a scenario where I have nS samples at nC concentrations repeated nR times. For each of these I’d like nF pieces of data (features). The table to construct will have nS.nC.nR rows and nF columns of data.\n\nlibrary(data.table)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(naturalsort)\n\n### Generate table\n\nnF &lt;- 50  # number of features\nnS &lt;- 20  # number of samples\nnR &lt;- 5  # number of replicates\nconc &lt;- c(0, 5, 10, 20)  # concentration per sample\nnormalizeConc &lt;- conc[1]  # concentration for normalization\n\ndt &lt;- data.table(\n  Sample = rep(paste0('Sample_', seq(nS)), each = nR * length(conc)),\n  Concentration = rep(rep(conc, each = nR), times = nS)\n)\nfor (i in seq(nF)) dt[, paste0('F', i) := runif(n = nS * nR * length(conc), min = 0, max = 100)]\ndf &lt;- as.data.frame(dt)\n\nThe top of the table is shown below.\n\nTable dimensions = 400 x 52.\nThe data is stored as both a data frame (df) and a data table (dt) for comparison later.\nFor my application, I’d like to take a table, split or group it by Sample and Concentration, calculate the mean of the replicates for each sample-concentration pair and then divide all data by the corresponding sample at concentration = 0. This can readily be accomplished under base R by using the split.data.frame function which takes a data frame and splits it into a list of data frames defined by a vector. The method below splits the data frame by Sample and then again by Concentration, performing the ratio calculation for each Concentration under each Sample. It then recombines all the data frames using rbind.\n\n## Using base R\nbase_method &lt;- function(df, normalizeConc) {\n  split.data &lt;- split.data.frame(df, df$Sample)  ## split by sample\n  features &lt;- names(df)[grep('F[0-9]+', names(df))]  ## grab column names corresponding to features\n  l.split &lt;- lapply(split.data, function(x) {  ## loop over samples\n    v.means &lt;- colMeans(x[x$Concentration == normalizeConc, features])  ## calculate average of normalizing concentration\n    split.data2 &lt;- split.data.frame(x, x$Concentration)  ## split by concentration\n    l.splitConc &lt;- lapply(split.data2, function(y) {  ## loop over concentrations within a sample\n      df.ratio &lt;- colMeans(y[, features]) / v.means  ## calc ratio of average of each concentration to average of normalizing concentration\n    })\n    df.splitConc &lt;- data.frame(Sample = x[['Sample']][1], Concentration = as.numeric(names(l.splitConc)), do.call('rbind', l.splitConc), stringsAsFactors = FALSE)  ## construct a data frame of all concentration ratios for a single sample\n    df.splitConc &lt;- df.splitConc[df.splitConc$Concentration != normalizeConc, ]  ## get rid of the normalizing concentration (ratio = 1)\n  })\n  names(l.split) &lt;- NULL\n  do.call('rbind', l.split)  ## combine all into a single data frame\n}\n\nThe method under base R works but it’s fairly long and not very efficient, using nested lapply loops. A quick look using profvis suggests that the time to run is distributed fairly equally throughout the function so it would be difficult to optimize.\nCleaner code can be written using the data.table package. In this case the table is grouped by Sample and Concentration and the means are calculated in a single step:\n\n## Using data.table\ndt_method &lt;- function(dt, normalizeConc) {\n  features &lt;- names(dt)[grep('F[0-9]+', names(dt))]  ## grab column names corresponding to features\n  dt1 &lt;- dt[, lapply(.SD, mean), by = list(Sample, Concentration), .SDcols = features]  ## calculate means for each sample concentration\n  dt2 &lt;- dt1[, lapply(.SD, function(x) {x / x[Concentration == normalizeConc]} ), by = Sample, .SDcols = features]  ## calculate ratio to the normalizing concentration\n  dt2[, Concentration := dt1[, Concentration]]  ## add the concentration back as a column\n  dt3 &lt;- dt2[Concentration != normalizeConc]  ## get rid of the normalizing concentration (ratio = 1)\n  setcolorder(dt3, c('Sample', 'Concentration', features))  ## reorder columns\n  return(dt3)\n}\n\nThe beauty is in the use of .SD which is a subset of the input data.table.\nOf course, all this can be accomplished in a single line using dplyr and tidyr. I’m a big fan of the tidyverse and the more I use dplyr, the happy I become.\n\n## using dplyr and tidyr\ntidyverse_method &lt;- function(df, normalizeConc) {\n  df %&gt;% \n    gather(feature, value, starts_with('F')) %&gt;%  ## wide -&gt; long\n    group_by(Sample, feature, Concentration) %&gt;%  ## group by Sample, feature and concentration\n    summarise(meanVal = mean(value)) %&gt;%   ## calculate the mean concentration for each sample/feature pair\n    mutate(ratio = meanVal / meanVal[Concentration == normalizeConc]) %&gt;%  ## determine ratio to specific concentration\n    filter (Concentration != normalizeConc) %&gt;%  ## get rid of the rows with ratio = 1\n    select(-meanVal) %&gt;%  ## remove meanVal column\n    spread(feature, ratio) %&gt;%  ## long -&gt; wide\n    arrange(as.numeric(sub('.*_', '', Sample))) %&gt;%  ## rearrange sample ID by number\n    select(Sample, Concentration, one_of(names(df[3:ncol(df)])))  ## original feature order\n}\n\ndata.table wins out on speed but tidyverse is cleaner and more straightforward to modify.\n\nlibrary(microbenchmark)\nmb &lt;- microbenchmark(\n  base_method(df, 0),\n  dt_method(dt, 0),\n  tidyverse_method(df, 0),\n  times = 10\n)\n\nprint(mb)\n\nTiming (milliseconds)\n\n\n\n\n\n\n\n\n\n\n\n\n\nexpr\nmin\nlq\nmean\nmedian\nuq\nmax\nnval\n\n\n\n\nbase_method\n186.05\n206.71\n266.95\n239.96\n330.96\n399.50\n10\n\n\ndt_method\n8.59\n8.90\n17.13\n16.84\n20.22\n36.87\n10\n\n\ntidyverse_method\n72.06\n75.83\n101.01\n82.10\n106.67\n194.53\n10"
  },
  {
    "objectID": "posts/2017/2017-01-14-monitor_player_list/index.html",
    "href": "posts/2017/2017-01-14-monitor_player_list/index.html",
    "title": "Monitoring Fantasy Football Transfers",
    "section": "",
    "text": "There are many fantasy sports out there. Since I’m from England I like playing fantasy football (that’s football, also known as soccer where I am now). Rules are pretty straight forward - pick a team of players from the Premier League and score points depending on how they perform. Most British leagues work on the principle that any team can contain any player and that two teams within a single league can each have the same player. This is contrary to many American fantasy NFL leagues in which the number of managers is limited and player repeats are not allowed. Several years ago, we changed our Premiership League so that each player could only exist in a single team.\nThis means that there is now an advantage to being first to transfer in an on-form player or a potential star once they hit the Premiership. FIFA regulates that leagues should have two transfer windows - one prior to the start of a season and one in the middle. For the Premiership, the in-season transfer window is the month of January. Now, since our league works on the princple that only one team can have any player and that the player has to be posted on the Premierleague site before he can be transferred into a team, there’s a distinct advantage to knowing as soon as a player is available. This can be easily accomplished using the script below.\nThe code works by monitoring the Premierleague site, in particular the web page that lists all the players. It grabs the player list, compares it to the previously grabbed list and, if there have been any changes, sends out a pushbullet notification. Pushbullet’s a great service allowing communication to multiple devices simultaneously. I run this on a Digital Ocean droplet through a cron job. The code is accompanied by a .rpushbullet.json file which contains the pushbullet key and device parameters.\n\n##\n## transferWatch\n##\n## Monitor fantasy premierleague player list for updates during transfer window.\n## Send a pushbullet notification when the player list has changed.\n## Run as a cron job to send updates at regular intervals\n##\n## crontab:\n## 0 * * * * Rscript $HOME/codes/transferWatch/transferWatch.R\n## run every hour\n##\n\nlibrary(rvest)\nlibrary(xml2)\nlibrary(dplyr)\nlibrary(RPushbullet)\nlibrary(methods)\n\ndataFolder &lt;- Sys.getenv('HOME')\nl.devices &lt;- RPushbullet::pbGetDevices()\ndevices &lt;- unlist(lapply(l.devices[['devices']], function(x) x[['nickname']]))\n\n# Scrape site and pull back tables of players\nurl &lt;- 'https://fantasy.premierleague.com/player-list/'\npos &lt;- c('GLK', 'DEF', 'MID', 'FWD')\ntabs &lt;- url %&gt;% xml2::read_html(url) %&gt;% html_nodes('.ism-table') %&gt;% html_table()\n\nfor (i in seq_along(tabs)) {\n  tabs[[i]]$Pos &lt;- pos[(i+1) %/% 2]\n}\nnew.tables &lt;- dplyr::bind_rows(tabs)\n\nfilename &lt;- paste0(dataFolder, '/players.csv')\nif (file.exists(filename)) {\n  # Read in old data\n  old.tables &lt;- read.csv(filename, stringsAsFactors = F, encoding = 'UTF-8')\n  # Compare tables\n  df.new &lt;- dplyr::setdiff(new.tables[, c(1,2,5)], old.tables[, c(1,2,5)])\n  if (nrow(df.new) &gt; 0) {\n    newPlayers &lt;- paste0(apply(df.new, 1, function(x) paste0(x, collapse = ', ')), collapse='\\n')\n    RPushbullet::pbPost('note', 'Transfer News', body = newPlayers, recipients = devices)\n  }\n} \n\n# Write new data to file\nwrite.csv(new.tables, filename, row.names=F)"
  },
  {
    "objectID": "posts/2017/2017-03-30-rstudio_connect_databases/index.html",
    "href": "posts/2017/2017-03-30-rstudio_connect_databases/index.html",
    "title": "RStudio Connect and Databases",
    "section": "",
    "text": "I’m starting to experiment with RStudio Connect. I’ve been working on a shiny app that writes to a database and a flexdashboard that can illustrate the output. When writing this type of approach using Shiny Server, both pieces of code could simply point to the same sqlite database. This becomes a little more challenging under RStudio Connect. One solution is to point both pieces of code to a mysql database which resides outside of the RStudio Connect server. In order to run this way, the libmysqlclient library must be installed on the instance running RStudio Connect. Once deployed, the app can update the database and the flexdashboard can be configured to pool from the database and automatically update at fixed intervals."
  },
  {
    "objectID": "posts/2017/2017-11-28-sortable_tables/index.html",
    "href": "posts/2017/2017-11-28-sortable_tables/index.html",
    "title": "Sortable Tables",
    "section": "",
    "text": "The datatable widget is a powerful table-building tool used to display data in shiny apps. It can use many of the datatable plugins and extensions but a small javascript hack is needed for the rowReorder extension which allows rows to be reordered using drag and drop.\nIn the example below, the rowReorder options are set to selector = ‘tr’ (select by clicking anywhere on a row) and update = FALSE (do not fire an update to rowReorder). The removal of the update is due to the fact that the rows are not reordered properly in a shiny app. We can now use the row-order event which is fired irrespective of the setting of the update option (row-reordered, however, is only fired when update = true). The javascript function called on row-reorder simply grabs the new order of the table rows and exports it to a shiny variable. This can then be used to update the table.\nlibrary(shiny)\nlibrary(DT)\n\n## Sortable table\n\nserver &lt;- function(input, output) {\n  \n  df &lt;- reactiveValues(data = mtcars[c(1:20), c('mpg', 'cyl', 'disp')],\n                       data_reordered = mtcars[c(1:20), c('mpg', 'cyl', 'disp')])\n\n  output$tab1 &lt;- DT::renderDataTable({\n    DT::datatable(df$data, \n                  selection = 'none', \n                  extensions = c('Scroller', 'RowReorder'), \n                  options = list(rowReorder = list(selector = 'tr', update = FALSE), \n                                 columnDefs = list(list(targets = 0, visible = TRUE)),\n                                 deferRender = TRUE,\n                                 scrollY = 400,\n                                 scroller = TRUE,\n                                 dom = 't'),\n                  callback = JS(\"table.on('row-reorder', function(e, diff, edit) { \n                                  var arr = [];\n                                  $(this).parent().find('.dataTable tbody tr').each(function() { arr.push($(this).find('td').eq(0).text()); })\n                                  Shiny.onInputChange('tableReordered', arr);\n                                });\")\n                  )\n  })\n\n  observeEvent(input$tableReordered, {\n    df$data_reordered &lt;- df$data[order(match(row.names(df$data), input$tableReordered)), ]\n    df$order &lt;- input$tableReordered\n  })\n\n  output$df_original &lt;- renderTable(df$data, rownames = TRUE)  \n  output$df_reordered &lt;- renderTable(df$data_reordered, rownames = TRUE) \n}\n\nui &lt;- fluidPage(\n  column(4, \n           h4('Sortable Table'),\n           DT::dataTableOutput('tab1')\n         ),\n  column(4, \n           h4('Original Table'),\n           tableOutput('df_original')\n         ),\n  column(4, \n           h4('Sorted Table'),\n           tableOutput('df_reordered')\n         )\n)\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2017/2017-09-15-fancy_headers_in_automated_reports/index.html",
    "href": "posts/2017/2017-09-15-fancy_headers_in_automated_reports/index.html",
    "title": "Fancy Headers in Automated Reports",
    "section": "",
    "text": "Using RMarkdown with knitr is a great way of automating reports under R and I’ve used this approach extensively in shiny apps. For one particular project we’re storing raw data in a SQL database and processing on the fly under shiny. Results are displayed using heatmaps and graphs. We’re now considering pushing data reports to a filestore that connects to another corporate database via a visualizer. Not wanting to generate extra work, this is a great opportunity to put rmarkdown and knitr to work. I’ve added some code to the upload so that each time data are uploaded to the database some rudimentary calculations are performed and a pdf report is automatically generated. Unlike many of the other reports I’ve put together in the past, this one requires the title to be placed in a header along with a link to the app for further processing.\nAll this can be achieved with a little programming in R and latex as shown below…\n\nHere is a snippet from the app.R code. In this case ASSAY_TITLE refers to the name of the assay. Data have already been processed and are stored in a reactive variable (df.raw), comprising of Sample, Concentration and several columns of processed data.\n\n## Generate reports\nobserveEvent(input$butReport, {\n  req(df.raw())\n  for (sample in unique(df.raw()$Sample)) {  ## Create one report for each sample\n    output_file &lt;- paste(sample, Sys.Date(), 'ASSAY_TITLE', \"FA.pdf\", sep='_')\n    file_with_path &lt;- paste(tempdir(), output_file, sep = '/')\n    rmarkdown::render(input = \"./upload_report.Rmd\",\n            output_format = \"pdf_document\",\n            output_file = output_file,\n            output_dir = tempdir(),\n            params=list(sample=sample,  ## Send parameters to markdown yaml\n                        date=Sys.Date()))\n    df$report[df$report$Sample == sample, 'Uploaded'] &lt;- TRUE\n    ## send report to filestore\n    inq_metadata &lt;- '{\"file_content\": \"Report\", \"description\": \"ASSAY_TITLE Report file\"}'\n    uploadFile(parent_id, file_with_path, metadata = inq_metadata)\n  }\n})\n\nHere’s the entire rmarkdown file. The yaml at the top contains a params line to pass paraneters from the ramarkdown::render command. Two variables are set in yaml - the title and author - these contain data which will be used for two lines in the header. The author is used to store the subtitle data and consists of an r paste0 command concatenating teh sample name and date (passed as variables). A couple of latex packages are included: graphicx to include a graphic and fancyhdr to manage creating a header. The statement that reads \\AtBeginDocument{\\let\\maketitle\\relax} allows us to define the title in yaml but does not automatically print it to the document title page. The latex code defines a header/footer for the plain page style. The footer contains the page number, centered and the header contains the title and author variables, left justified, with the title on top. In addition to the title information in the header, a graphic is included, right justified. The graphic is embedded in an \\href command and links to the app. This allows the user to view the report which contains limited information and click to the app for further detail. Once this is all in place, all that is needed is to issue a \\newpage followed by \\pagestyle{plain} at the start of each page.\n\n---\nparams: \n  sample: \"\"\n  date: \"\"\ntitle: \"FATTY ACID ANALYSIS\"\nauthor: \"`r paste0('Sample: ', params$sample, ' --- Uploaded: ', params$date)`\"\nheader-includes:\n  \\usepackage{graphicx}\n  \\usepackage{fancyhdr}\n  \\AtBeginDocument{\\let\\maketitle\\relax}\noutput: pdf_document\n---\n\n\\makeatletter\n\\fancypagestyle{plain}{\n  \\fancyhf{}\n  \\fancyfoot[C]{\\thepage}\n  \\fancyhead[L]{\\Large \\textbf{\\@title} \\\\ \\large \\@author}\n  \\fancyhead[R]{\\href{http://link_to_shiny_app/}{\\includegraphics{link_button.png}}}\n}\n\n\\pagestyle{plain}\n\\vspace*{1\\baselineskip}\n\n## Raw data - averaged over each concentration\n```{r, results='asis'}\n\ndf.tab1 &lt;- df.raw() %&gt;%\n  filter(Sample == sample) %&gt;%\n  select(-Sample) %&gt;%\n  gather(FA, Value, -Conc) %&gt;%\n  group_by(FA, Conc) %&gt;%\n  summarise(av_Conc = round(mean(Value), 3)) %&gt;%\n  spread(Conc, av_Conc)\nnames(df.tab1)[-1] &lt;- paste(names(df.tab1)[-1], 'µM')\nkable(df.tab1)\n\n```\n\\newpage\n\\pagestyle{plain}\n\n## Normalized data - averaged over each concentration\n```{r results='asis'}\n\nfeatures &lt;- names(df.raw())[-c(1:2)]\ndf.tab2 &lt;- df.raw() %&gt;%\n  filter(Sample == sample) %&gt;%\n  select(-Sample) %&gt;%\n  mutate(total = rowSums(.[-1], na.rm = TRUE)) %&gt;%\n  mutate_at(features, funs(100*./total)) %&gt;%\n  select(-total) %&gt;%\n  gather(FA, Value, -Conc) %&gt;%\n  group_by(FA, Conc) %&gt;%\n  summarise(av_Conc = round(mean(Value), 3)) %&gt;%\n  spread(Conc, av_Conc)\nnames(df.tab2)[-1] &lt;- paste(names(df.tab2)[-1], 'µM')\nkable(df.tab2)\n\n```"
  },
  {
    "objectID": "posts/2023/2023-02-16-shiny_framework_01/index.html",
    "href": "posts/2023/2023-02-16-shiny_framework_01/index.html",
    "title": "Shiny Frameworks 01 - Introduction",
    "section": "",
    "text": "This is the first in a series of blog posts tagged Shiny Framekworks The goal is to provide a some loosely connected articles related to building shiny frameworks with the ultimate goal of turning them into an eBook. Inspiration comes from a presentation I gave at R/Pharma 2022 (https://youtu.be/bkKe_kC83iQ).\n\n\nImagine you’ve built a killer shiny app and you need to change the data. Most apps are adaptable to a degree. If you want to upload a different set of data, the app should be able to accommodate if the data are in an expected format.\nBut what if:\n\nyour data are in a completely different format?\nyou want to manipulate your data in some way (filter or add a new variable)?\nyou want to use a completely different visualization?\n\nIt’s unlikely that the app can cope with these situations unless choices were made at the design stage.\nA shiny framework is an approach to building shiny apps which allows for:\n\nflexibility: being able to offer choices after the app has been built.\nextensibility: ability to readily extend the framework for unmet needs.\nscalability: easily scale beyond the current needs of the app.\n\nThe basic premise is to build the app using instructions. These instructions are parsed through an interpreter, or an engine, which converts the instructions into R code. An interpreter can do many things, such as:\n\nreading and understanding files of different formats\ndata wrangling and manipulation\nbuilding static or dynamic outputs\nbuiding and/or responding to shiny reactives\n\nTaken to the extreme, a shiny framework can be used to build any part of an app. It’s a powerful resource to simplify the build for a series of similar apps. In effect you could build a framework that builds other frameworks or an app that builds other apps.\n\n\n\nWhen working with a framework its a good programming practice to take on a three layer approach:\n\nData Layer. This is where the data reside along with any functions that interact with the data.\nApplication Layer. This is where the data are processed and any analyses are performed.\nPresentation Layer. This is where the output is generated and presented to the user.\n\nIt’s important to note that layers can only interact with adjacent layers, meaning that information may pass from the data layer to the application layer and from the application layer to the presentation layer but NOT from the data layer directly to the presentation layer - it must pass through the application layer first.\nWhy is this an effective way of working? Well, firstly it forces you to separate out the tasks. From an R-perspective it’s easier to maintain once you realize that data interaction, processing and presentation can each exist in their own separate packages. Secondly it allows for simpler scalability - data retrieval and processing can be accomplished using an API running on a different architecture, releasing burden from a shiny app. Taking this a step further, each of these layers may be a different language (python API to access data, R to process and javascript to display)."
  },
  {
    "objectID": "posts/2023/2023-02-16-shiny_framework_01/index.html#shiny-frameworks",
    "href": "posts/2023/2023-02-16-shiny_framework_01/index.html#shiny-frameworks",
    "title": "Shiny Frameworks 01 - Introduction",
    "section": "",
    "text": "This is the first in a series of blog posts tagged Shiny Framekworks The goal is to provide a some loosely connected articles related to building shiny frameworks with the ultimate goal of turning them into an eBook. Inspiration comes from a presentation I gave at R/Pharma 2022 (https://youtu.be/bkKe_kC83iQ).\n\n\nImagine you’ve built a killer shiny app and you need to change the data. Most apps are adaptable to a degree. If you want to upload a different set of data, the app should be able to accommodate if the data are in an expected format.\nBut what if:\n\nyour data are in a completely different format?\nyou want to manipulate your data in some way (filter or add a new variable)?\nyou want to use a completely different visualization?\n\nIt’s unlikely that the app can cope with these situations unless choices were made at the design stage.\nA shiny framework is an approach to building shiny apps which allows for:\n\nflexibility: being able to offer choices after the app has been built.\nextensibility: ability to readily extend the framework for unmet needs.\nscalability: easily scale beyond the current needs of the app.\n\nThe basic premise is to build the app using instructions. These instructions are parsed through an interpreter, or an engine, which converts the instructions into R code. An interpreter can do many things, such as:\n\nreading and understanding files of different formats\ndata wrangling and manipulation\nbuilding static or dynamic outputs\nbuiding and/or responding to shiny reactives\n\nTaken to the extreme, a shiny framework can be used to build any part of an app. It’s a powerful resource to simplify the build for a series of similar apps. In effect you could build a framework that builds other frameworks or an app that builds other apps.\n\n\n\nWhen working with a framework its a good programming practice to take on a three layer approach:\n\nData Layer. This is where the data reside along with any functions that interact with the data.\nApplication Layer. This is where the data are processed and any analyses are performed.\nPresentation Layer. This is where the output is generated and presented to the user.\n\nIt’s important to note that layers can only interact with adjacent layers, meaning that information may pass from the data layer to the application layer and from the application layer to the presentation layer but NOT from the data layer directly to the presentation layer - it must pass through the application layer first.\nWhy is this an effective way of working? Well, firstly it forces you to separate out the tasks. From an R-perspective it’s easier to maintain once you realize that data interaction, processing and presentation can each exist in their own separate packages. Secondly it allows for simpler scalability - data retrieval and processing can be accomplished using an API running on a different architecture, releasing burden from a shiny app. Taking this a step further, each of these layers may be a different language (python API to access data, R to process and javascript to display)."
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover some concepts of importing data."
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html#introduction",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html#introduction",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover some concepts of importing data."
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html#import-data-once-or-many",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html#import-data-once-or-many",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "Import data once or many?",
    "text": "Import data once or many?\nData may be imported when an app starts up or imported as needed. Depending on the type and size of data, data import may be a slow step and it is prudent to consider the type and size of data required by a shiny framework at the design stage. Let’s consider the two options of importing all data at the start or only importing when data are required.\n\nImport data once at the start\nIt makes sense to import data just once, when the app starts up, if the framework relies on only a few data sources. This occurs when the framework defines a single instruction set or if we have a collection of instructions but these instructions only access a limited number of datasets.\n\n\nImport data as needed\nImporting data as needed makes sense when you have a collection of instructions that access a large number of datasets - for example if each instruction set accesses a different dataset. This is particularly true if instruction sets are selected by a user. For example, consider an app with 200 instructions and outputs where the user may choose which one to process and display. In such a case we should not import all 200 datasets upfront as only one is required by the app. The dataset should be imported once the user has selected the instruction set."
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html#data-import-packages",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html#data-import-packages",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "Data import packages",
    "text": "Data import packages\nData may come in many formats. For now, let’s consider CSV since it is a popular format to store rectangular data. The base R CSV reader function read.csv() is relatively slow. There are faster CSV file readers that may be used in its place such as read_csv() from {readr} and fread from {data.table}.\nTo test speed we’ll create two CSV files. f1.csv contains 10000 rows of 10 columns of data (first three columns are character and rest are numeric). f2.csv contains 10 rows of 10000 columns of data (first three columns are character and rest are numeric). f1.csv simulates long data whereas f2.csv simulates wide.\n\n## create two CSV files\n## f1.CSV - 10000 rows, 10 cols, long format\n## f2.CSV - 10 rows, 10000 cols, wide format\nd &lt;- list(c(10000, 10), c(10, 10000))\nfor (i in seq_along(d)) {\n  f &lt;- sprintf(\"f_%02i.csv\", i)\n  data &lt;- matrix(runif(d[[i]][1] * d[[i]][2]), ncol = d[[i]][2]) |&gt;\n    data.frame() |&gt;\n    dplyr::mutate(dplyr::across(c(\"X1\", \"X2\", \"X3\"), as.character))\n  write.csv(data, f, row.names = FALSE)\n}\n\nWe can test the speed of base::read.csv, readr::read_csv and data.table::fread using {microbenchmark} and visualize the output with ggplot::autoplot as follows\n\nout &lt;- lapply(seq_along(d), function(i) {\n  f &lt;- sprintf(\"f_%02i.csv\", i)\n  microbenchmark::microbenchmark(\n    `read.csv` = read.csv(f),\n    read_csv = readr::read_csv(f, show_col_types = FALSE),\n    fread = data.table::fread(f), times = 10\n  )\n})\n\nggplot2::autoplot(out[[1]])\nggplot2::autoplot(out[[2]])\n\n\nBenchmark reading long-format CSV\n\n\n\nBenchmark reading wide-format CSV\n\n\n\n\n\n\n\nNote\n\n\n\nLong format relative timing: fread: 1, read_csv: 5.3, read.csv: 13.2\nWide format relative timing: fread: 1, read_csv: 197, read.csv: 626\n\ndata.table::fread is the most efficient at reading both long and wide formatted CSV data.\nreading wide-formatted files is much slower than long-formatted files"
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html#importing-what-is-required",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html#importing-what-is-required",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "Importing what is required",
    "text": "Importing what is required\nBoth readr::read_csv and data.table::fread include a parameter to limit the columns imported. If you know that not all columns are required, limiting the imported columns can speed up the time. In the example below we read in just 6 columns.\n\nout_select &lt;- lapply(seq_along(d), function(i) {\n  f &lt;- sprintf(\"f_%02i.csv\", i)\n  chosen_cols &lt;- c(\"X1\", paste0(\"X\", sample(x = seq(d[[i]][2])[-1], size = 5)))\n  microbenchmark::microbenchmark(\n    `read.csv` = read.csv(f),\n    read_csv = readr::read_csv(f, show_col_types = FALSE, col_select = all_of(chosen_cols)),\n    fread = data.table::fread(f, select = chosen_cols), times = 10\n  )\n})\n\nggplot2::autoplot(out_select[[1]])\nggplot2::autoplot(out_select[[2]])\n\n\nBenchmark reading long-format CSV (selected columns)\n\n\n\nBenchmark reading wide-format CSV (selected columns)\n\n\n\n\n\n\n\nNote\n\n\n\nLong format relative timing: fread: 1, read_csv: 4.8, read.csv: 13.6\nWide format relative timing: fread: 1, read_csv: 3.1, read.csv: 653\n\ndata.table::fread is the most efficient at reading both long and wide formatted CSV data.\nThere is little advantage when selecting columns for data.table::fread but when selected with readr::read_csv there is a significant increase in speed (1.2x for long data and 65x for wide data)"
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html#importing-data",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html#importing-data",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "Importing data",
    "text": "Importing data\nWorking with data import instructions is relatively simple. Consider the instructional json file (instructions.json):\n{\n  \"instruction\": \"import\",\n  \"file_name\": \"my_file.csv\"\n}\nThe interpreter can be a few lines of code as simple as:\n\n## import json to R list\ninstr &lt;- jsonlite::fromJSON(\"instructions.json\", simplifyVector = FALSE)\n\n## parse json\nif (instr$instruction == \"import\") {\n    my_file &lt;- instr$file_name\n    out &lt;- readr::read_csv(my_file, col_types = readr::cols())\n}\n\nThis is perhaps the simplest example. The interpreter can, however, be more complex depending on needs. The example below includes an optional file path, identifies the file type (either CSV or SAS) by its extension and allows the import to be limited to a subset of columns.\n\n## import json to R list\ninstr &lt;- jsonlite::fromJSON(\"instructions.json\", simplifyVector = FALSE)\n\n## parse json\nif (instr$instruction == \"import\") {\n  if (!is.null(instr$file_path)) {\n    my_file &lt;- file.path(instr$file_path, instr$file_name)\n  } else {\n    my_file &lt;- instr$file_name\n  }\n  only_cols &lt;- unlist(instr$cols)\n\n  if(tools::file_ext(my_file) == \"csv\") {\n    out &lt;- readr::read_csv(my_file, col_types = readr::cols(), col_select = only_cols)\n  } else if (tools::file_ext(my_file) == \"sas7bdat\") {\n    out &lt;- haven::read_sas(my_file, col_select = only_cols)\n  } else {\n    out &lt;- data.frame()\n  }\n}\n\nA list of columns is passed as a json list:\n{\n  \"instruction\": \"import\",\n  \"file_name\": \"my_file.csv\",\n  \"cols\": [\"mpg\", \"wt\"]\n}\nand is converted to a vector (unlist) in the code. If cols does not exist in the json file then instr$cols evaluates to NULL, as does unlist(instr$cols) and the parameter col_select = NULL is carried through to readr::read_csv or haven::read_sas."
  },
  {
    "objectID": "posts/2023/2023-03-10-shiny_framework_03/index.html",
    "href": "posts/2023/2023-03-10-shiny_framework_03/index.html",
    "title": "Shiny Frameworks 03 - A Simple Interpreter",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover the concept of interpreters with a simple example."
  },
  {
    "objectID": "posts/2023/2023-03-10-shiny_framework_03/index.html#introduction",
    "href": "posts/2023/2023-03-10-shiny_framework_03/index.html#introduction",
    "title": "Shiny Frameworks 03 - A Simple Interpreter",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover the concept of interpreters with a simple example."
  },
  {
    "objectID": "posts/2023/2023-03-10-shiny_framework_03/index.html#shiny-framework-interpreters",
    "href": "posts/2023/2023-03-10-shiny_framework_03/index.html#shiny-framework-interpreters",
    "title": "Shiny Frameworks 03 - A Simple Interpreter",
    "section": "Shiny Framework Interpreters",
    "text": "Shiny Framework Interpreters\nWhere instructions are the soul of a shiny framework, interpreters are the heart. An interpreter takes input instructions, parses them and generates an output. An ideal interpreter should be data agnostic, meaning that it can take multiple, different types of data and work with them accordingly. The instructions tell the interpreter what to do and how to handle the data.\nIn one simple example below we’ll read in an instruction file and parse its contents to build a plot.\nThe instructional file (instructions.json) looks like this:\n{\n  \"build\": \"plot\",\n  \"data\": \"mtcars\",\n  \"type\": \"scatter\",\n  \"x\": \"mpg\",\n  \"y\": \"wt\"\n}\nThe interpreter is a parser that can read this input and act upon it.\n\n## import json to R list\ninstr &lt;- jsonlite::fromJSON(\"instructions.json\", simplifyVector = FALSE)\n\n## parse contents and build plot\nif (isTRUE(instr$build == \"plot\")) {\n  data &lt;- get(instr$data)\n  if (isTRUE(instr$type == \"scatter\")) {\n    plot(data[[instr$x]],\n         data[[instr$y]],\n         xlab = instr$x,\n         ylab = instr$y,\n         type = \"p\")\n  }\n}\n\nUpon running we get a plot that has been built using the parameters from the json file.\n\nUnpacking the code above we first import the json file using the jsonlite library. The file will be interpreted as a list by R:\n\ninstr\n\n$build\n[1] \"plot\"\n\n$data\n[1] \"mtcars\"\n\n$type\n[1] \"scatter\"\n\n$x\n[1] \"mpg\"\n\n$y\n[1] \"wt\"\n\n\n&gt; instr\n$build\n[1] \"plot\"\n\n$data\n[1] \"mtcars\"\n\n$type\n[1] \"scatter\"\n\n$x\n[1] \"mpg\"\n\n$y\n[1] \"wt\"\nThe parser works by first identifying if instr$build is plot and then generating the plot. We use isTRUE to check the value of instr$build as it returns false if there is no match or if the list instr does not have an element named build. The parser then assigns the data to a variable using the get function and builds a scatterplot, assigning parameters as applicable.\nThis simple example does not include error checking for missing parameters. The parser would fail if, for example, x or y were missing or referenced a column in the data that does not exist. This can be easily mitigated by validating inputs or using tryCatch to handle errors.\nFrom this simple example it’s easy to see how our parser can be extended:\n\n## import json to R list\ninstr &lt;- jsonlite::fromJSON(\"instructions.json\", simplifyVector = FALSE)\n\n## parse contents and build plot\nif (isTRUE(instr$build == \"plot\")) {\n  data &lt;- get(instr$data)\n  if (isTRUE(instr$type == \"scatter\")) {\n    plot(data[[instr$x]],\n         data[[instr$y]],\n         xlab = instr$x,\n         ylab = instr$y,\n         type = \"p\")\n  } else if (isTRUE(instr$type == \"line\")) {\n    plot(data[[instr$x]],\n         data[[instr$y]],\n         xlab = instr$x,\n         ylab = instr$y,\n         type = \"l\")\n  }\n}\n\nand simplified:\n\n## import json to R list\ninstr &lt;- jsonlite::fromJSON(\"instructions.json\", simplifyVector = FALSE)\n\n## list of plot types\nplot_type &lt;- list(scatter = \"p\", line = \"l\", both = \"b\")\n\n## parse contents and build plot\nif (isTRUE(instr$build == \"plot\")) {\n  data &lt;- get(instr$data)\n  plot(data[[instr$x]],\n        data[[instr$y]],\n        xlab = instr$x,\n        ylab = instr$y,\n        type = plot_type[[instr$type]])\n}\n\nThis post introduced the concept of an interpreter, or parser, with a simple example."
  },
  {
    "objectID": "posts/2023/2023-10-25-serverless_shiny/index.html",
    "href": "posts/2023/2023-10-25-serverless_shiny/index.html",
    "title": "Serverless shiny app embedded in a Quarto Website",
    "section": "",
    "text": "Inspired by Max Kuhn’s presentation at R/Pharma today I tried out embedding shiny a app within a Quarto website and hosting it on GitHub pages. The app itself is a chemistry quiz built to help my son who had a school test coming up. By running it within a Quarto website it’s available for him to use on the bus on the way to school for some quick revision.\n\n\n\n\n\n\nNote\n\n\n\nThanks so the app he scored 27/30!\n\n\n\n\nTo use shinylive in a Quarto document, you need to first install the shinylive Quarto extension:\nquarto add quarto-ext/shinylive\nalong with the shinylive R package\n\nremotes::install_github(\"posit-dev/r-shinylive\")\n\n\n\n\nThe _quarto.yml file is a project with some basic parameters to define the website. The only additional parameter of note is to include shinylive as a filter.\nproject:\n  type: website\n  output-dir: docs\n  \nformat: \n  html\n  \nwebsite:\n  title: \"shinylive elements quiz\"\n  navbar:\n    left:\n      - index.qmd\n\nfilters:\n  - shinylive\n\n\n\nThe shiny app is in a single chunk of the index.qmd file with a code chunk type of shinylive-r and the standalone option set.\n\n---\ntitle: \"Chem symbol test\"\n---\n\nThis is a simple chemical symbol test.  You'll be tested on chemical elements and their names.\n\n```{r}\n#| include: false\nlibrary(shinylive)\n```\n\n```{shinylive-r}\n#| viewerHeight: 300\n#| standalone: true\n\nchem &lt;- data.frame(\n  symbol = c(\"Al\", \"Sb\", \"Ar\", \"As\", \"Ba\", \"Be\", \"Bi\", \n             \"B\", \"Br\", \"Cd\", \"Ca\", \"C\", \"Cs\", \"Cl\", \"Cr\",\n             \"Co\", \"Cu\", \"F\", \"Au\", \"He\", \"H\", \"I\", \"Fe\",\n             \"Kr\", \"Pb\", \"Li\", \"Mg\", \"Mn\", \"Hg\", \"Ne\", \"Ni\",\n             \"N\", \"O\", \"P\", \"Pt\", \"K\", \"Rn\", \"Se\", \"Si\", \"Ag\",\n             \"Na\", \"Sr\", \"S\", \"Te\", \"Sn\", \"Ti\", \"W\",\n             \"U\", \"V\", \"Xe\", \"Zn\", \"Zr\"),\n  name = c(\"aluminum\", \"antimony\", \"argon\", \"arsenic\", \"barium\", \"beryllium\", \"bismuth\", \n           \"boron\", \"bromine\",\"cadmium\", \"calcium\", \"carbon\", \"cesium\", \"chlorine\", \"chromium\",\n           \"cobalt\", \"copper\", \"fluorine\", \"gold\", \"helium\", \"hydrogen\", \"iodine\", \"iron\",\n           \"krypton\", \"lead\", \"lithium\", \"magnesium\", \"mangenese\", \"mercury\", \"neon\", \"nickel\",\n           \"nitrogen\", \"oxygen\", \"phosphorus\", \"platinum\", \"potassium\", \"radon\", \"selenium\", \"silicon\", \"silver\",\n           \"sodium\", \"strontium\", \"sulfur\", \"tellurium\", \"tin\", \"titanium\", \"tungsten\",\n           \"uranium\", \"vanadium\", \"xenon\", \"zinc\", \"zirconium\")\n)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(5, offset = 1, checkboxGroupInput(\"chk_options\", \"Test me on\", choices = names(chem), selected = \"symbol\", inline = TRUE))\n  ),\n  fluidRow(\n    column(5, offset = 1, uiOutput(\"ui_question\")),\n    column(5, \n           fluidRow(uiOutput(\"ui_score\")),\n           fluidRow(uiOutput(\"ui_streak\"))\n           )\n  )\n  \n)\n\nserver &lt;- function(input, output, session) {\n\n  last_num &lt;- 0\n  rv &lt;- reactiveValues(\n    question_count = 0,\n    score = 0,\n    question_type = NULL,\n    question = NULL,\n    answer = NULL,\n    streak = 0\n  )\n  \n  question_index &lt;- reactive({\n    rv$question_count\n    num &lt;- last_num\n    while (num == last_num) {\n      num &lt;- sample(nrow(chem), size = 1)\n    }\n    last_num &lt;- num\n  })\n  \n  output$ui_question &lt;- renderUI({\n    if (length(input$chk_options) &gt; 0) {\n      rv$question_type &lt;- sample(input$chk_options, size = 1)\n      answer_type &lt;- names(chem)[!names(chem) == rv$question_type]\n      rv$question &lt;- chem[[rv$question_type]][question_index()]\n      rv$answer &lt;- chem[[answer_type]][question_index()]\n      tagList(\n        h3(paste(answer_type, \"for:\", rv$question)),\n        textInput(\"txt_answer\", label = NULL),\n        actionButton(\"but_answer\", \"Submit\")\n      )\n    }\n  })\n  \n  observeEvent(input$but_answer, {\n    if (rv$question_type == \"symbol\") {\n      answer &lt;- tolower(input$txt_answer)\n    } else {\n      answer &lt;- input$txt_answer\n    }\n    if (answer == rv$answer) {\n      rv$score &lt;- rv$score + 1\n      rv$streak &lt;- rv$streak + 1\n      showNotification(ui = \"CORRECT!\", type = \"message\")\n    } else {\n      rv$streak &lt;- 0\n      showNotification(ui = paste0(\"WRONG.  Correct answer is \", rv$answer), type = \"error\")\n    }\n    rv$question_count &lt;- rv$question_count + 1\n  })\n  \n  output$ui_score &lt;- renderUI({\n    h3(paste0(\"Score: \", rv$score, \"/\", rv$question_count), style = \"color: #388E3C\")\n  })\n  \n  output$ui_streak &lt;- renderUI({\n    if (rv$streak &gt; 29) {\n      col &lt;- \"#2E7D32\"\n    } else if (rv$streak &gt; 19) {\n      col &lt;- \"#00838F\"\n    } else if (rv$streak &gt; 9) {\n      col &lt;- \"#1E88E5\"\n    } else if (rv$streak &gt; 0) {\n      col &lt;- \"#8E24AA\"\n    } else {\n      col &lt;- \"#E53935\"\n    }\n    h3(paste0(\"Streak: \", rv$streak), style = paste0(\"color: \", col))\n  })\n\n}\n\napp &lt;- shinyApp(ui = ui, server = server)\n\n```\n\nThe app itself contains the typical ui and server along with the shinyapp() function to execute. It is basic and unoptimized (but it demonstrates the purpose). It takes very little effort to change a standalone app to an embedded one.\nThe quarto website with embedded app is available at https://harveyl888.github.io/shinylive-test/."
  },
  {
    "objectID": "posts/2023/2023-10-25-serverless_shiny/index.html#setup",
    "href": "posts/2023/2023-10-25-serverless_shiny/index.html#setup",
    "title": "Serverless shiny app embedded in a Quarto Website",
    "section": "",
    "text": "To use shinylive in a Quarto document, you need to first install the shinylive Quarto extension:\nquarto add quarto-ext/shinylive\nalong with the shinylive R package\n\nremotes::install_github(\"posit-dev/r-shinylive\")"
  },
  {
    "objectID": "posts/2023/2023-10-25-serverless_shiny/index.html#quarto.yml-file",
    "href": "posts/2023/2023-10-25-serverless_shiny/index.html#quarto.yml-file",
    "title": "Serverless shiny app embedded in a Quarto Website",
    "section": "",
    "text": "The _quarto.yml file is a project with some basic parameters to define the website. The only additional parameter of note is to include shinylive as a filter.\nproject:\n  type: website\n  output-dir: docs\n  \nformat: \n  html\n  \nwebsite:\n  title: \"shinylive elements quiz\"\n  navbar:\n    left:\n      - index.qmd\n\nfilters:\n  - shinylive"
  },
  {
    "objectID": "posts/2023/2023-10-25-serverless_shiny/index.html#index.qmd",
    "href": "posts/2023/2023-10-25-serverless_shiny/index.html#index.qmd",
    "title": "Serverless shiny app embedded in a Quarto Website",
    "section": "",
    "text": "The shiny app is in a single chunk of the index.qmd file with a code chunk type of shinylive-r and the standalone option set.\n\n---\ntitle: \"Chem symbol test\"\n---\n\nThis is a simple chemical symbol test.  You'll be tested on chemical elements and their names.\n\n```{r}\n#| include: false\nlibrary(shinylive)\n```\n\n```{shinylive-r}\n#| viewerHeight: 300\n#| standalone: true\n\nchem &lt;- data.frame(\n  symbol = c(\"Al\", \"Sb\", \"Ar\", \"As\", \"Ba\", \"Be\", \"Bi\", \n             \"B\", \"Br\", \"Cd\", \"Ca\", \"C\", \"Cs\", \"Cl\", \"Cr\",\n             \"Co\", \"Cu\", \"F\", \"Au\", \"He\", \"H\", \"I\", \"Fe\",\n             \"Kr\", \"Pb\", \"Li\", \"Mg\", \"Mn\", \"Hg\", \"Ne\", \"Ni\",\n             \"N\", \"O\", \"P\", \"Pt\", \"K\", \"Rn\", \"Se\", \"Si\", \"Ag\",\n             \"Na\", \"Sr\", \"S\", \"Te\", \"Sn\", \"Ti\", \"W\",\n             \"U\", \"V\", \"Xe\", \"Zn\", \"Zr\"),\n  name = c(\"aluminum\", \"antimony\", \"argon\", \"arsenic\", \"barium\", \"beryllium\", \"bismuth\", \n           \"boron\", \"bromine\",\"cadmium\", \"calcium\", \"carbon\", \"cesium\", \"chlorine\", \"chromium\",\n           \"cobalt\", \"copper\", \"fluorine\", \"gold\", \"helium\", \"hydrogen\", \"iodine\", \"iron\",\n           \"krypton\", \"lead\", \"lithium\", \"magnesium\", \"mangenese\", \"mercury\", \"neon\", \"nickel\",\n           \"nitrogen\", \"oxygen\", \"phosphorus\", \"platinum\", \"potassium\", \"radon\", \"selenium\", \"silicon\", \"silver\",\n           \"sodium\", \"strontium\", \"sulfur\", \"tellurium\", \"tin\", \"titanium\", \"tungsten\",\n           \"uranium\", \"vanadium\", \"xenon\", \"zinc\", \"zirconium\")\n)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(5, offset = 1, checkboxGroupInput(\"chk_options\", \"Test me on\", choices = names(chem), selected = \"symbol\", inline = TRUE))\n  ),\n  fluidRow(\n    column(5, offset = 1, uiOutput(\"ui_question\")),\n    column(5, \n           fluidRow(uiOutput(\"ui_score\")),\n           fluidRow(uiOutput(\"ui_streak\"))\n           )\n  )\n  \n)\n\nserver &lt;- function(input, output, session) {\n\n  last_num &lt;- 0\n  rv &lt;- reactiveValues(\n    question_count = 0,\n    score = 0,\n    question_type = NULL,\n    question = NULL,\n    answer = NULL,\n    streak = 0\n  )\n  \n  question_index &lt;- reactive({\n    rv$question_count\n    num &lt;- last_num\n    while (num == last_num) {\n      num &lt;- sample(nrow(chem), size = 1)\n    }\n    last_num &lt;- num\n  })\n  \n  output$ui_question &lt;- renderUI({\n    if (length(input$chk_options) &gt; 0) {\n      rv$question_type &lt;- sample(input$chk_options, size = 1)\n      answer_type &lt;- names(chem)[!names(chem) == rv$question_type]\n      rv$question &lt;- chem[[rv$question_type]][question_index()]\n      rv$answer &lt;- chem[[answer_type]][question_index()]\n      tagList(\n        h3(paste(answer_type, \"for:\", rv$question)),\n        textInput(\"txt_answer\", label = NULL),\n        actionButton(\"but_answer\", \"Submit\")\n      )\n    }\n  })\n  \n  observeEvent(input$but_answer, {\n    if (rv$question_type == \"symbol\") {\n      answer &lt;- tolower(input$txt_answer)\n    } else {\n      answer &lt;- input$txt_answer\n    }\n    if (answer == rv$answer) {\n      rv$score &lt;- rv$score + 1\n      rv$streak &lt;- rv$streak + 1\n      showNotification(ui = \"CORRECT!\", type = \"message\")\n    } else {\n      rv$streak &lt;- 0\n      showNotification(ui = paste0(\"WRONG.  Correct answer is \", rv$answer), type = \"error\")\n    }\n    rv$question_count &lt;- rv$question_count + 1\n  })\n  \n  output$ui_score &lt;- renderUI({\n    h3(paste0(\"Score: \", rv$score, \"/\", rv$question_count), style = \"color: #388E3C\")\n  })\n  \n  output$ui_streak &lt;- renderUI({\n    if (rv$streak &gt; 29) {\n      col &lt;- \"#2E7D32\"\n    } else if (rv$streak &gt; 19) {\n      col &lt;- \"#00838F\"\n    } else if (rv$streak &gt; 9) {\n      col &lt;- \"#1E88E5\"\n    } else if (rv$streak &gt; 0) {\n      col &lt;- \"#8E24AA\"\n    } else {\n      col &lt;- \"#E53935\"\n    }\n    h3(paste0(\"Streak: \", rv$streak), style = paste0(\"color: \", col))\n  })\n\n}\n\napp &lt;- shinyApp(ui = ui, server = server)\n\n```\n\nThe app itself contains the typical ui and server along with the shinyapp() function to execute. It is basic and unoptimized (but it demonstrates the purpose). It takes very little effort to change a standalone app to an embedded one.\nThe quarto website with embedded app is available at https://harveyl888.github.io/shinylive-test/."
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "Quarto is a scientific publishing system used to build documents, presentations, books and websites. Quarto extensions are a powerful way to extend the behavior of Quarto. These extensions are built using Lua, a language that I do not have much familiarity with but, building a simple extension is actually quite straighforward.\nIn this example I’ll create a shortcode extension that allows you to add comments to a Quarto document. The comments can be turned on or off by using an environemnt variable defined in the yaml header.\n\n\nTo initialize a Quarto shortcode extension, use the following command and enter a name for the extension (in this case comment)\nquarto create extension shortcode\nThe following folder structure will be created:\ncomment\n├── _extensions  \n│   └── comment  \n│       ├── _extension.yml  \n│       └── comment.lua  \n├── .gitignore  \n├── .luarc.json  \n├── example.qmd\n└── README.md  \nI use VS Code for coding. When the quarto create command is executed, VS Code opens a new window at the comment folder, ready for development.\n\n\n\nThis Quarto extension allows an author to add comments to a Quarto document. It also adds a parameter to control if comments should included on not when a file is rendered. I’ve found this extension useful when adding instructional comments to a template.\nThe extension contains three shortcodes. One to start a comment block, one to end a comment block and one to add an inline comment.\nThe code concept is pretty simple. For comment blocks, surround the contents in a div with either the cmt class (which can be used to control styling) when the comment variable is set to true, or display: none when the comment variable is set to false. For inline comments surround the contents in a span with the cmt class when the comment variable is set to true.\nThe comment.lua file is shown below.\n-- start a comment block\nfunction comment_start(args, kwargs, meta)\n  cmt = meta['show_comments']\n  if cmt == nil or cmt == false then\n    return pandoc.RawBlock('html', \"&lt;div style = 'display: none;'&gt;\")\n  else\n    return pandoc.RawBlock('html', \"&lt;div class = 'cmt'&gt;\")\n  end\nend\n\n-- end a comment block\nfunction comment_stop()\n  return pandoc.RawBlock('html', \"&lt;/div&gt;\")\nend\n\n-- inline comment\nfunction comment(args, kwargs, meta)\n  txt = pandoc.utils.stringify(args[1])\n  cmt = meta['show_comments']\n  if cmt == true then\n    return pandoc.RawInline('html', \"&lt;span class = 'cmt'&gt;\" .. txt .. \"&lt;/span&gt;\")\n  end \nend\nIn addition to the comment.lua file, an example.qmd should be written (plus, in this case, a style.css css file). If the example.qmd file is previewed then it will automatically update as you edit comment.lua - a great way to ensure that your extension is working as expected. The example.qmd and style.css files for the comment extension are shown below:\n\n\n---\ntitle: \"Comment Example\"\nformat:\n  html:\n    css: style.css\nshow_comments: true\n---\n\n## Comments Test - Commented text within a paragraph\n\nThis is some uncommented text.\n{{&lt; comment_start &gt;}}\nHere is a &lt;b&gt;comment&lt;/b&gt; containing some instructional information.\n{{&lt; comment_stop &gt;}}\nFinally, some additional uncommented text.\n\n## Comments Test - Inline commenting\n\nThis comment is an inline comment {{&lt; comment \"It can include instruction within the text\" &gt;}} followed by addititional text.\n\n\n\n.cmt {\n  color: #AAAA00\n}\nTo run in interactive / preview mode simple execute the command:\nquarto preview example.qmd\n\n\n\n\nThe example.qmd file contains some example Quarto to test the extension along with a header. The header applies styles in the style.css file (the .cmt class) and also defines a boolean parameter called show_comments. The comment.lua file contains three functions, each evaluating to a shortcode in Quarto. They are each explored below.\n\n\nThis shortcode starts a comment block. It takes three arguments, args, kwargs and meta (arguments, named arguments and document/project-level metadata). In this function we only use the document/project-level metadata and run the command cmt = meta['show_comments'] to create a variable, cmt holding the metadata show_comments, a boolean. Generally, arguments passed to lua will be a list of pandoc inlines and require pandoc.utils.stringify() to convert to strings. In our case, we are only passing a single value in show_comments and it will be a boolean.\nIf the cmt variable is false or missing then a div block is started with display: none to hide it. If the cmt variable is true then a div block is started with the .cmt style.\n\n\n\nThis simply closes the div initiated by comment_start().\n\n\n\nThis shortcode adds a comment inline. It works slightly differently to comment_start() by reading the first argument from the shortcode using txt = pandoc.utils.stringify(args[1]). It then defines the cmt variable as in comment_start() and, if cmt is true, outputs the commented text, returning nothing if cmt is not true.\n\n\n\n\nIn this example, I’ve included show_comments as a document-level parameter. It could be substituted at the project-level in _quarto.yml to manage a set of documents / website. It can also be included in _variables.yml as a project-level variable in which case the line cmt = meta['show_comments'] would be replaced by cmt = meta['_quarto-vars']['show_comments'] in order to access variables defined in the _variables.yml file.\n\n\n\nFinally, a licence file was added (MIT licence), README was edited and the extension was pushed to GitHub at https://github.com/harveyl888/comment. To install to a quarto project simply run:\nquarto add harveyl888/comment"
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html#initialization",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html#initialization",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "To initialize a Quarto shortcode extension, use the following command and enter a name for the extension (in this case comment)\nquarto create extension shortcode\nThe following folder structure will be created:\ncomment\n├── _extensions  \n│   └── comment  \n│       ├── _extension.yml  \n│       └── comment.lua  \n├── .gitignore  \n├── .luarc.json  \n├── example.qmd\n└── README.md  \nI use VS Code for coding. When the quarto create command is executed, VS Code opens a new window at the comment folder, ready for development."
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html#building-the-shortcode-extension",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html#building-the-shortcode-extension",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "This Quarto extension allows an author to add comments to a Quarto document. It also adds a parameter to control if comments should included on not when a file is rendered. I’ve found this extension useful when adding instructional comments to a template.\nThe extension contains three shortcodes. One to start a comment block, one to end a comment block and one to add an inline comment.\nThe code concept is pretty simple. For comment blocks, surround the contents in a div with either the cmt class (which can be used to control styling) when the comment variable is set to true, or display: none when the comment variable is set to false. For inline comments surround the contents in a span with the cmt class when the comment variable is set to true.\nThe comment.lua file is shown below.\n-- start a comment block\nfunction comment_start(args, kwargs, meta)\n  cmt = meta['show_comments']\n  if cmt == nil or cmt == false then\n    return pandoc.RawBlock('html', \"&lt;div style = 'display: none;'&gt;\")\n  else\n    return pandoc.RawBlock('html', \"&lt;div class = 'cmt'&gt;\")\n  end\nend\n\n-- end a comment block\nfunction comment_stop()\n  return pandoc.RawBlock('html', \"&lt;/div&gt;\")\nend\n\n-- inline comment\nfunction comment(args, kwargs, meta)\n  txt = pandoc.utils.stringify(args[1])\n  cmt = meta['show_comments']\n  if cmt == true then\n    return pandoc.RawInline('html', \"&lt;span class = 'cmt'&gt;\" .. txt .. \"&lt;/span&gt;\")\n  end \nend\nIn addition to the comment.lua file, an example.qmd should be written (plus, in this case, a style.css css file). If the example.qmd file is previewed then it will automatically update as you edit comment.lua - a great way to ensure that your extension is working as expected. The example.qmd and style.css files for the comment extension are shown below:\n\n\n---\ntitle: \"Comment Example\"\nformat:\n  html:\n    css: style.css\nshow_comments: true\n---\n\n## Comments Test - Commented text within a paragraph\n\nThis is some uncommented text.\n{{&lt; comment_start &gt;}}\nHere is a &lt;b&gt;comment&lt;/b&gt; containing some instructional information.\n{{&lt; comment_stop &gt;}}\nFinally, some additional uncommented text.\n\n## Comments Test - Inline commenting\n\nThis comment is an inline comment {{&lt; comment \"It can include instruction within the text\" &gt;}} followed by addititional text.\n\n\n\n.cmt {\n  color: #AAAA00\n}\nTo run in interactive / preview mode simple execute the command:\nquarto preview example.qmd"
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html#exploring-the-files",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html#exploring-the-files",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "The example.qmd file contains some example Quarto to test the extension along with a header. The header applies styles in the style.css file (the .cmt class) and also defines a boolean parameter called show_comments. The comment.lua file contains three functions, each evaluating to a shortcode in Quarto. They are each explored below.\n\n\nThis shortcode starts a comment block. It takes three arguments, args, kwargs and meta (arguments, named arguments and document/project-level metadata). In this function we only use the document/project-level metadata and run the command cmt = meta['show_comments'] to create a variable, cmt holding the metadata show_comments, a boolean. Generally, arguments passed to lua will be a list of pandoc inlines and require pandoc.utils.stringify() to convert to strings. In our case, we are only passing a single value in show_comments and it will be a boolean.\nIf the cmt variable is false or missing then a div block is started with display: none to hide it. If the cmt variable is true then a div block is started with the .cmt style.\n\n\n\nThis simply closes the div initiated by comment_start().\n\n\n\nThis shortcode adds a comment inline. It works slightly differently to comment_start() by reading the first argument from the shortcode using txt = pandoc.utils.stringify(args[1]). It then defines the cmt variable as in comment_start() and, if cmt is true, outputs the commented text, returning nothing if cmt is not true."
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html#extending",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html#extending",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "In this example, I’ve included show_comments as a document-level parameter. It could be substituted at the project-level in _quarto.yml to manage a set of documents / website. It can also be included in _variables.yml as a project-level variable in which case the line cmt = meta['show_comments'] would be replaced by cmt = meta['_quarto-vars']['show_comments'] in order to access variables defined in the _variables.yml file."
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html#final-steps",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html#final-steps",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "Finally, a licence file was added (MIT licence), README was edited and the extension was pushed to GitHub at https://github.com/harveyl888/comment. To install to a quarto project simply run:\nquarto add harveyl888/comment"
  },
  {
    "objectID": "posts/2024/2024-05-01-bslib_resizable/index.html",
    "href": "posts/2024/2024-05-01-bslib_resizable/index.html",
    "title": "Resizable bslib Cards",
    "section": "",
    "text": "This is a simple example of resizing {bslib} cards for a dashboard. A card can be made resizable (vertical, horizontal or both) by using the resize property. In order to use this in a {bslib} dashboard it can be added using tags$style or included in bs_theme(). Adding the resize-vertical class adds a resize anchor to the botton right of a card.\nlibrary(bslib)\nlibrary(shiny)\n\nui &lt;- page_fillable(\n  tags$head(\n    tags$style(\"\n      .resize-vertical {\n        resize: vertical;\n      }\n    \")\n  ),\n  layout_sidebar(\n    sidebar = sidebar(\n      width = 250,\n      h3(\"controls\")\n    ),\n    card(\n      card_title(\"Card 1\"),\n      height = \"60%\",\n      fill = FALSE,\n      class = 'resize-vertical',\n      card_body(\n        plotOutput('plt')\n      )\n    ),\n    layout_column_wrap(\n      card(\n        card_title(\"Card 2\"),\n        card_body(\n        )\n      ),\n      card(\n        card_title(\"Card 3\"),\n        card_body()\n      )\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  output$plt &lt;- renderPlot({\n    plot(mtcars$mpg, mtcars$hp)\n  })\n  output$data &lt;- renderDataTable(mtcars)\n}\n\nshinyApp(ui, server)"
    "text": "Running testthat within covr\n\n\n\n\n\n\nR\n\n\n\nReturning testthat output from within covr with a custom reporter\n\n\n\n\n\nApr 3, 2025\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nPorting to Quarto\n\n\n\n\n\n\nQuarto\n\n\n\nPorting the site from Hugo to Quarto\n\n\n\n\n\nJan 25, 2025\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\ngt Extensions\n\n\n\n\n\n\nR\n\n\n\nAdding Additional Functionality to the gt Package\n\n\n\n\n\nJan 13, 2025\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nNew Year Fun with Quarto\n\n\n\n\n\n\nQuarto\n\n\n\nA New Year’s balloon pop updated using Quarto.\n\n\n\n\n\nJan 2, 2025\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nTesting for a Float in a Vector\n\n\n\n\n\n\nR\n\n\n\nHow to check if a floating point is in a Vector\n\n\n\n\n\nOct 15, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding Dynamic Nested Loops in R\n\n\n\n\n\n\nR\n\n\n\nBuilding Dynamic Nested Loops in R - an exercise in recursion to retain a nested structure\n\n\n\n\n\nAug 7, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nSelectable Groups in Plotly\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nHow to build a series of selectable groups in Plotly\n\n\n\n\n\nJun 9, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nFun With R6 Classes\n\n\n\n\n\n\nR\n\n\n\nchild R6 classes that update a parent\n\n\n\n\n\nApr 28, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nResizable bslib Cards\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nbslib dashboards with resizable cards\n\n\n\n\n\nMar 1, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nToggling Error Bars in Plotly\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nadding buttons to turn error bars on and off\n\n\n\n\n\nFeb 15, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nPassing and R6 Class to Quarto\n\n\n\n\n\n\nR\n\n\nQuarto\n\n\n\nHow to pass an R6 class to Quarto as a parameter\n\n\n\n\n\nFeb 2, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding a Quarto Extension\n\n\n\n\n\n\nQuarto\n\n\n\nFirst attempt at building a Quarto extension\n\n\n\n\n\nNov 20, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nAdding to a sortable bucketlist\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nDynamically updating a sortable bucketlist upon adding a new element\n\n\n\n\n\nNov 10, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nServerless shiny app embedded in a Quarto Website\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nQuarto\n\n\n\nServerless shiny app embedded in a Quarto Website\n\n\n\n\n\nOct 25, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nInternal labels in textInput box\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nMoving a shiny textInput label to inside the textbox\n\n\n\n\n\nSep 4, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Frameworks 04 - Importing Data\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nShiny Framework\n\n\n\nShiny Frameworks 04 - Importing Data\n\n\n\n\n\nMar 15, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Frameworks 03 - A Simple Interpreter\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nShiny Framework\n\n\n\nShiny Frameworks 03 - A Simple Interpreter\n\n\n\n\n\nMar 10, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Frameworks 02 - Instructions and Parsing\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nShiny Framework\n\n\nOpinion\n\n\n\nShiny Frameworks 02 - Instructions and Parsing\n\n\n\n\n\nMar 5, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Frameworks 01 - Introduction\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nShiny Framework\n\n\nOpinion\n\n\n\nShiny Frameworks 01 - Introduction\n\n\n\n\n\nFeb 16, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nOrdering Pre-selected Items in selectizeInput\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nMaintaining the order of pre-selected items in selectizeInput\n\n\n\n\n\nJan 27, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nplumber API as a package\n\n\n\n\n\n\nR\n\n\nPlumber\n\n\nRSConnect\n\n\n\nBuilding a plumber API as an R package\n\n\n\n\n\nNov 11, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nRunning SAS in Quarto. Part 2\n\n\n\n\n\n\nQuarto\n\n\nPython\n\n\n\nRunning SAS in Quarto. Part 2\n\n\n\n\n\nJul 2, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nRunning SAS in Quarto. Part 1\n\n\n\n\n\n\nQuarto\n\n\nPython\n\n\n\nRunning SAS in Quarto. Part 1\n\n\n\n\n\nJun 27, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nAdding and Retrieving metadata in RMarkdown Documents\n\n\n\n\n\n\nR\n\n\nRMarkdown\n\n\n\nInclude abitrary metadata in RMarkdown documents\n\n\n\n\n\nMay 31, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nAdding Metadata to R Functions\n\n\n\n\n\n\nR\n\n\n\nThree ways to embed metadata in R functions\n\n\n\n\n\nMay 28, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nknitr::knit_child with Quarto\n\n\n\n\n\n\nRMarkdown\n\n\nQuarto\n\n\n\nknitr::knit_child with Quarto\n\n\n\n\n\nMay 12, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\n{distill} Comments With Replies\n\n\n\n\n\n\nR\n\n\nJavascript\n\n\nRSConnect\n\n\n\nIncluding a comments (plus replies) section in {distill} pages\n\n\n\n\n\nMar 5, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\n{distill} Comments\n\n\n\n\n\n\nR\n\n\nJavascript\n\n\nRSConnect\n\n\n\nIncluding a comments section in {distill} pages\n\n\n\n\n\nJan 11, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny hot reload\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nHot reload when working with a parameter file\n\n\n\n\n\nJan 5, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny dynamic tabs\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nExtend and reduce tab count in shiny app\n\n\n\n\n\nJan 1, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nEmbedding {learnr} in {distill}\n\n\n\n\n\n\nR\n\n\n\nHow to share a {learnr} lesson within a {distill} website page\n\n\n\n\n\nNov 30, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nMultiwindow App - RStudio Connect and pins\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nJavascript\n\n\nRSConnect\n\n\n\nBuilding a multiwindow shiny app running on RStudio Connect with pins\n\n\n\n\n\nNov 16, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nConnecting shiny modules through R6\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nShiny Modules\n\n\n\nUsing an R6 class to share data between multiple shiny modules\n\n\n\n\n\nOct 10, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\n{distill} Contact Form\n\n\n\n\n\n\nR\n\n\nJavascript\n\n\nRSConnect\n\n\n\nIncluding a contact form on a {distill} site\n\n\n\n\n\nSep 8, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nMultiwindow App\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nJavascript\n\n\n\nBuilding a multiwindow shiny app\n\n\n\n\n\nAug 30, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nUsing tidyselect in your own package\n\n\n\n\n\n\nR\n\n\n\nUsing tidyselect in your own package\n\n\n\n\n\nJul 22, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nImplementing magrittr\n\n\n\n\n\n\nR\n\n\n\nUsing the magrittr pipe in your own package\n\n\n\n\n\nJul 16, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nPassing a Mixture of Reactive and Non-Reactives to a Shiny Module\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nShiny Modules\n\n\n\nPassing a Mixture of Reactive and Non-Reactives to a Shiny Module\n\n\n\n\n\nJun 20, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Reactivity\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nShiny Modules\n\n\n\nList of Reactives vs Reactive List\n\n\n\n\n\nJun 2, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nBeer Trip Around the World\n\n\n\n\n\n\nR\n\n\n\nTraveling Salesman Problem between breweries\n\n\n\n\n\nMay 19, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nEmailing under Windows using R\n\n\n\n\n\n\nR\n\n\n\nUsing vbs scripting to email from R\n\n\n\n\n\nMay 10, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nA Switch to Hugo\n\n\n\n\n\n\nOpinion\n\n\n\nFrom Jekyll to Hugo\n\n\n\n\n\nMay 3, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nChecking internal consistency of CAS numbers\n\n\n\n\n\n\nR\n\n\nChemistry\n\n\n\nChecking internal consistency of CAS numbers\n\n\n\n\n\nDec 26, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nCAS from pdf\n\n\n\n\n\n\nR\n\n\nChemistry\n\n\n\nExtracting CAS numbers from a PDF\n\n\n\n\n\nDec 24, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nTowards Lab IoT Part Two\n\n\n\n\n\n\nPython\n\n\nIoT\n\n\n\nMoving towards IoT in a lab (part two - python test)\n\n\n\n\n\nOct 16, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nTowards Lab IoT Part One\n\n\n\n\n\n\nIoT\n\n\n\nMoving towards IoT in a lab (part one - installing and command-line testing)\n\n\n\n\n\nOct 16, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nStar Checkbutton\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nIcon star as a checkbox in a shiny app\n\n\n\n\n\nSep 21, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nExtracting data from LCMS PDF\n\n\n\n\n\n\nR\n\n\nChemistry\n\n\n\nExtracting data from Agilent LCMS PDF\n\n\n\n\n\nAug 26, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nSetting up Shiny Apps - An Opinionated View\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nHow I like to set up shiny apps on a single server\n\n\n\n\n\nJun 15, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nvisNetwork Continuous Colors\n\n\n\n\n\n\nR\n\n\n\nBuilding a visNetwork graph with a continuous color-coded fill\n\n\n\n\n\nMar 15, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nAlerts in Chrome and IE\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nJavascript\n\n\n\nDisplaying Browser-Dependent alerts in Shiny Apps\n\n\n\n\n\nFeb 19, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nFormattable - color data according to RSD\n\n\n\n\n\n\nR\n\n\n\nHow to color a formattable table using data from another source. This is useful in coloring a table of averages according to RSD\n\n\n\n\n\nJan 31, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nStopping a crashed RStudio Server Instance\n\n\n\n\n\n\nR\n\n\n\nFinding and Stopping a Crashed Linux RStudio Server Instance\n\n\n\n\n\nJan 8, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny app startup options\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nStartup a shiny app with options in interactive or server mode\n\n\n\n\n\nJan 3, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nMimic Button Press with Enter Key\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nJavascript\n\n\n\nMinic a button press with the Enter key\n\n\n\n\n\nNov 9, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nRestarting a Shiny App\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nForcing a shiny app restart\n\n\n\n\n\nNov 7, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nDatatable Callback in Shiny Module\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nShiny Modules\n\n\n\nDatatable Callback in Shiny Module\n\n\n\n\n\nOct 11, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\ncron, python and slack - a beautiful combination\n\n\n\n\n\n\nPython\n\n\n\nTracking Fantasy Football injuries using cron, python and slack\n\n\n\n\n\nAug 5, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nUsing CSS Variables with Shiny\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nJavascript\n\n\n\nHow to change a CSS variable in a shiny app\n\n\n\n\n\nJul 13, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nInterrupting a background process: asynchronous shiny\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nHow to Interrupt a long-running background process in Shiny\n\n\n\n\n\nJun 13, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nR 3.5.0 Package Update\n\n\n\n\n\n\nR\n\n\n\nWorking with user and system libraries in R\n\n\n\n\n\nMay 23, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nUsing Redmine with RStudio\n\n\n\n\n\n\nR\n\n\n\nIntegrating Redmine in RStudio\n\n\n\n\n\nFeb 21, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nCode instead of Spreadsheet\n\n\n\n\n\n\nOpinion\n\n\n\nWhy can’t we break the Spreadsheet mold in Science?\n\n\n\n\n\nJan 7, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nPlotly Error Bar Hack\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nHack to fix error bar issue when using plotly\n\n\n\n\n\nOct 26, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nFancy Headers in Automated Reports\n\n\n\n\n\n\nR\n\n\nRMarkdown\n\n\n\nCreating a fancy header in an automated markdown report\n\n\n\n\n\nSep 15, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nKEGG and neo4j\n\n\n\n\n\n\nNeo4j\n\n\n\nImporting the KEGG database into neo4j\n\n\n\n\n\nSep 8, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nSQL Server\n\n\n\n\n\n\nR\n\n\n\nConnecting to a SQL Server database\n\n\n\n\n\nAug 10, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nparallel dplyr\n\n\n\n\n\n\nR\n\n\n\nMultidplyr - A parallel version of dplyr\n\n\n\n\n\nMay 24, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Background Process\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nRunning a background process under Shiny\n\n\n\n\n\nApr 8, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nqueryBuilder\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nAn htmlwidget for jQuery QueryBuilder\n\n\n\n\n\nApr 6, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nRStudio Connect and Databases\n\n\n\n\n\n\nR\n\n\nRSConnect\n\n\n\nAccessing a shared space from RStudio Connect\n\n\n\n\n\nMar 30, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nChemSymWords\n\n\n\n\n\n\nR\n\n\nChemistry\n\n\n\nBuilding words using chemical symbols\n\n\n\n\n\nMar 29, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nRapid ANOVA p-value Calculation\n\n\n\n\n\n\nR\n\n\n\nFast calculation of multiple p-values\n\n\n\n\n\nMar 20, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nDatatable Embedded Tables\n\n\n\n\n\n\nR\n\n\nJavascript\n\n\n\nEmbedding subtables in datatables\n\n\n\n\n\nMar 6, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nIn The Cloud\n\n\n\n\n\n\nOpinion\n\n\n\nI’m now totally cloud-based\n\n\n\n\n\nFeb 21, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nSplit-Apply-Combine\n\n\n\n\n\n\nR\n\n\n\nA complex split-apply-combine procedure run three different ways\n\n\n\n\n\nFeb 6, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nMonitoring Fantasy Football Transfers\n\n\n\n\n\n\nR\n\n\n\nLet me know when there’s an update to the Fantasy Premierleague Player List\n\n\n\n\n\nJan 14, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nManaging Users\n\n\n\n\n\n\nR\n\n\nShiny\n\n\n\nManaging users in a Shiny App\n\n\n\n\n\nJan 13, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nFantasy football\n\n\n\n\n\n\nR\n\n\n\nOptimizing a fantasy football team\n\n\n\n\n\nJan 9, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nSortable Tables\n\n\n\n\n\n\nR\n\n\nShiny\n\n\nJavascript\n\n\n\nSorting rows in a datatable\n\n\n\n\n\nJan 7, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nR-Notebooks Collapse Button\n\n\n\n\n\n\nR\n\n\n\nAdding an open/collapse button to an R Notebook\n\n\n\n\n\nDec 20, 2016\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nScraping for Dishwashers\n\n\n\n\n\n\nR\n\n\n\nScraping Home Depot to gather dishwasher information (using rvest)\n\n\n\n\n\nNov 24, 2016\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nWhy blog? Why now?\n\n\n\n\n\n\nOpinion\n\n\n\nWhy am I starting to blog now?\n\n\n\n\n\nNov 23, 2016\n\n\nHarvey\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html",
    "title": "Porting to Quarto",
    "section": "",
    "text": "I’m a big fan of Hugo for building static sites but wanted to port this blog over to Quarto as it’s a framework I’m using more consistently. This post describes some of the extra styling and javascript used to build the blog."
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html#index-page",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html#index-page",
    "title": "Porting to Quarto",
    "section": "Index Page",
    "text": "Index Page\nThe landing page contains a little javascript typewriter effect along with a couple of navigation buttons. The typewriter effect is generated using the Typewriterjs library (https://github.com/tameemsafi/typewriterjs), built as a shortcode extension (see https://github.com/harveyl888/typewriter). The links are simply styled buttons that use Lord icons through the Quarto extension (https://github.com/jmgirard/lordicon)."
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html#lightdark-theme",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html#lightdark-theme",
    "title": "Porting to Quarto",
    "section": "Light/Dark Theme",
    "text": "Light/Dark Theme\nIt’s fairly simple to set a light/dark theme in Quarto and add additional styling. The _quarto.yaml file includes the following lines which specifies an override order. Light and dark themes use a default (flatly, darkly) which is replaced with some general styling in custom.scss. Finally, specific light and dark styles are applied using custom-light.scss and custom-dark.scss.\nformat:\n  html:\n    theme: \n      light: [flatly, custom.scss, custom-light.scss]\n      dark: [darkly, custom.scss, custom-dark.scss]\n\nLight and Dark Swtiching\nBy default, Quarto includes a switch to change from light to dark mode. The switch is, in fact, two icons (switch to the left and switch to the right) from Bootstrap icons. This discussion pointed to the code used to define the light and dark icons, which can be changed by simply copying the svg code from https://icons.getbootstrap.com/. The folllowing has been added to custom.scss to replace the switch with sun and moon icons.\n.navbar .quarto-color-scheme-toggle:not(.alternate) .bi::before { \n  background-image: url('data:image/svg+xml,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"#{colorToRGBA($navbar-light-color)}\" class=\"bi bi-sun\" viewBox=\"0 0 16 16\"&gt;&lt;path d=\"M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6m0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8M8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0m0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13m8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5M3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8m10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0m-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0m9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707M4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708\"/&gt;&lt;/svg&gt;'); \n} \n \n.sidebar-navigation .quarto-color-scheme-toggle:not(.alternate) .bi::before { \n  background-image: url('data:image/svg+xml,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"#{colorToRGBA(theme-dim($body-color, 10%))}\" class=\"bi bi-sun\" viewBox=\"0 0 16 16\"&gt;&lt;path d=\"M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6m0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8M8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0m0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13m8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5M3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8m10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0m-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0m9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707M4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708\"/&gt;&lt;/svg&gt;'); \n} \n \n.navbar .quarto-color-scheme-toggle.alternate .bi::before { \n  background-image: url('data:image/svg+xml,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"#{colorToRGBA($navbar-light-color)}\" class=\"bi bi-moon\" viewBox=\"0 0 16 16\"&gt;&lt;path d=\"M6 .278a.77.77 0 0 1 .08.858 7.2 7.2 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277q.792-.001 1.533-.16a.79.79 0 0 1 .81.316.73.73 0 0 1-.031.893A8.35 8.35 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.75.75 0 0 1 6 .278M4.858 1.311A7.27 7.27 0 0 0 1.025 7.71c0 4.02 3.279 7.276 7.319 7.276a7.32 7.32 0 0 0 5.205-2.162q-.506.063-1.029.063c-4.61 0-8.343-3.714-8.343-8.29 0-1.167.242-2.278.681-3.286\"/&gt;&lt;/svg&gt;'); \n} \n \n.sidebar-navigation .quarto-color-scheme-toggle.alternate .bi::before { \n  background-image: url('data:image/svg+xml,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"#{colorToRGBA(theme-dim($body-color, 10%))}\" class=\"bi bi-moon\" viewBox=\"0 0 16 16\"&gt;&lt;path d=\"M6 .278a.77.77 0 0 1 .08.858 7.2 7.2 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277q.792-.001 1.533-.16a.79.79 0 0 1 .81.316.73.73 0 0 1-.031.893A8.35 8.35 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.75.75 0 0 1 6 .278M4.858 1.311A7.27 7.27 0 0 0 1.025 7.71c0 4.02 3.279 7.276 7.319 7.276a7.32 7.32 0 0 0 5.205-2.162q-.506.063-1.029.063c-4.61 0-8.343-3.714-8.343-8.29 0-1.167.242-2.278.681-3.286\"/&gt;&lt;/svg&gt;'); \n}"
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html#listing-layout",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html#listing-layout",
    "title": "Porting to Quarto",
    "section": "Listing Layout",
    "text": "Listing Layout\nQuarto has a few listing formats built in but also allows you to create your own by scripting in ejs. Initially I tried to build a cool looking listing for blog entries using ejs but realized that some of the interativity, related to clicking on categories, would require to include additional javascript (copied from the Quarto repo). An alternate approach is to keep a standard listing and style it using scss. This was how this site was built.\n\nListing Page Background Color\nTo set body properties for a single page you can add a &lt;style&gt; tag at the top of the quarto qmd file. For example, to set a body background color to grey you could insert the following code just after the yaml heading:\n&lt;style&gt;\n  body {\n    background-color: #eeeeee;\n  }\n&lt;/style&gt;\nSince we have a dark/light mode, I would like the body background color on the listing page to change with the theme of the site. Our themes are built with scss but the &lt;style&gt; tag takes css. In order to make the body background change according to the theme setting I’ve added a css variable to the top of the scss custom-light.scss and custom-dark.scss files. The variable is added before the first section commment.\ncustom-light.scss starts with:\n:root {\n  --post-page-background: #eeeeee;\n}\ncustom-dark.scss starts with:\n:root {\n  --post-page-background: #444444;\n}\nand posts/index.qmd contains the following code just after the yaml header:\n&lt;style&gt;\n  body {\n    background-color: var(--post-page-background);\n  }\n&lt;/style&gt;\nWhen the posts listing page is built the background color will be set to the css variable --post-page-background which is defined in the light and dark scss files."
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html#blog-categories",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html#blog-categories",
    "title": "Porting to Quarto",
    "section": "Blog Categories",
    "text": "Blog Categories\nBlog categories are listed to the side of the posts. They are styled using scss with a little javascript to remove the parentheses around the counts. Javascript is shown below. The code works by finding and looping over all instances of the quarto-category-count class and removing the first and last character. The document.addEventListener(\"DOMContentLoaded\", function() {}) code waits for the page to load before executing.\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  const counts = document.querySelectorAll('.quarto-category-count');\n  counts.forEach(count =&gt; {\n    let text = count.textContent;\n    if (text.length &gt; 1) {\n      count.textContent = text.slice(1, -1);\n    } else {\n      count.textContent = '';\n    }\n  });\n});  \nThe javascript script file is added to the bottom of each page by adding the following to _quarto.yml:\nformat:\n  html:\n    include-after-body:\n      - text: |\n          &lt;script type=\"text/javascript\" src=\"/_resources/js/scripts.js\"&gt;&lt;/script&gt;"
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html#notes",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html#notes",
    "title": "Porting to Quarto",
    "section": "Notes",
    "text": "Notes\nPorting from Hugo to Quarto was simple and I can now execute R and python as blog entries are built. In addition, shinylive will allow shiny to be run from within Quarto pages."
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html",
    "title": "New Year Fun with Quarto",
    "section": "",
    "text": "We have a New Year tradition of a balloon pop for the kids. We blow up a number of balloons, each containing a piece of paper with a fun game or activity. Throughout New Year’s Eve we pop a balloon every half hour and the kids enjoy the surprise. Of course, it’s much more fun to build this in Quarto so here we go. The repo is available at https://github.com/harveyl888/newyear."
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html#introduction",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html#introduction",
    "title": "New Year Fun with Quarto",
    "section": "",
    "text": "We have a New Year tradition of a balloon pop for the kids. We blow up a number of balloons, each containing a piece of paper with a fun game or activity. Throughout New Year’s Eve we pop a balloon every half hour and the kids enjoy the surprise. Of course, it’s much more fun to build this in Quarto so here we go. The repo is available at https://github.com/harveyl888/newyear."
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html#balloon-pop-quarto",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html#balloon-pop-quarto",
    "title": "New Year Fun with Quarto",
    "section": "Balloon Pop Quarto",
    "text": "Balloon Pop Quarto\nThe concept is simple. Inside each balloon is a QR code instead of an activity. The QR code points to an entry on a Quarto blog. Kids pop a balloon, scan the code, and the fun activity pops up. There’s a distinct advantage to this approach over the old paper method - by decoupling the activity from the balloon we can easily change the activity (by updating the blog) without having to destroy the balloon."
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html#qr-codes",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html#qr-codes",
    "title": "New Year Fun with Quarto",
    "section": "QR Codes",
    "text": "QR Codes\nGenerating QR codes is fairly straightforward with the {qrcodes} package. The following Quarto file generates a QR code for each entry in the posts folder. It reads the websites’s site-url parameter from _quarto.yml, construct’s each post’s URL, generates the QR code and outputs the codes to a page on the site (see example at https://harveyl888.github.io/newyear/QRcodes.html).\n---\ntitle: QR Codes\n---\n\n```{r}\n#| label: build_codes\n#| echo: false\n#| results: asis\n\nquarto_yaml &lt;- yaml::read_yaml(\"_quarto.yml\")\nurl &lt;- quarto_yaml$website$`site-url`\nposts &lt;- list.files(\"posts\")\n\ncat(\"::: {#fig-QR layout-ncol=3}\\n\")\n\nfor (i in seq_along(posts)) {\n  # generate a QR code\n  qr &lt;- qrcode::qr_code(file.path(url, \"posts\", posts[i]))\n\n  # save QR code as svg\n  f &lt;- file.path(\"qr_svg\", sprintf(\"f%02i.svg\", i))\n  qrcode::generate_svg(qr, filename = f, show = FALSE, size = 200)\n\n  # get title and add as label\n  post_yaml &lt;- rmarkdown::yaml_front_matter(file.path(\"posts\", posts[i], \"index.qmd\"))\n  cat(paste0(\"![\", post_yaml$title,  \"](\", f, \")\\n\\n\"))\n}\n\ncat(\"QR Codes\\n\\n:::\\n\")\n\n```"
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html#extensions",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html#extensions",
    "title": "New Year Fun with Quarto",
    "section": "Extensions",
    "text": "Extensions\nOne of the great things about Quarto is the ability to write extensions. I added two simple shortcode extensions for a game of charades and to give a list of tongue-twisters. Quarto extensions are written in lua but, in this case, the extensions simply take some parameters from the post header and build a button, passing the parameters to a javascript function. The extensions can be found at https://github.com/harveyl888/newyear/tree/main/_extensions/newyear."
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html#conclusion",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html#conclusion",
    "title": "New Year Fun with Quarto",
    "section": "Conclusion",
    "text": "Conclusion\nOverall, a fun, simple idea which only took a few hours to put together from scratch."
  },
  {
    "objectID": "posts/2024/2024-08-07-dynamic_loops/index.html",
    "href": "posts/2024/2024-08-07-dynamic_loops/index.html",
    "title": "Building Dynamic Nested Loops in R",
    "section": "",
    "text": "lapply is a fundemental programming function in R, used to apply a function over a list ot a vector. Running lapply in a nested manner leads to a nested outcome. For example, the following code, when executed leads to the output below:\n\nlapply(c(\"A\", \"B\"), function(x) {\n  lapply(c(\"C\", \"D\"), function(y) {\n    paste0(x, y, collapse = \"\")\n  })\n})\n\n[[1]]\n[[1]][[1]]\n[1] \"AC\"\n\n[[1]][[2]]\n[1] \"AD\"\n\n\n[[2]]\n[[2]][[1]]\n[1] \"BC\"\n\n[[2]][[2]]\n[1] \"BD\"\n\n\nThere are situations where the inputs to the apply function may not be known in advance. Furthermore, we may not know how deep to nest. The following code uses a recursive approach to apply functions, returning output from a nested function without having to know how deep the nesting goes."
  },
  {
    "objectID": "posts/2024/2024-08-07-dynamic_loops/index.html#introduction",
    "href": "posts/2024/2024-08-07-dynamic_loops/index.html#introduction",
    "title": "Building Dynamic Nested Loops in R",
    "section": "",
    "text": "lapply is a fundemental programming function in R, used to apply a function over a list ot a vector. Running lapply in a nested manner leads to a nested outcome. For example, the following code, when executed leads to the output below:\n\nlapply(c(\"A\", \"B\"), function(x) {\n  lapply(c(\"C\", \"D\"), function(y) {\n    paste0(x, y, collapse = \"\")\n  })\n})\n\n[[1]]\n[[1]][[1]]\n[1] \"AC\"\n\n[[1]][[2]]\n[1] \"AD\"\n\n\n[[2]]\n[[2]][[1]]\n[1] \"BC\"\n\n[[2]][[2]]\n[1] \"BD\"\n\n\nThere are situations where the inputs to the apply function may not be known in advance. Furthermore, we may not know how deep to nest. The following code uses a recursive approach to apply functions, returning output from a nested function without having to know how deep the nesting goes."
  },
  {
    "objectID": "posts/2024/2024-08-07-dynamic_loops/index.html#coding",
    "href": "posts/2024/2024-08-07-dynamic_loops/index.html#coding",
    "title": "Building Dynamic Nested Loops in R",
    "section": "Coding",
    "text": "Coding\nWe’ll start with the calling function, called run_loops().\n\n#' run_loops\n#' Run a series of nested lapply functions, returning a nested\n#' or flattened list\n#' \n#' @param vals list of lists or vectors to run lapply over\n#' @param fn calling function\n#' @param flatten if TRUE then flatten the resulting output\n#' @param ... other named parameters passed to calling function\n#' \nrun_loops &lt;- function(vals, fn, flatten = FALSE, ...) {\n  rtn &lt;- .build_loop(vals = vals, params = list(), fn = fn, ...)\n  if (isTRUE(flatten)) {\n    return(.flatten(rtn, level = length(vals) - 1))\n  } else {\n    return(rtn)\n  }\n}\n\nIn this function, vals is a list of vectors to be called. To mimic the lapply() example above, vals = list(a = c(\"A\", \"B\"), b = c(\"C\", \"D\")). fn is the name of the function to call within the innermost lapply loop. flatten is a boolean specifying whether the resulting output should be flattened or kept as a nested list. ... allows additional parameters to be passed to fn. The function simply calls the recursive function .build_loop() with starting values and either returns the output or the flattened output once recursion has completed.\nNext comes the main recursive function, called .build_loop().\n\n#' .build_loop\n#' Add an lapply function or run the calling function\n#' \n#' @param vals list of lists or vectors to run lapply over\n#' @param params current list of parameters for calling function\n#' @param fn calling function\n#' @param ... other named parameters passed to calling function\n#' \n.build_loop &lt;- function(vals = list(), params = list(), fn, ...) {\n  if (length(vals) &gt; 0) {\n    lapply(vals[[1]], function(x) {\n      .build_loop(vals = vals[-1], params = c(params, setNames(x, names(vals)[1])), fn, ...)\n    })\n\n  } else {\n    return(fn(params, ...))\n  }\n}\n\n.build_loop() takes a number of parameters. vals, params and ... are initially passed from run_loops(). params is a named list of parameters, passed to fn. It’s worth spending a little time understanding this function as it powers the approach. Let’s provide an example and start to work through the logic.\nrun_loops(vals = list(a=c('a', 'b', 'c'), b=c('d', 'e'), c=c('f', 'g')), fn = f1)\nrun_loops() passes vals and fn to .build_loop() as initial values. .build_loop() checks the length of vals (in this case 3) and, if it’s greater than zero, continues. We then construct an lapply function to run over all values of vals[[1]], which, in this case is c(‘a’, ‘b’, ‘c’). Within the lapply function we recursively call .build_loop() on shorter and shorter iterations of vals, removing the first group each time and longer and longer iterations of params, the named list of parameters.\nthe recursive function’s terminal condition exists when vals has been reduced to an empty list and params contains a named list of parameters to pass to the calling function fn. The function fn runs on the named parameters, params which, in the first call will be c(a='a', b='d', c='f'), on the second call will be c(a='a', b='d', c='g'), and so on.\nThe final function is another recursive function, called .flatten(). This function recursively flattens a list to a specified level.\n\n#' .flatten\n#' Recursively flatten a list\n#' \n#' @param l list\n#' @param level level to flatten to\n#'\n.flatten &lt;- function(l, level = 1) {\n  if (purrr::pluck_depth(l) &gt; level) {\n    .flatten(purrr::list_flatten(l), level)\n  } else {\n    l\n  }\n}"
  },
  {
    "objectID": "posts/2024/2024-08-07-dynamic_loops/index.html#execution",
    "href": "posts/2024/2024-08-07-dynamic_loops/index.html#execution",
    "title": "Building Dynamic Nested Loops in R",
    "section": "Execution",
    "text": "Execution\nIn this example, we request a nested structure at three levels. For each combination we’ll run a function, f1. The lapply function has three levels of nesting with 3, 2, and 2 parameters, leading to 3x2x2 = 12 outputs.\nThe f1() function is:\n\n#' f1\n#' Function to test recursive lapply\n#' Paste a series of characters with an optional prefix\n#' \nf1 &lt;- function(params, ...) {\n  args &lt;- list(...)\n  paste0(c(args[[\"prefix\"]], params), collapse = \"\")\n}\n\nrun_loops() can be called as follows:\n\nrun_loops(vals = list(a=c('a', 'b', 'c'), b=c('d', 'e'), c=c('f', 'g')), fn = f1, flatten = FALSE, prefix = \"PRE_\")\n\n[[1]]\n[[1]][[1]]\n[[1]][[1]][[1]]\n[1] \"PRE_adf\"\n\n[[1]][[1]][[2]]\n[1] \"PRE_adg\"\n\n\n[[1]][[2]]\n[[1]][[2]][[1]]\n[1] \"PRE_aef\"\n\n[[1]][[2]][[2]]\n[1] \"PRE_aeg\"\n\n\n\n[[2]]\n[[2]][[1]]\n[[2]][[1]][[1]]\n[1] \"PRE_bdf\"\n\n[[2]][[1]][[2]]\n[1] \"PRE_bdg\"\n\n\n[[2]][[2]]\n[[2]][[2]][[1]]\n[1] \"PRE_bef\"\n\n[[2]][[2]][[2]]\n[1] \"PRE_beg\"\n\n\n\n[[3]]\n[[3]][[1]]\n[[3]][[1]][[1]]\n[1] \"PRE_cdf\"\n\n[[3]][[1]][[2]]\n[1] \"PRE_cdg\"\n\n\n[[3]][[2]]\n[[3]][[2]][[1]]\n[1] \"PRE_cef\"\n\n[[3]][[2]][[2]]\n[1] \"PRE_ceg\"\n\n\nThe function can also be run, returning a flattened list as follows:\n\nrun_loops(vals = list(a=c('a', 'b', 'c'), b=c('d', 'e'), c=c('f', 'g')), fn = f1, flatten = TRUE, prefix = \"PRE_\")\n\n[[1]]\n[1] \"PRE_adf\"\n\n[[2]]\n[1] \"PRE_adg\"\n\n[[3]]\n[1] \"PRE_aef\"\n\n[[4]]\n[1] \"PRE_aeg\"\n\n[[5]]\n[1] \"PRE_bdf\"\n\n[[6]]\n[1] \"PRE_bdg\"\n\n[[7]]\n[1] \"PRE_bef\"\n\n[[8]]\n[1] \"PRE_beg\"\n\n[[9]]\n[1] \"PRE_cdf\"\n\n[[10]]\n[1] \"PRE_cdg\"\n\n[[11]]\n[1] \"PRE_cef\"\n\n[[12]]\n[1] \"PRE_ceg\""
  },
  {
    "objectID": "posts/2024/2024-08-07-dynamic_loops/index.html#alternative-method",
    "href": "posts/2024/2024-08-07-dynamic_loops/index.html#alternative-method",
    "title": "Building Dynamic Nested Loops in R",
    "section": "Alternative method",
    "text": "Alternative method\nAn alternative approach would be to build all combinations of parameters and then send them to the calling function, f1. The base R function expand.grid() can be used to run in this manner.\n\ng &lt;- expand.grid(list(a=c('a', 'b', 'c'), b=c('d', 'e'), c=c('f', 'g')))\napply(g, 1, f1, prefix = \"PRE_\")\n\n [1] \"PRE_adf\" \"PRE_bdf\" \"PRE_cdf\" \"PRE_aef\" \"PRE_bef\" \"PRE_cef\" \"PRE_adg\"\n [8] \"PRE_bdg\" \"PRE_cdg\" \"PRE_aeg\" \"PRE_beg\" \"PRE_ceg\"\n\n\nThe advantage of expand.grid() is that it is far simpler in nature, however the nested structure is lost. The recursive approach outlined above offers additional advantages when working with more complex logic."
  },
  {
<<<<<<< HEAD
    "objectID": "posts/2024/2024-04-28-fun_with_R6_classes/index.html",
    "href": "posts/2024/2024-04-28-fun_with_R6_classes/index.html",
    "title": "Fun With R6 Classes",
    "section": "",
    "text": "R has several object-oriented systems and I’m a big fan of R6. Detailed below is a specific use-case. I wanted a parent class that held a list of child classes with thet specification that the child class instances could update the parent class instance."
  },
  {
    "objectID": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#parent-class",
    "href": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#parent-class",
    "title": "Fun With R6 Classes",
    "section": "Parent Class",
    "text": "Parent Class\nThe parent class is shown below along with a table detailing the public and private fields and methods. the purpose of the parent class is to hold a series of steps along with methods to interact with them. In addition, the parent class has a private field called accumulator which we will update from the child classes.\n\n\n\n\n\n\n\n\npublic/private\nfield/method\ndescription\n\n\n\n\npublic\nname\na label\n\n\npublic\ninitialize()\ncreate a new instance\n\n\npublic\nupdate(n)\nupdate the accumulator by n (default n = 1)\n\n\npublic\ncount()\nreturn the value of the accumulator\n\n\npublic\nadd(step)\nadd a new step to the parent class (steps are child classes)\n\n\npublic\nrun()\nexecute all the steps (child classes)\n\n\npublic\nstatus()\nreturn the status of each step\n\n\npublic\naccumulator\nan accumulator, intially set to 0\n\n\nprivate\nsteps\nlist of steps\n\n\n\n\n#' R6 parent class\nparent_class &lt;- R6::R6Class(\n  \"parent_class\",\n  public = list(\n    \n    #' @field name Class label\n    name = \"\",\n    \n    #' @description\n    #' Initialize the class\n    initialize = function(name) {\n      self$name = name\n      invisible(self)\n    },\n    \n    #' @description\n    #' Update accumulator by value\n    update = function(n = 1) {\n      private$accumulator &lt;- private$accumulator + n\n    },\n    \n    #' @description\n    #' Return the value of the accumulator\n    count = function() {\n      return(private$accumulator)\n    },\n    \n    #' @description\n    #' Add a new step\n    #' @param step type of step to add\n    add = function(step) {\n      new_name &lt;- paste0(sample(LETTERS, size = 8), collapse = \"\")\n      new_step &lt;- get(step)$new(name = new_name)\n      private$steps[[new_name]] &lt;- new_step\n    },\n    \n    #' @description\n    #' Run the steps\n    run = function() {\n      for (s in private$steps) {\n        s$execute(parent = self)\n      }\n    },\n    \n    #' @description\n    #' Return status of steps\n    status = function() {\n      lapply(private$steps, function(s) {\n        list(name = s$name, value = s$val, status = s$status)\n      }) |&gt; dplyr::bind_rows()\n    }\n    \n  ),\n  \n  private = list(\n    accumulator = 0,\n    steps = list()\n  )\n)"
  },
  {
    "objectID": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#child-class---generic",
    "href": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#child-class---generic",
    "title": "Fun With R6 Classes",
    "section": "Child Class - Generic",
    "text": "Child Class - Generic\nFor child classes we first build a generic class that can manage any function that is common across the child classes. We can then use the property of inheritance so that the generic child class methods are available for all child classes, adding any specific methods. The generic class is shown below along with a list of public fields and methods.\n\n\n\n\n\n\n\nfield/method\ndescription\n\n\n\n\nname\na label\n\n\nval\nnumeric to store a class value (intial = NA)\n\n\nstatus\nstatus notification - possible values are initialized and run\n\n\ninitialize()\ncreate a new instance\n\n\nexecute()\nexecute the class - set val equal to parent$count() and change status to run\n\n\n\n\nchild_class &lt;- R6::R6Class(\n  \"child_class\",\n  public = list(\n    \n    #'  @field name class label\n    name = NULL,\n    \n    #' @field val class value\n    val = NA,\n    \n    #' @field status class status\n    status = \"initialized\",\n    \n    #' @description\n    #' Initialize class\n    initialize = function(name) {\n      self$name &lt;- name\n    },\n    \n    #' @description\n    #' Execute the class.  Set internal value equal to the\n    #'     parent class `accumulator`\n    #' @param parent Parent class\n    execute = function(parent) {\n      self$val &lt;- parent$count()\n      self$status &lt;- \"run\"\n    }\n  )\n)"
  },
  {
    "objectID": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#child-class---child-classes",
    "href": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#child-class---child-classes",
    "title": "Fun With R6 Classes",
    "section": "Child Class - Child Classes",
    "text": "Child Class - Child Classes\nWe define two child classes. The first increases the parent accumulator field by one, and the second doubles it. Each child class inherits the generic class to avoid repetition. The only change from the generic class is the public execute() method.\n\n\n\n\n\n\n\nfield/method\ndescription\n\n\n\n\nexecute()\nexecute the class - set val equal to parent$count(), change parent accumulator according to the step, and change status to run\n\n\n\n\nstep_add_one &lt;- R6::R6Class(\n  \"step_add_one\",\n  \n  inherit = child_class,\n  \n  public = list(\n    \n    #' @description\n    #' Execute the class.  Set internal value equal to the\n    #'     parent class `accumulator` and increase the parent\n    #'     class `accumulator` by 1.\n    #' @param parent Parent class\n    execute = function(parent) {\n      self$val &lt;- parent$count()\n      parent$update()\n      self$status &lt;- \"run\"\n    }\n  )\n)\n\n\nstep_double &lt;- R6::R6Class(\n  \"step_double\",\n  \n  inherit = child_class,\n  \n  public = list(\n    \n    #' @description\n    #' Execute the class.  Set internal value equal to the\n    #'     parent class `accumulator` and multiply the parent\n    #'     class `accumulator` by 2.\n    #' @param parent Parent class\n    execute = function(parent) {\n      self$val &lt;- parent$count()\n      parent$update(n = parent$count())\n      self$status &lt;- \"run\"\n    }\n  )\n)"
  },
  {
    "objectID": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#execution",
    "href": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#execution",
    "title": "Fun With R6 Classes",
    "section": "Execution",
    "text": "Execution\n\n# initialize the parent class\nmy_parent &lt;- parent_class$new('parent class')\n\n# step_add_one - add a single number to the counter\nmy_parent$add('step_add_one')\nmy_parent$add('step_add_one')\n\n# step_double - double the counter\nmy_parent$add('step_double')\nmy_parent$add('step_double')\n\n# return the counter value\nmy_parent$count() \n\n[1] 0\n\n\n\n# print the status of each step\nmy_parent$status() \n\n# A tibble: 4 × 3\n  name     value status     \n  &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt;      \n1 SQAKMEDO NA    initialized\n2 HBTISPCF NA    initialized\n3 NQRYSKHL NA    initialized\n4 EKAHXLGF NA    initialized\n\n\n\n# run - execute each step in turn\nmy_parent$run()\n\n# return the counter value\nmy_parent$count()\n\n[1] 8\n\n\n\n# print the status of each step\nmy_parent$status()\n\n# A tibble: 4 × 3\n  name     value status\n  &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; \n1 SQAKMEDO     0 run   \n2 HBTISPCF     1 run   \n3 NQRYSKHL     2 run   \n4 EKAHXLGF     4 run   \n\n\nRunning the code above creates a parent class instance called my_parent. Four steps are added to the parent class (step_add_one twice and step_double twice). At this point, the accumulator (my_parent$count()) is 0 and my_parent$status() shows all steps are initialized as no steps have been executed. After my_parent$run() is run and all steps executed, the accumulator is 8 (add 1, add 1, double, double) and my_parent$status() shows all steps are run.\nThe accumulator is a field in the parent and it is updated through the child classes."
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html",
    "title": "New Year Fun with Quarto",
    "section": "",
    "text": "We have a New Year tradition of a balloon pop for the kids. We blow up a number of balloons, each containing a piece of paper with a fun game or activity. Throughout New Year’s Eve we pop a balloon every half hour and the kids enjoy the surprise. Of course, it’s much more fun to build this in Quarto so here we go. The repo is available at https://github.com/harveyl888/newyear."
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html#introduction",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html#introduction",
    "title": "New Year Fun with Quarto",
    "section": "",
    "text": "We have a New Year tradition of a balloon pop for the kids. We blow up a number of balloons, each containing a piece of paper with a fun game or activity. Throughout New Year’s Eve we pop a balloon every half hour and the kids enjoy the surprise. Of course, it’s much more fun to build this in Quarto so here we go. The repo is available at https://github.com/harveyl888/newyear."
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html#balloon-pop-quarto",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html#balloon-pop-quarto",
    "title": "New Year Fun with Quarto",
    "section": "Balloon Pop Quarto",
    "text": "Balloon Pop Quarto\nThe concept is simple. Inside each balloon is a QR code instead of an activity. The QR code points to an entry on a Quarto blog. Kids pop a balloon, scan the code, and the fun activity pops up. There’s a distinct advantage to this approach over the old paper method - by decoupling the activity from the balloon we can easily change the activity (by updating the blog) without having to destroy the balloon."
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html#qr-codes",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html#qr-codes",
    "title": "New Year Fun with Quarto",
    "section": "QR Codes",
    "text": "QR Codes\nGenerating QR codes is fairly straightforward with the {qrcodes} package. The following Quarto file generates a QR code for each entry in the posts folder. It reads the websites’s site-url parameter from _quarto.yml, construct’s each post’s URL, generates the QR code and outputs the codes to a page on the site (see example at https://harveyl888.github.io/newyear/QRcodes.html).\n---\ntitle: QR Codes\n---\n\n```{r}\n#| label: build_codes\n#| echo: false\n#| results: asis\n\nquarto_yaml &lt;- yaml::read_yaml(\"_quarto.yml\")\nurl &lt;- quarto_yaml$website$`site-url`\nposts &lt;- list.files(\"posts\")\n\ncat(\"::: {#fig-QR layout-ncol=3}\\n\")\n\nfor (i in seq_along(posts)) {\n  # generate a QR code\n  qr &lt;- qrcode::qr_code(file.path(url, \"posts\", posts[i]))\n\n  # save QR code as svg\n  f &lt;- file.path(\"qr_svg\", sprintf(\"f%02i.svg\", i))\n  qrcode::generate_svg(qr, filename = f, show = FALSE, size = 200)\n\n  # get title and add as label\n  post_yaml &lt;- rmarkdown::yaml_front_matter(file.path(\"posts\", posts[i], \"index.qmd\"))\n  cat(paste0(\"![\", post_yaml$title,  \"](\", f, \")\\n\\n\"))\n}\n\ncat(\"QR Codes\\n\\n:::\\n\")\n\n```"
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html#extensions",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html#extensions",
    "title": "New Year Fun with Quarto",
    "section": "Extensions",
    "text": "Extensions\nOne of the great things about Quarto is the ability to write extensions. I added two simple shortcode extensions for a game of charades and to give a list of tongue-twisters. Quarto extensions are written in lua but, in this case, the extensions simply take some parameters from the post header and build a button, passing the parameters to a javascript function. The extensions can be found at https://github.com/harveyl888/newyear/tree/main/_extensions/newyear."
  },
  {
    "objectID": "posts/2025/2025-01-02-new_year_quarto/index.html#conclusion",
    "href": "posts/2025/2025-01-02-new_year_quarto/index.html#conclusion",
    "title": "New Year Fun with Quarto",
    "section": "Conclusion",
    "text": "Conclusion\nOverall, a fun, simple idea which only took a few hours to put together from scratch."
  },
  {
    "objectID": "posts/2025/2025-07-14-capturing_functions/index.html",
    "href": "posts/2025/2025-07-14-capturing_functions/index.html",
    "title": "Capturing functions in R",
    "section": "",
    "text": "Here’s a little code snippet used to capture a function and its arguments. A use-case is to define the function when building metacode.\nThe function get_function() takes the name of an R function that exists in memory and returns the function definition as it was be defined in code. Two trailing lines are removed: &lt;environment&gt; is the environment in which the function was defined, typically namespace:base for base R functions or namespace:pkg for a function from package pkg; &lt;bytecode&gt; indicates that the function has been compiled into bytecode.\nget_function &lt;- function(fn) {\n  \n  ## capture the function\n  fn_txt &lt;- capture.output(print(get(fn)))\n  \n  if (length(fn_txt) &gt; 0) {\n    \n    fn_txt[1] &lt;- paste(fn, \"&lt;-\", fn_txt[1])\n    \n    if (grepl(\"&lt;environment\", fn_txt[length(fn_txt)])) {\n      fn_txt &lt;- fn_txt[-length(fn_txt)]\n    }\n    if (grepl(\"&lt;bytecode\", fn_txt[length(fn_txt)])) {\n      fn_txt &lt;- fn_txt[-length(fn_txt)]\n    }\n    fn_txt &lt;- paste(fn_txt, collapse = \"\\n\")\n  }\n  return(fn_txt)\n  \n}"
  },
  {
    "objectID": "posts/2025/2025-07-14-capturing_functions/index.html#example",
    "href": "posts/2025/2025-07-14-capturing_functions/index.html#example",
    "title": "Capturing functions in R",
    "section": "Example",
    "text": "Example\n\nmy_function &lt;- function(x) {\n  # return x + 1\n  x + 1\n}\n\ncat(get_function(\"my_function\"))\nmy_function &lt;- function (x)\n{\n    # return x + 1\n    x + 1\n}"
  },
  {
    "objectID": "posts/2025/2025-07-14-capturing_functions/index.html#why-not-use-deparse",
    "href": "posts/2025/2025-07-14-capturing_functions/index.html#why-not-use-deparse",
    "title": "Capturing functions in R",
    "section": "Why not use deparse?",
    "text": "Why not use deparse?\ndeparse() and deparse() are base R functions that return unevaluated R expressions into strings. Passing a function name to deparse() leads to a similar output, however any comments are removed from the output.\n\nfn_deparse &lt;- deparse(my_function)\nfn_deparse &lt;- paste(fn_deparse, collapse = \"\\n\")\ncat(fn_deparse)\n\nfunction (x) \n{\n    x + 1\n}"
  },
  {
    "objectID": "posts/2025/2025-07-01-inserting_chunk/index.html",
    "href": "posts/2025/2025-07-01-inserting_chunk/index.html",
    "title": "Inserting Code Chunks into RMarkdown/Quarto",
    "section": "",
    "text": "This is a short post to demonstrate a function that can be used to insert code chunks, from a library of chunks, into an active RMarkdown or Quarto document. The concept is simple - read in a chunk of code from a location, in this case GitHub, and use functions from {rstudioapi} to insert it at the current cursor position."
  },
  {
    "objectID": "posts/2025/2025-07-01-inserting_chunk/index.html#introduction",
    "href": "posts/2025/2025-07-01-inserting_chunk/index.html#introduction",
    "title": "Inserting Code Chunks into RMarkdown/Quarto",
    "section": "",
    "text": "This is a short post to demonstrate a function that can be used to insert code chunks, from a library of chunks, into an active RMarkdown or Quarto document. The concept is simple - read in a chunk of code from a location, in this case GitHub, and use functions from {rstudioapi} to insert it at the current cursor position."
  },
  {
    "objectID": "posts/2025/2025-07-01-inserting_chunk/index.html#code-and-example",
    "href": "posts/2025/2025-07-01-inserting_chunk/index.html#code-and-example",
    "title": "Inserting Code Chunks into RMarkdown/Quarto",
    "section": "Code and Example",
    "text": "Code and Example\nadd_code_chunk &lt;- function(snippet = NULL, fences = TRUE) {\n\n  if (!is.null(snippet)) {\n    location &lt;- \"https://raw.githubusercontent.com/harveyl888/insert-chunks/refs/heads/main/\"\n    snippet_location &lt;- paste0(file.path(location, snippet), \".qmd\")\n    s &lt;- readLines(snippet_location) |&gt;\n      paste(collapse = \"\\n\")\n\n    if (fences == TRUE) {\n      s &lt;- paste(\"```{r}\", s, \"```\", sep = \"\\n\")\n    }\n\n    ## inject at current cursor position\n    l &lt;- rstudioapi::getSourceEditorContext()\n    rstudioapi::insertText(text = s, id = l$id)\n\n  }\n}\nThe function can be run from the console add_code_chunk(\"testfile_01\", chunk = TRUE) to insert the contents of harveyl888/insert-chunks/testfile_01.qmd at the current cursor position. With fences = TRUE the chunk fences will be included.\nThe two {rstudioapi} functions take care of placing the content at the cursor. rstudioapi::getSourceEditorContent() grabs details of the current open editor window. It returns a list with the follow members:\n\nid. A unique ID\npath. The document path\ncontents. The document contents\nselection. The currently selected region range\n\nFor the purpose of inserting code, we want to capture the id, so that we can refer to the open document.\nThe second function, rstudioapi::insertText() inserts text into a chosen document. We use the document id returned by rstudioapi::getSourceEditorContent() and place text at the current cursor position.\nHere’s an initial document\n\n## Heading\n\nSome initial text\n\nand here it is after scrolling to the end and executing add_code_chunk(\"testfile_01\", chunk = TRUE)\n\n## Heading\n\nSome initial text\n\n```{r}\ndf &lt;- mtcars |&gt;\n  dplyr::filter(cyl == 6)\nprint(nrow(df))\n```"
  },
  {
    "objectID": "posts/2022/2022-05-28-metadata/index.html",
    "href": "posts/2022/2022-05-28-metadata/index.html",
    "title": "Adding Metadata to R Functions",
    "section": "",
    "text": "This post describes three ways to tag functions with metadata."
  },
  {
    "objectID": "posts/2022/2022-05-28-metadata/index.html#attributes",
    "href": "posts/2022/2022-05-28-metadata/index.html#attributes",
    "title": "Adding Metadata to R Functions",
    "section": "Attributes",
    "text": "Attributes\nUsing attributes is a simple way to add metadata to any object in R. Data frames and other objects already use attributes to hold metadata which are accessible via the attributes function.\n\ndf &lt;- data.frame(a = 1:5, b = letters[1:5])\n\n## retrieve attributes\nattributes(df)\n\n$names\n[1] \"a\" \"b\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3 4 5\n\n\nMetadata can be added by simply using the attributes function and retrieved using attr.\n\nf &lt;- function(x, y) {\n    sum(x, y)\n}\n\n## add two new attributes\nattrs &lt;- attributes(f)\nattrs$f &lt;- \"function: sum\"\nattrs$param_count &lt;- 2\nattributes(f) &lt;- attrs\n\n\n## list all attributes\nattributes(f)\n\n$f\n[1] \"function: sum\"\n\n$param_count\n[1] 2\n\n\n\n## retrieve a single attribute\nattr(f, \"param_count\")\n\n[1] 2"
  },
  {
    "objectID": "posts/2022/2022-05-28-metadata/index.html#metadata-in-comment",
    "href": "posts/2022/2022-05-28-metadata/index.html#metadata-in-comment",
    "title": "Adding Metadata to R Functions",
    "section": "Metadata in comment",
    "text": "Metadata in comment\nMetadata can be associated with any R object using comment. The comment is, in fact, simply an attribute with the limitation that it must be a character vector. Multiple items of metadata can be attached using the comment function.\n\nf &lt;- function(x, y) {\n    sum(x, y)\n}\n\ncomment(f) &lt;- c(f = \"function: sum\", param_count = \"2\")\n\nOnce set, comment can be used to retrieve one of more items of metadata.\n\ncomment(f)\n\n              f     param_count \n\"function: sum\"             \"2\" \n\ncomment(f)[[\"param_count\"]]\n\n[1] \"2\"\n\n\nFor a more complex data structure a json object can be attached. Note that in the example below, param_count is a numeric as opposed to a character type imposed when using comment to hold a vector.\n\nf &lt;- function(x, y) {\n    sum(x, y)\n}\n\ncomment(f) &lt;- jsonlite::toJSON(list(f = \"function: sum\", param_count = 2), auto_unbox = TRUE)\n\n\n## retrieving metadata (comment)\ncomment(f)\n\n{\"f\":\"function: sum\",\"param_count\":2} \n\njsonlite::fromJSON(comment(f))\n\n$f\n[1] \"function: sum\"\n\n$param_count\n[1] 2"
  },
  {
    "objectID": "posts/2022/2022-05-28-metadata/index.html#metadata-in-roxygen2",
    "href": "posts/2022/2022-05-28-metadata/index.html#metadata-in-roxygen2",
    "title": "Adding Metadata to R Functions",
    "section": "Metadata in roxygen2",
    "text": "Metadata in roxygen2\nMetadata can be included in custom roxygen2 tags. Once added it can be retrieved programatically.\nIn order to demonstrate this method we need to build two packages - one for the custom tag and the other to demonstate its use in a function.\n\nPackage 1 - Custom roxygen2 tag\nThis package consists of a number of functions to define a new roclet, metadata which can be used to store metadata for a function. The R code is shown below.\n\n#' roclet to parse @metadata tag\n#'\n#' @import roxygen2\n#' @export\nmetadata &lt;- function() {\n  roxygen2::roclet(\"metadata\")\n}\n\n\n#' @rdname metadata\n#' @importFrom roxygen2 tag_markdown\n#' @export\nroxy_tag_parse.roxy_tag_metadata &lt;- function(x) {\n  roxygen2::tag_markdown(x)\n}\n\n\n#' @rdname metadata\n#' @importFrom roxygen2 rd_section\n#' @export\nroxy_tag_rd.roxy_tag_metadata &lt;- function(x, base_path, env) {\n  roxygen2::rd_section('metadata', x$val)\n}\n\n#' @rdname metadata\n#' @export\nformat.rd_section_metadata &lt;- function(x, ...) {\n  paste0(\n    \"\\\\section{Metadata}{\\n\",\n    x$value,\n    \"}\\n\"\n  )\n}\n\n\n#' @rdname metadata\n#' @export\nroclet_process.roclet_metadata &lt;- function(x, blocks, env, base_path) {\n  x\n}\n\n\n#' @rdname metadata\n#' @export\nroclet_output.roclet_metadata &lt;- function(x, results, base_path, ...) {\n  x\n}\n\nAn explanation of extending roxygen2 can be found with the roxygen2 documentation.\nAfter running roxygen2::roxygenize() to document and build the NAMESPACE file, this package can be built and installed.\n\n\nPackage 2 - testing\nTo test the roclet we need to build a second package consisting of a single function, my_function.\n\n#' my function\n#'\n#' my function to test metadata roclet\n#'\n#' @metadata \\{\"a\":1, \"b\":\"text string\", \"c\": \\[4, 5, 6\\]\\}\n#'\n#' @export\nmy_function &lt;- function(x) {\n  x\n}\n\nThis function contains the new roclet @metadata which holds a json-encoded string of parameters.\nIn addition to the function we need to add this line to the DESCRIPTION file:\n\nRoxygen: list(markdown = TRUE, roclets = c(\"namespace\", \"rd\", \"collate\", \"roxymeta::metadata\"))\n\nOnce roxygen2::roxygenize() is run, the function documentation incudes the new tag:\n\n\n\nFunction to retrieve metadata\nNow that the metadata has been attached to a function it can be retrieved using the code below:\n\n#' extract parameters from roxygen tags\n#'\n#' extract parameters from roxygen tags\n#'\n#' @param n Namespace\n#' @param f Function\n#'\n#' @importFrom tools Rd_db\n#' @importFrom jsonlite fromJSON\n#'\n#' @export\n#'\nget_params &lt;- function(n, f) {\n  db &lt;- tools::Rd_db(n)\n  fn_rd &lt;- db[[paste0(f, \".Rd\")]]\n  \n  ## get list of attributes\n  fn_attributes &lt;- lapply(fn_rd, attributes)\n  \n  ## get sections\n  fn_sections &lt;- which(\n    sapply(fn_attributes, function(x) {\n      x$Rd_tag == \"\\\\section\"\n    })\n  )\n  \n  ## get param section\n  fn_params &lt;- which(\n    sapply(fn_rd[fn_sections], function(x) {\n      x[[1]] == \"Metadata\"\n    })\n  )\n  \n  if (length(fn_params) &gt; 0) {\n    \n    input_tags &lt;- fn_rd[[fn_sections[fn_params]]]\n    param_tag &lt;- input_tags[[2]][[2]]\n    return(jsonlite::fromJSON(as.character(param_tag), simplifyVector = FALSE))\n    \n  } else {\n    \n    return(NULL)\n    \n  }\n  \n}\n\nThis function simply retrieves the Rd file and parses it, retrieving the json-encoded metadata and returning a list.\n\nout &lt;- get_params('roxymetatest', 'my_function')\nout\n\n\n\n$a\n[1] 1\n\n$b\n[1] \"text string\"\n\n$c\n$c[[1]]\n[1] 4\n\n$c[[2]]\n[1] 5\n\n$c[[3]]\n[1] 6\n\n\nThis is a very basic example, simply demonstrating what can be done.\nOne use-case for this approach is for self-building shiny functions. Such a function could embed shiny widget details which are used to build interactive inputs to the function. The shiny widgets could therefore be built for the function prior to running the function itself.\ncode for this example is available in\nhttps://github.com/harveyl888/roxymeta\nhttps://github.com/harveyl888/roxymetatest\nhttps://gist.github.com/harveyl888/1f043414a4102ed5f04e8ed22b73c939"
  },
  {
    "objectID": "posts/2022/2022-05-31-metadata_markdown/index.html",
    "href": "posts/2022/2022-05-31-metadata_markdown/index.html",
    "title": "Adding and Retrieving metadata in RMarkdown Documents",
    "section": "",
    "text": "Metadata can be included in the yaml header of an RMarkdown document. The yaml can store metadata in the params parameter or as individual yaml parameters. For example, the RMarkdown file below adds some metadata parameters to the header: short_title, reference and meta_list. The rmarkdown function rmarkdown::metadata can be used to access the yaml parameters.\n---\ntitle: \"document title\"\nauthor: \"author name\"\nshort_title: \"short\"\nreference: 1\noutput: \"html_document\"\nparams:\n    name: \"my name\"\nmeta_list:\n    meta: \"meta 1\"\n---\n\ntest doc\n\n`r rmarkdown::metadata$short_title`\n\n`r params$name`\n\n`r rmarkdown::metadata$meta_list$meta`\nIn addition, the parameters can be accessed using the rmarkdown::yaml_front_matter() function.\nrmarkdown::yaml_front_matter(\"document.Rmd\")\n$title\n[1] \"document title\"\n\n$author\n[1] \"author name\"\n\n$short_title\n[1] \"short\"\n\n$reference\n[1] 1\n\n$output\n[1] \"html_document\"\n\n$params\n$params$name\n[1] \"my name\"\n\n\n$meta_list\n$meta_list$meta\n[1] \"meta 1\""
  },
  {
    "objectID": "posts/2022/2022-05-31-metadata_markdown/index.html#searching-metadata",
    "href": "posts/2022/2022-05-31-metadata_markdown/index.html#searching-metadata",
    "title": "Adding and Retrieving metadata in RMarkdown Documents",
    "section": "Searching metadata",
    "text": "Searching metadata\nOnce metadata are added to a series of documents, the metadata become searchable using the yaml_front_matter function. By way of example, the functions below build and then search 1000 documents containing dummy data. The time taken to search through 1000 documents on a 4-core laptop was 920 ms.\n\n## create Rmd with yaml\ncreate_rmd &lt;- function(ref, name, folder) {\n\n  x &lt;- glue::glue(\"\n---\ntitle: {name}\nauthor: Harvey\nshort_title: {stringi::stri_rand_strings(1, 20)}\nreference: {ref}\noutput: html_document\nparams:\n    name: {name}\nmeta_list:\n    meta: {ref}\n    text: {stringi::stri_rand_strings(1, 20)}\n---\n\n### {name}\n\nreference: `r rmarkdown::metadata$reference`\n\n{paste0(stringi::stri_rand_lipsum(5), collapse = '\\n\\n')}\n\n\"\n  )\n\n  ## write Rmd file\n  con &lt;- file(file.path(\"./docs\", paste0(\"file_\", name, \".Rmd\")))\n  writeLines(x, con)\n  close(con)\n}\n\n## build a random set of documents\nbuild_docs &lt;- function(n=10, folder) {\n  for (i in seq(n)) {\n    create_rmd(ref=i, name=paste(\"Document\", i), folder=folder)\n  }\n}\n\n## search documents and return matches\nsearch_docs &lt;- function(parameter, search_string, folder) {\n  files &lt;- list.files(folder, pattern = \"*.Rmd\", full.names = TRUE, recursive = TRUE)\n  found &lt;- c()\n  for (f in files) {\n    front_matter &lt;- rmarkdown::yaml_front_matter(f)\n    if (grepl(search_string, front_matter[[parameter]])) found &lt;- append(found, f)\n  }\n  return(found)\n}\n\n\n## create files\nbuild_docs(n=1000, folder=\"./docs\")\n\n## search files\nmicrobenchmark::microbenchmark(\n  match_docs &lt;- search_docs(parameter = \"short_title\",\n                            search_string = \"ae\",\n                            folder = \"./docs/\"),\n  times = 5)\n\nWhen run, the search identified 5 documents that matched."
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html",
    "title": "{distill} Comments With Replies",
    "section": "",
    "text": "This post expands upon the post on {distill} Comments. It includes a method to reply to comments and store comments and replies in an hierarchical manner.\nIn the previous post I covered how we could use RStudio Connect to manage commenting on a static blog. Here we extend it, adding a way to reply to comments and store comments plus replies in a hiersrchical data structure.\nThe concept is essentially the same as the earlier version: a {distill} blog is connected to a {pins} data source via plumber. Here, however, the data source is a data.tree as opposed to a data frame. data.tree is an R package that manages hierarchical data and tree structures. Page comments with replies lends itself nicely to a hierarchical data structure where each node is a comment or reply to a comment. The pinned data.tree holds the comments and replies which can be added or retrieved through the API. Comments are retrieved through javascript functions in the distill blog. The blog, pin board and plumber API all sit on the same RStudio Connect instance."
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#new-comment-form",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#new-comment-form",
    "title": "{distill} Comments With Replies",
    "section": "New Comment Form",
    "text": "New Comment Form\nNew comment form is very similar to the original version. The function comment_form_dt takes site_id and page_id arguments and returns an HTML form. site_id is a unique identifier for a website and page_id is a unique identifier for a page on that site.\nThe form captures a comment and optional user name and passes each of these, along with site_id, page_id and parent_ref to a plumber API. Each comment or reply is given a unique reference number and parent_ref is the reference number of the parent. For page comments parent_ref is simply the page_id but for replies parent_ref is the reference to a comment or a reply. The plumber API updates a pinned data.tree with the new comment. In fact, a javascript function intercepts the submit button triggering an update of the page comments after adding the new one. This allows a new comment to be added without having to refresh the page manually.\nIn addition, the comment_form_dt function adds a div with the id rtncomments which is a placeholder to display comments.\nThe comment_form_dt R function along with the javascript eventListener are shown below. In the code, /addcomment_dt refers to the plumber API endpoint for adding a new comment.\nThe javascript function formsubmit is essentially the same as the earlier function.\n\nlibrary(htmltools)\n\ncomment_form_dt &lt;- function(page_id = 0, site_id = 0) {\n  \n  comment_html &lt;- paste0('\n  &lt;div class=\"comments\"&gt;\n    &lt;div class=\"form-container\"&gt;\n      &lt;h3 class=\"comment-header\"&gt;Post a Comment&lt;/h3&gt;\n      &lt;form action=\"&lt;rsconnect URL&gt;/addcomment_dt\" id=\"my-form\"&gt;\n      \n        &lt;div class=\"form-contents\"&gt;\n          &lt;span class=\"comment-pic\"&gt;\n            &lt;i class=\"far fa-user\"&gt;&lt;/i&gt;\n          &lt;/span&gt;\n          \n          &lt;div class=\"form-details\"&gt;\n            &lt;div class=\"comment-comments\"&gt;\n              &lt;input type=\"text\" id=\"comment\" name=\"comment\" placeholder=\"Your comment\"&gt;&lt;/textarea&gt;\n            &lt;/div&gt;\n            &lt;div class=\"comment-user\"&gt;\n              &lt;span class=\"comment-short\"&gt;\n                &lt;input type=\"text\" id=\"user_name\" name=\"user_name\" placeholder=\"Your name (optional)\" /&gt;\n              &lt;/span&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n\n          &lt;input type=\"hidden\" name=\"site_id\" value=\"', site_id, '\" /&gt;\n          &lt;input type=\"hidden\" name=\"page_id\" value=\"', page_id, '\" /&gt;\n          &lt;input type=\"hidden\" name=\"parent_ref\" value=\"', page_id, '\" /&gt;\n      \n          &lt;span class=\"button-container\"&gt;\n            &lt;input type=\"submit\" value=\"Comment\"&gt;\n          &lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n      &lt;div id=\"rtncomments\"&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  ')\n  htmltools::HTML(comment_html)\n}\n\n\nwindow.addEventListener(\"load\", function() {\n  // add eventlistener to new comment submit button\n  document.getElementById(\"my-form\").addEventListener(\"submit\", formsubmit);\n});\n\n// Intercept submit button and run fetch code\nasync function formsubmit(e) {\n  \n  e.preventDefault();\n  \n  // get event-handler element\n  const form = e.currentTarget;\n  \n  // get form url\n  const url = form.action;\n  \n  // get form data as json string\n  formdata = new FormData(form);\n  const plainFormData = Object.fromEntries(formdata.entries());\n  const jsonFormData = JSON.stringify(plainFormData);\n  \n  // send request and capture output\n  out = await fetch(url, {\n    method: 'POST',\n    body: jsonFormData,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"Accept\": \"application/json\"\n    }\n  })\n  .then(response =&gt; response.json());\n  \n  // update comments\n  update_comments_dt(plainFormData.page_id, plainFormData.site_id);\n\n};"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#existing-comments",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#existing-comments",
    "title": "{distill} Comments With Replies",
    "section": "Existing Comments",
    "text": "Existing Comments\nRetrieving existing comments introduces a new function to build replies and a reply box for each comment/reply. The main function takes site_id and page_id arguments and calls a plumber API which returns comments belonging to the page in json form. A recursive function then builds comments and any replies, terminating each tree branch with a reply box.\nHere, /page_comments_dt refers to the plumber API endpoint for retrieving comments. The search parameters site_id and page_id are appended to the url so that we can limit the returning data to a specific page on a specific site. Since we are using fetch, the webpage and API must live on the same RStudio Connect instance.\n\n// build and populate comment reply box\nfunction reply_comment_box(page_id, site_id, parent_ref) {\n  var out = $('&lt;div/&gt;', {class: 'form-container'}).append([\n    $('&lt;h5/&gt;', {class: 'comment-header comment-header-margin-narrow', text: 'Post a reply'}),\n    $('&lt;form/&gt;', {action: 'https://rsconnect-prod.dit.eu.novartis.net/content/1200/addcomment_dt', method: 'POST', class: 'reply-form'}).append([\n      $('&lt;div/&gt;', {class: 'form-contents'}).append(\n        $('&lt;span/&gt;', {class: 'comment-pic'}).append($('&lt;i/&gt;', {class: 'far fa-user'})),\n        $('&lt;div/&gt;', {class: 'form-details'}).append(\n          $('&lt;div/&gt;', {class: 'comment-comments'}).append(\n            $('&lt;input/&gt;', {type: 'text', name: 'comment', placeholder: 'Your reply'})\n          ),\n          $('&lt;div/&gt;', {class: 'comment-user'}).append(\n            $('&lt;span/&gt;', {class: 'comment-short'}).append(\n              $('&lt;input/&gt;', {type: 'text', name: 'user_name', placeholder: 'Your name (optional)'})\n            )\n          )\n        ),\n        $('&lt;input/&gt;', {type: 'hidden', name: 'site_id', value: site_id}),\n        $('&lt;input/&gt;', {type: 'hidden', name: 'page_id', value: page_id}),\n        $('&lt;input/&gt;', {type: 'hidden', name: 'parent_ref', value: parent_ref}),\n        $('&lt;span/&gt;', {class: 'button-container'}).append(\n          $('&lt;input/&gt;', {type: 'submit', value: 'submit'})\n        )\n      )\n\n    ])\n  ])\n  return(out)\n};\n\n\n// update comments on the page\nfunction update_comments_dt(page_id, site_id) {\n\n  const url = \"&lt;rsconnect URL&gt;/page_comments_dt?\"\n\n  fetch(url + new URLSearchParams({\n    site: site_id, \n    page: page_id,\n  }))\n  .then(response =&gt; response.json())  \n  .then(data =&gt; {\n    \n    // recursive function to print comments\n    function comment_recurse(d) {\n      if (d.hasOwnProperty('children')) {\n        const ul_list_comments = $('&lt;ul/&gt;', {class: 'comment-list'});\n\n        // loop over children (replies) and populate\n        $.each(d.children, function(i, x) {\n          user_name = x.user_name == \"null\" ? \"anonymous user\" : x.user_name;\n          style_txt = 'margin-left: 20px;'\n          ul_list_comments.append(\n            $('&lt;li/&gt;', {class: 'comment-item', style: style_txt}).append([\n              $('&lt;div/&gt;', {class: 'comment-top'}).append([\n                $('&lt;h3/&gt;', {class: 'comment-name', text: user_name}),\n                $('&lt;span/&gt;', {class: 'date-holder'}).append([\n                  $('&lt;i/&gt;', {class: 'far fa-clock'}),\n                  $('&lt;h3/&gt;', {class: 'comment-date', text: x.date})\n                ])\n              ]),\n              $('&lt;p/&gt;', {class: 'comment-text', text: x.comment}),\n              $('&lt;details/&gt;').append([\n                $('&lt;summary/&gt;', {class: 'text-reply', text: 'reply'}),\n                reply_comment_box(x.page_id, x.site_id, x.ref)\n              ]),\n              comment_recurse(x)\n            ]),\n\n          );\n          \n        });\n        return(ul_list_comments)\n      } else {\n        return(null)\n      }\n      \n    }\n      \n    // outer_div - placeholder for comments\n    div_outer = $('&lt;div/&gt;').attr('id', 'div_outer');\n    \n    // add comments if exist\n    if (data.children) {\n      // add comments count\n      div_outer.append('&lt;h3&gt;' + data.children.length + ' Comments&lt;/h3&gt;');\n      \n      // recursively loop through returned comments, building unordered lists\n      ul_list_comments = comment_recurse(data);\n      \n      // add comments to outer div\n      div_outer.append(ul_list_comments);\n    }\n    \n    // update comment holder\n    $(\"#rtncomments\").html(div_outer);\n    \n    // add event listener to class\n    const reply_forms = document.querySelectorAll('.reply-form');\n    reply_forms.forEach(item =&gt; item.addEventListener('submit', formsubmit));\n    \n  })\n  .catch((err) =&gt; console.log(\"Can’t access \" + url + \" response. Blocked by browser?\" + err));\n  \n};"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#plumber-api",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#plumber-api",
    "title": "{distill} Comments With Replies",
    "section": "plumber API",
    "text": "plumber API\nAs previously, the distill blog pages via a plumber API. The API contains two endpoints, a POST endpoint, addcomment_dt which is used to add a new comment and a GET endpoint, page_comments_dt which is used to retrieve comments for a specific page. The comments are stored in a hierarchical data.tree format which is accessible via the {pins} package.\nIn the code below, board_register(\"rsconnect\", server = \"&lt;rsconnect URL&gt;, account = \"&lt;account id&gt;\", key = connectAPIKey) registers a pin board which holds a pin called blog_comment_table+dt.  refers to the RStudio Connect URL and,  is the account associated with the pin. An RStudio Connect API key must be defined and exposed as an environment variable (see below).\n\naddcomment_dt adds the comment to a parent id which sits under a page id, that is, in turn, under a site id. Each comment is given a unique reference id, used as an identifier when comments or replies are added.\npage_comments_dt retrieves a hierarchy of comments and replies for a specified site id and page id. The data.tree obtained is returned as a list.\n\nlibrary(plumber)\nlibrary(jsonlite)\nlibrary(pins)\nlibrary(lubridate)\nlibrary(data.tree)\nlibrary(stringi)\n\n#* Add a comment to the comment table\n#* \n#* @param req request body\n#* \n#* @serializer unboxedJSON\n#* \n#* @post /addcomment_dt\nfunction(req) {\n  \n  ## get the message body\n  body &lt;- jsonlite::fromJSON(req$postBody)\n  \n  ## RSConnect API Key\n  connectAPIKey &lt;- Sys.getenv(\"CONNECT_API_KEY\")\n  \n  ## register rsconnect pin board\n  board_register(\"rsconnect\",\n                 server = \"&lt;rsconnect URL&gt;\",\n                 account = \"&lt;account id&gt;\",\n                 key = connectAPIKey)\n  \n  ## generate a ref for the comment\n  comment_ref &lt;- stringi::stri_rand_strings(n = 1, length = 12)\n  \n  comment &lt;- c(\n    body,\n    list(\n      ref = comment_ref,\n      date = lubridate::now()\n    )\n  )\n  \n  ## check for comments table and create if not present\n  if (nrow(pins::pin_find(\"blog_comment_table_dt\", board = \"rsconnect\")) == 0) {\n    comment_tree &lt;- Node$new(\"comments\")\n  } else {\n    comment_tree &lt;- pins::pin_get(name = \"blog_comment_table_dt\", board = \"rsconnect\") \n  }\n  \n  ## does site_id child node exist?\n  if (is.null(FindNode(comment_tree, comment$site_id))) {\n    comment_tree$AddChild(comment$site_id)\n  }\n  \n  ## does page_id child node exist?\n  site_node &lt;- FindNode(comment_tree, comment$site_id)\n  if (is.null(FindNode(site_node, comment$page_id))) {\n    site_node$AddChild(comment$page_id)\n  }\n  \n  ## add new comment\n  if (!is.na(comment$parent_ref)) {\n    parent_node &lt;- FindNode(site_node, comment$parent_ref)\n  } else {\n    parent_node &lt;- FindNode(site_node, comment$page_id)\n  }\n  do.call(parent_node$AddChild, c(list(name = comment$ref), comment))\n  \n  pins::pin(comment_tree, name = \"blog_comment_table_dt\", board = \"rsconnect\")\n  \n  return(comment)\n}\n\n\n#* Retrieve all comments for a page\n#* \n#* @param site site id\n#* @param page page id\n#* \n#* @serializer unboxedJSON\n#* \n#* @get /page_comments_dt\nfunction(site = \"site_01\", page = \"page_01\") {\n  \n  ## RSConnect API Key\n  connectAPIKey &lt;- Sys.getenv(\"CONNECT_API_KEY\")\n  \n  ## register rsconnect pin board\n  board_register(\"rsconnect\", \n                 server = \"https://rsconnect-prod.dit.eu.novartis.net\",\n                 account = \"liebeha1\",\n                 key = connectAPIKey)\n  \n  ## get table and filter\n  rtn_subtree &lt;- list()\n  if (nrow(pins::pin_find(\"blog_comment_table_dt\", board = \"rsconnect\")) &gt; 0) {\n    \n    ## get pinned comment tree\n    comment_tree &lt;- pins::pin_get(name = \"blog_comment_table_dt\", board = \"rsconnect\")\n    \n    ## is site in comment tree?\n    if (!is.null(FindNode(comment_tree, site))) {\n      \n      ## is page in comment tree and does it have comments?\n      found_page_comments &lt;- FindNode(comment_tree[[site]], page)\n      if (!is.null(found_page_comments)) {\n        rtn_subtree &lt;- as.list(found_page_comments, \n                               mode = \"explicit\", unname = TRUE)\n      }\n      \n    }\n  }\n  return(rtn_subtree)\n}\n\n\n\n\ndata.tree with comments illustrating hierarchy. Data are nested as comments, replies, replies-to-replies, etc. For example, page_01 contains two comments: R8VkpR08pQTA (with a reply cVGBQzLRV9pa) and lHcoISddQbJp\n\n\n\n\n\noutput from data.tree illustrating the metadata held at each node"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#webpage-blog-post-with-comments",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#webpage-blog-post-with-comments",
    "title": "{distill} Comments With Replies",
    "section": "Webpage / Blog Post with Comments",
    "text": "Webpage / Blog Post with Comments\nAny page with comments follows the same approach. The page includes the javascript functions listed above (comments.js), some css styling (style.css, see below) and the comment_form function (sourced from comment.R).\nThere are a few things to note in the code below.\n\nThe two variables, site_id and page_id, are needed to identify comments for the webpage. Ideally, we’d define them in the yaml header and use them as parameters in the markdown text. Unfortunately, when using render_site, markdown parameters are not rendered (see open GitHub issue). site_id and page_id are therefore defined within a chunk.\nThe javascript function update_comments_dt does not sit in a javascript chunk (you can include javascript in rmarkdown by including a chunk with js instead of r in the chunk header). Instead, the code is placed directly within a &lt;script&gt; tag. When processed this way, we can access variables (site_id and page_id) stored in r language chunks earlier in the document.\n\n\n    ---\n    title: \"article 1\"\n    description: |\n      Blog post #1.\n    author:\n      - name: Harvey Lieberman\n    date: 03-03-2022\n    output:\n      distill::distill_article:\n        self_contained: false\n    ---\n\n    ```{r setup, include=FALSE}\n    knitr::opts_chunk$set(echo = FALSE)\n    ```\n\n    ```{r}\n    ## define site and page\n    page_id &lt;- \"page_01\"\n    site_id &lt;- \"site_02\"\n\n    ## add function, css and js to page\n    source(here::here(\"comment_dt.R\"))\n    htmltools::includeCSS(here::here(\"style.css\"))\n    htmltools::includeScript(here::here(\"comment_dt.js\"))\n    ```\n\n    This is a typical blog post but with a comment section added.  \n    Comments include nested replies.\n\n    ```{r}\n    ## include comment form\n    comment_form_dt(page_id = page_id, site_id = site_id)\n\n    ## js below placed in script tags so that R variable can be included\n    ```\n\n    &lt;script&gt;\n    update_comments_dt(page_id = \"`r page_id`\", site_id = \"`r site_id`\")\n    &lt;/script&gt;"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#css",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#css",
    "title": "{distill} Comments With Replies",
    "section": "css",
    "text": "css\nThe style.css file takes care of styling comments. The file is included below.\n.comments {\n  padding: 20px 10px;\n  margin: 0;\n}\n\n.form-container input[type=submit] {\n  background-color: #04AA6D;\n  color: white;\n  padding: 12px 20px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n.form-container input[type=submit]:hover {\n  background-color: #45a049;\n}\n\n.comment-header {\n  font-size: 1.5em;\n  line-height: 1.5em;\n  font-weight: 400;\n  margin-block-start: 1.5em;\n  margin-block-end: 1.5em;\n}\n\n.comment-header-margin-narrow {\n  margin-block-start: 0.5em;\n  margin-block-end: 0.5em;\n}\n\n.form-contents {\n    padding: 10px;\n    margin: 10px;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\n.form-contents .comment-pic {\n    display: flex;\n    font-size: 3em;\n    align-self: flex-end;\n}\n\n.form-details {\n    display: flex;\n    flex-direction: column;\n    flex: 2 1 auto;\n}\n\n.form-details input[type=text] {\n    border-top: 0px;\n    border-bottom: 1px solid #ccc;\n    border-left: 0px;\n    border-right: 0px;\n    outline: 0px;\n    padding: 0;\n    margin-top: 20px;\n    margin-left: 20px;\n    font-weight: normal;\n}\n\n.form-details input[type=text]:focus {\n    border-color: #04AA6D;\n    border-width: 2px;\n}\n\n.comment-comments input[type=text]{\n    width: 90%;\n}\n\n.comment-user {\n    display: flex;\n    flex-direction: row;\n}\n\n.comment-short {\n    width: 50%;\n}\n\n.comment-short input[type=text]{\n    width: 80%;\n}\n\n.button-container {\n    display: flex;\n    align-self: flex-end;\n}\n\n.button-container input[type=submit] {\n  margin: 2px 5px;\n  float: right;\n}\n\n.comment-holder {\n  margin-top: 50px;\n}\n\nul.comment-list {\n  list-style: none;\n  position: relative;\n  padding: 0;\n  border: 1px solid #ccc;\n}\n\nli.comment-item {\n  padding: 20px 10px;\n  margin: 20px 0;\n  position: relative;\n}\n\n.comment-top {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n}\n\n.comment-name {\n  font-size: 1.5em;\n  font-weight: 400;\n  margin: 5px 0;\n  color: #5d5d5d;\n  align-self: flex-start;\n}\n\n.date-holder {\n  color: #5d5d5d;\n  align-self: flex-end;\n  display: inline-flex;\n  align-items: baseline;\n}\n\n.comment-date {\n  font-size: 1em;\n  font-weight: 400;\n  margin: 5px 0 5px 10px;\n}\n\n.comment-text {\n  display: block;\n  margin: 0 0 10px 0;\n}"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#output",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#output",
    "title": "{distill} Comments With Replies",
    "section": "Output",
    "text": "Output\nThe follow screen captures illustrate adding comments and replies.\n\nFirst comment add to a blog post\n\n\n\nFirst comment add to a blog post\n\n\n\nAdding a reply added to comment #1\nClicking on the Reply dropdown opens a reply window\n\n\n\nOnce the reply is added it also includes a dropdown for nesting replies\n\n\n\nReply for comment #2 dropdown opened"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#conclusion",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#conclusion",
    "title": "{distill} Comments With Replies",
    "section": "Conclusion",
    "text": "Conclusion\nRStudio Connect can be used with {pins} to hold nested comments for blog pages. This demonstrates the huge scope that RStudio Connect can play as a CMS."
  },
  {
    "objectID": "posts/2022/2022-07-02_quarto_sas_02/index.html",
    "href": "posts/2022/2022-07-02_quarto_sas_02/index.html",
    "title": "Running SAS in Quarto. Part 2",
    "section": "",
    "text": "An earlier post demonstrated how the jupyter SAS kernel could be used to run SAS from within a Quarto document. This post demonstrates the saspy library and how SAS can be incorporated into Quarto, ultimately passing data to an interactive observable visualization.\n\nSetup and Configure\nsaspy needs to be installed and configured. See the previous post for details on configuring sascfg_personal.py and _authinfo files.\n\n\nQuarto qmd Document\nThe saspy library can be used to communicate between python and sas. It works within Quarto python chunks without requiring the SAS kernel. Below is an example document which demonstrates how to call SAS code directly within a python chunk, how to execute SAS commands from within a python chunk and how to pass data from SAS to python. Once data have been passed from SAS to python we have the opportunity of using observable to render interactive visualizations.\n---\ntitle: \"Quarto Demo with SAS\"\nformat: html\nself-contained: true\n---\n\nA simple demo of using SAS in Quarto.  In this document we demonstrate the following:\n\n-  Running SAS code directly\n-  Importing a SAS dataset\n-  Executing SAS commands using saspy\n-  Converting SAS dataset to a Pandas DataFrame\n-  Interactive visualization using observable \n\n# Setup\n\nsaspy is required to run SAS commands from python/jupyter.\n\n```{python}\nimport saspy\nimport pandas as pd\n\nsas = saspy.SASsession()\n```\n\n# Running SAS code directly from the notebook\n\nThe `sas.submit()` method can be used to submit SAS code directly.  The method returns a dictionary with two keys, _LOG_ and _LST_.  The _LOG_ can simply be printed and the _LST_ rendered as HTML using `sas.HTML()`.\n\n```{python}\n#| echo: true\n#| results: asis\n#| warning: false\n\nll = sas.submit(\"\"\"\nlibname work list;\n\nproc sql;\n   select type, count(*) as 'number of models'n, avg(MPG_city) as 'Avg(MPG_City)'n\n   from sashelp.cars\n   group by type\n   order by 3 desc;\nquit; \n\"\"\")\n\n```\n\n### keys\nlist of dictionary keys returned by SAS\n```{python}\nll.keys()\n```\n\n### LST\nLST output\n```{python}\nsas.HTML(ll['LST'])\n```\n\nAlternatively, the _LST_ can be rendered automatically using the `sas.submitLST()` method\n\n```{python}\n#| echo: true\n#| results: asis\n#| warning: false\n\nll = sas.submitLST(\"\"\"\nlibname work list;\n\nproc sql;\n   select type, count(*) as 'number of models'n, avg(MPG_city) as 'Avg(MPG_City)'n\n   from sashelp.cars\n   group by type\n   order by 3 desc;\nquit; \n\"\"\")\n\n```\n\n# Working with SAS and python together\n\n## Importing data from SAS\n```{python}\ndata_sas = sas.sasdata('cars', 'sashelp')\n```\n\n## Running SAS PROC MEANS from Quarto\n```{python}\ndata_sas.means()\n```\n\n## A simple bar chart (from SAS)\n```{python}\ndata_sas.bar('EngineSize')\n```\n\n## Converting the data to a Pandas DataFrame\n```{python}\ndata_pd = data_sas.to_df()\ndata_pd.describe()\n```\n\n# Interactive visualization with observable\n\nSAS -&gt; python -&gt; observable   \nNow that our data is available in python we can use the `ojs_define` function to make it available to observable.\n\n```{python}\n#| warning: false\n# make data available to observable\nojs_define(ojs_data = data_pd)\n```\n\nThe observabale code to generate the plot below is included as folded code.\n\n```{ojs}\n//| code-fold: true\n// create an interactive input, limiting MPG_City\nviewof MPG_City = Inputs.range(\n  [10, 60], \n  {value: 10, step: 1, label: \"MPG City\"}\n)\n\n// filter data based on the value based on the MPG_City input\nfiltered_data = transpose(ojs_data).filter(function(car) {\n  return MPG_City &lt; car.MPG_City;\n})\n```\n\n\n```{ojs}\n//| code-fold: true\n// build a dotplot from the filtered data\nplt = Plot.plot({\n    marks: [\n        Plot.dot(filtered_data, {x: \"EngineSize\", y: \"Horsepower\"})\n    ]\n})\n```\n\n\nOutput"
=======
    "objectID": "posts/2024/2024-05-01-bslib_resizable/index.html",
    "href": "posts/2024/2024-05-01-bslib_resizable/index.html",
    "title": "Resizable bslib Cards",
    "section": "",
    "text": "This is a simple example of resizing {bslib} cards for a dashboard. A card can be made resizable (vertical, horizontal or both) by using the resize property. In order to use this in a {bslib} dashboard it can be added using tags$style or included in bs_theme(). Adding the resize-vertical class adds a resize anchor to the botton right of a card.\nlibrary(bslib)\nlibrary(shiny)\n\nui &lt;- page_fillable(\n  tags$head(\n    tags$style(\"\n      .resize-vertical {\n        resize: vertical;\n      }\n    \")\n  ),\n  layout_sidebar(\n    sidebar = sidebar(\n      width = 250,\n      h3(\"controls\")\n    ),\n    card(\n      card_title(\"Card 1\"),\n      height = \"60%\",\n      fill = FALSE,\n      class = 'resize-vertical',\n      card_body(\n        plotOutput('plt')\n      )\n    ),\n    layout_column_wrap(\n      card(\n        card_title(\"Card 2\"),\n        card_body(\n        )\n      ),\n      card(\n        card_title(\"Card 3\"),\n        card_body()\n      )\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  output$plt &lt;- renderPlot({\n    plot(mtcars$mpg, mtcars$hp)\n  })\n  output$data &lt;- renderDataTable(mtcars)\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2024/2024-02-15-toggle_plotly_errorbars/index.html",
    "href": "posts/2024/2024-02-15-toggle_plotly_errorbars/index.html",
    "title": "Toggling Error Bars in Plotly",
    "section": "",
    "text": "Plotly charts can be enhanced with custom controls. One use of controls is to update an existing chart. This post will show how to add a couple of buttons to a chart, toggling error bars on and off. It should be noted that coloring by group affects the order (and hence validity) of error bars in a Plotly plot so a workaround has to be employed.\n\nGenerate Some Demo Data\n\nset.seed(12345)\nd &lt;- data.frame(\n time = rep(0:9, 10),\n  group = sample(paste0(\"Group_\", seq(5)), size = 1000, replace = TRUE),\n  value = rnorm(n = 1000) + 1\n) |&gt;\n  dplyr::group_by(time, group) |&gt;\n  dplyr::summarise(mean = mean(value), se = sd(value) / sqrt(dplyr::n())) |&gt;\n  dplyr::ungroup()\n\n`summarise()` has grouped output by 'time'. You can override using the\n`.groups` argument.\n\n\n\n\nInitializing Chart and Adding Traces\nWe’ll build up the chart from the demo data by first initializing an empty plot as follows:\n\np &lt;- plotly::plot_ly(type = 'scatter', mode = 'lines+markers')\n\nThe next step is to add a series of traces, one for each group, without error bars:\n\nfor (x in unique(d$group)) {\n  p &lt;- p |&gt;\n    plotly::add_trace(data = d |&gt; dplyr::filter(group == x), visible = TRUE,\n                      x = ~time, y = ~mean, type = 'scatter', mode = 'lines+markers', color = ~group)\n} \n\nand then a second series of traces, this time with error bars but with the parameter visible=FALSE set to ensure that they are not visible when the chart is initially drawn:\n\nfor (x in unique(d$group)) {\n  p &lt;- p |&gt;\n    plotly::add_trace(data = d |&gt; dplyr::filter(group == x), visible = FALSE,\n                      x = ~time, y = ~mean, type = 'scatter', mode = 'lines+markers', color = ~group,\n                      error_y = ~list(array = se, color = group))\n}\n\nSince we have 5 groups, our plotly chart now contains 5 traces without error bars and 5 traces with error bars. It actually contains one additional empty trace corresponding to the initial plotly::plot_ly() call when the empty chart was built. This can be deduced using plotly::plotly_build() to observe the list object sent to plotly for plotting. At this stage the following code reveals a total of 11 traces:\n\np_obj &lt;- plotly::plotly_build(p)\nprint(length(p_obj$x$data))\n\n[1] 11\n\n\n\n\nBuilding the Menu Buttons\nPlotly does not have the option of a toggle switch or toggle button so we’ll add two buttons - one to plot without error bars and one to plot with error bars. The control works by changing the visible status so that only a subset of plots are visible. As mentioned above, we have 5 traces without error bars and 5 with. We also have the empty trace (the first trace), so in order to see just traces without error bars we’ll want to show only traces 2-6 and in order to see just traces with error bars we’ll want to show only traces 7-11. Here is the code to build the plotly menu buttons:\n\nnum_traces &lt;- length(unique(d$group))\nmenu &lt;- list(\n  active = 0,\n  type = 'buttons',\n  direction = 'right',\n  x = 1.2,\n  y = 0.1,\n  buttons = list(\n    list(\n      label = 'off',\n      method = 'update',\n      args = list(list(visible = c(F, rep(c(TRUE, FALSE), each = num_traces))))\n    ),\n    list(\n      label = 'on',\n      method = 'update',\n      args = list(list(visible = c(F, rep(c(FALSE, TRUE), each = num_traces))))\n    )\n  )\n)\n\nannotation &lt;- list(list(text = \"Error Bars\", x = 1.18, y = 0.13, xref = \"paper\", yref = \"paper\", showarrow = FALSE))\n\n\n\nPlotting\nFinally, the plot can be created by adding the menu items and annotation to the existing plotly object:\n\np |&gt;\n  plotly::layout(updatemenus = list(menu), annotations = annotation)"
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "Quarto is a scientific publishing system used to build documents, presentations, books and websites. Quarto extensions are a powerful way to extend the behavior of Quarto. These extensions are built using Lua, a language that I do not have much familiarity with but, building a simple extension is actually quite straighforward.\nIn this example I’ll create a shortcode extension that allows you to add comments to a Quarto document. The comments can be turned on or off by using an environemnt variable defined in the yaml header.\n\n\nTo initialize a Quarto shortcode extension, use the following command and enter a name for the extension (in this case comment)\nquarto create extension shortcode\nThe following folder structure will be created:\ncomment\n├── _extensions  \n│   └── comment  \n│       ├── _extension.yml  \n│       └── comment.lua  \n├── .gitignore  \n├── .luarc.json  \n├── example.qmd\n└── README.md  \nI use VS Code for coding. When the quarto create command is executed, VS Code opens a new window at the comment folder, ready for development.\n\n\n\nThis Quarto extension allows an author to add comments to a Quarto document. It also adds a parameter to control if comments should included on not when a file is rendered. I’ve found this extension useful when adding instructional comments to a template.\nThe extension contains three shortcodes. One to start a comment block, one to end a comment block and one to add an inline comment.\nThe code concept is pretty simple. For comment blocks, surround the contents in a div with either the cmt class (which can be used to control styling) when the comment variable is set to true, or display: none when the comment variable is set to false. For inline comments surround the contents in a span with the cmt class when the comment variable is set to true.\nThe comment.lua file is shown below.\n-- start a comment block\nfunction comment_start(args, kwargs, meta)\n  cmt = meta['show_comments']\n  if cmt == nil or cmt == false then\n    return pandoc.RawBlock('html', \"&lt;div style = 'display: none;'&gt;\")\n  else\n    return pandoc.RawBlock('html', \"&lt;div class = 'cmt'&gt;\")\n  end\nend\n\n-- end a comment block\nfunction comment_stop()\n  return pandoc.RawBlock('html', \"&lt;/div&gt;\")\nend\n\n-- inline comment\nfunction comment(args, kwargs, meta)\n  txt = pandoc.utils.stringify(args[1])\n  cmt = meta['show_comments']\n  if cmt == true then\n    return pandoc.RawInline('html', \"&lt;span class = 'cmt'&gt;\" .. txt .. \"&lt;/span&gt;\")\n  end \nend\nIn addition to the comment.lua file, an example.qmd should be written (plus, in this case, a style.css css file). If the example.qmd file is previewed then it will automatically update as you edit comment.lua - a great way to ensure that your extension is working as expected. The example.qmd and style.css files for the comment extension are shown below:\n\n\n---\ntitle: \"Comment Example\"\nformat:\n  html:\n    css: style.css\nshow_comments: true\n---\n\n## Comments Test - Commented text within a paragraph\n\nThis is some uncommented text.\n{{&lt; comment_start &gt;}}\nHere is a &lt;b&gt;comment&lt;/b&gt; containing some instructional information.\n{{&lt; comment_stop &gt;}}\nFinally, some additional uncommented text.\n\n## Comments Test - Inline commenting\n\nThis comment is an inline comment {{&lt; comment \"It can include instruction within the text\" &gt;}} followed by addititional text.\n\n\n\n.cmt {\n  color: #AAAA00\n}\nTo run in interactive / preview mode simple execute the command:\nquarto preview example.qmd\n\n\n\n\nThe example.qmd file contains some example Quarto to test the extension along with a header. The header applies styles in the style.css file (the .cmt class) and also defines a boolean parameter called show_comments. The comment.lua file contains three functions, each evaluating to a shortcode in Quarto. They are each explored below.\n\n\nThis shortcode starts a comment block. It takes three arguments, args, kwargs and meta (arguments, named arguments and document/project-level metadata). In this function we only use the document/project-level metadata and run the command cmt = meta['show_comments'] to create a variable, cmt holding the metadata show_comments, a boolean. Generally, arguments passed to lua will be a list of pandoc inlines and require pandoc.utils.stringify() to convert to strings. In our case, we are only passing a single value in show_comments and it will be a boolean.\nIf the cmt variable is false or missing then a div block is started with display: none to hide it. If the cmt variable is true then a div block is started with the .cmt style.\n\n\n\nThis simply closes the div initiated by comment_start().\n\n\n\nThis shortcode adds a comment inline. It works slightly differently to comment_start() by reading the first argument from the shortcode using txt = pandoc.utils.stringify(args[1]). It then defines the cmt variable as in comment_start() and, if cmt is true, outputs the commented text, returning nothing if cmt is not true.\n\n\n\n\nIn this example, I’ve included show_comments as a document-level parameter. It could be substituted at the project-level in _quarto.yml to manage a set of documents / website. It can also be included in _variables.yml as a project-level variable in which case the line cmt = meta['show_comments'] would be replaced by cmt = meta['_quarto-vars']['show_comments'] in order to access variables defined in the _variables.yml file.\n\n\n\nFinally, a licence file was added (MIT licence), README was edited and the extension was pushed to GitHub at https://github.com/harveyl888/comment. To install to a quarto project simply run:\nquarto add harveyl888/comment"
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html#initialization",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html#initialization",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "To initialize a Quarto shortcode extension, use the following command and enter a name for the extension (in this case comment)\nquarto create extension shortcode\nThe following folder structure will be created:\ncomment\n├── _extensions  \n│   └── comment  \n│       ├── _extension.yml  \n│       └── comment.lua  \n├── .gitignore  \n├── .luarc.json  \n├── example.qmd\n└── README.md  \nI use VS Code for coding. When the quarto create command is executed, VS Code opens a new window at the comment folder, ready for development."
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html#building-the-shortcode-extension",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html#building-the-shortcode-extension",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "This Quarto extension allows an author to add comments to a Quarto document. It also adds a parameter to control if comments should included on not when a file is rendered. I’ve found this extension useful when adding instructional comments to a template.\nThe extension contains three shortcodes. One to start a comment block, one to end a comment block and one to add an inline comment.\nThe code concept is pretty simple. For comment blocks, surround the contents in a div with either the cmt class (which can be used to control styling) when the comment variable is set to true, or display: none when the comment variable is set to false. For inline comments surround the contents in a span with the cmt class when the comment variable is set to true.\nThe comment.lua file is shown below.\n-- start a comment block\nfunction comment_start(args, kwargs, meta)\n  cmt = meta['show_comments']\n  if cmt == nil or cmt == false then\n    return pandoc.RawBlock('html', \"&lt;div style = 'display: none;'&gt;\")\n  else\n    return pandoc.RawBlock('html', \"&lt;div class = 'cmt'&gt;\")\n  end\nend\n\n-- end a comment block\nfunction comment_stop()\n  return pandoc.RawBlock('html', \"&lt;/div&gt;\")\nend\n\n-- inline comment\nfunction comment(args, kwargs, meta)\n  txt = pandoc.utils.stringify(args[1])\n  cmt = meta['show_comments']\n  if cmt == true then\n    return pandoc.RawInline('html', \"&lt;span class = 'cmt'&gt;\" .. txt .. \"&lt;/span&gt;\")\n  end \nend\nIn addition to the comment.lua file, an example.qmd should be written (plus, in this case, a style.css css file). If the example.qmd file is previewed then it will automatically update as you edit comment.lua - a great way to ensure that your extension is working as expected. The example.qmd and style.css files for the comment extension are shown below:\n\n\n---\ntitle: \"Comment Example\"\nformat:\n  html:\n    css: style.css\nshow_comments: true\n---\n\n## Comments Test - Commented text within a paragraph\n\nThis is some uncommented text.\n{{&lt; comment_start &gt;}}\nHere is a &lt;b&gt;comment&lt;/b&gt; containing some instructional information.\n{{&lt; comment_stop &gt;}}\nFinally, some additional uncommented text.\n\n## Comments Test - Inline commenting\n\nThis comment is an inline comment {{&lt; comment \"It can include instruction within the text\" &gt;}} followed by addititional text.\n\n\n\n.cmt {\n  color: #AAAA00\n}\nTo run in interactive / preview mode simple execute the command:\nquarto preview example.qmd"
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html#exploring-the-files",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html#exploring-the-files",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "The example.qmd file contains some example Quarto to test the extension along with a header. The header applies styles in the style.css file (the .cmt class) and also defines a boolean parameter called show_comments. The comment.lua file contains three functions, each evaluating to a shortcode in Quarto. They are each explored below.\n\n\nThis shortcode starts a comment block. It takes three arguments, args, kwargs and meta (arguments, named arguments and document/project-level metadata). In this function we only use the document/project-level metadata and run the command cmt = meta['show_comments'] to create a variable, cmt holding the metadata show_comments, a boolean. Generally, arguments passed to lua will be a list of pandoc inlines and require pandoc.utils.stringify() to convert to strings. In our case, we are only passing a single value in show_comments and it will be a boolean.\nIf the cmt variable is false or missing then a div block is started with display: none to hide it. If the cmt variable is true then a div block is started with the .cmt style.\n\n\n\nThis simply closes the div initiated by comment_start().\n\n\n\nThis shortcode adds a comment inline. It works slightly differently to comment_start() by reading the first argument from the shortcode using txt = pandoc.utils.stringify(args[1]). It then defines the cmt variable as in comment_start() and, if cmt is true, outputs the commented text, returning nothing if cmt is not true."
>>>>>>> origin/HEAD
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html#extending",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html#extending",
    "title": "Building a Quarto Extension",
    "section": "",
    "text": "In this example, I’ve included show_comments as a document-level parameter. It could be substituted at the project-level in _quarto.yml to manage a set of documents / website. It can also be included in _variables.yml as a project-level variable in which case the line cmt = meta['show_comments'] would be replaced by cmt = meta['_quarto-vars']['show_comments'] in order to access variables defined in the _variables.yml file."
  },
  {
    "objectID": "posts/2023/2023-11-20-quarto_extension/index.html#final-steps",
    "href": "posts/2023/2023-11-20-quarto_extension/index.html#final-steps",
    "title": "Building a Quarto Extension",
    "section": "",
<<<<<<< HEAD
    "text": "Quarto is a powerful web publishing system based on Pandoc. Working with jupyter kernels expands the number of languages that Quarto can work with. In this example we’ll add SAS capability to Quarto."
  },
  {
    "objectID": "posts/2022/2022-06-27-quarto_sas_01/index.html#setup",
    "href": "posts/2022/2022-06-27-quarto_sas_01/index.html#setup",
    "title": "Running SAS in Quarto. Part 1",
    "section": "Setup",
    "text": "Setup\nFirst install the saspy and the SAS kernel packages.\npip install saspy\npip install sas_kernel\nOnce installed the sas kernel should be listed when running jupyter kernelspec list:\nsas      ...\npython3  ..."
  },
  {
    "objectID": "posts/2022/2022-06-27-quarto_sas_01/index.html#configure-saspy",
    "href": "posts/2022/2022-06-27-quarto_sas_01/index.html#configure-saspy",
    "title": "Running SAS in Quarto. Part 1",
    "section": "Configure saspy",
    "text": "Configure saspy\nBefore the kernel can be used, two configuration files need to be created: - sascfg_personal.py contains details on how to connect to a SAS instance - _authinfo contains authentication details\nDetails on the configuration files are available at https://sassoftware.github.io/saspy/configuration.html.\nI’m using SAS on demand and additional information on editing these two files is available at https://support.sas.com/ondemand/saspy.html.\n\nsascfg_personal.py\nBelow is an example of a sascfg_personal.py (for a PC configuration). Here we are specifying the connection to the SAS On Demand for Academics (oda) service, US Home Region 2. The sasacfg_personal.py can be placed in the .config/saspy/ subfolder under the home folder.\n\nSAS_config_names=['oda']\noda = {'java' : 'C:\\\\Program Files (x86)\\\\Common Files\\\\Oracle\\\\Java\\\\javapath\\\\java.exe',\n#US Home Region 1\n#'iomhost' : ['odaws01-usw2.oda.sas.com','odaws02-usw2.oda.sas.com','odaws03-usw2.oda.sas.com','odaws04-usw2.oda.sas.com'],\n#US Home Region 2\n'iomhost' : ['odaws01-usw2-2.oda.sas.com','odaws02-usw2-2.oda.sas.com'],\n#European Home Region 1\n#'iomhost' : ['odaws01-euw1.oda.sas.com','odaws02-euw1.oda.sas.com'],\n#Asia Pacific Home Region 1\n#'iomhost' : ['odaws01-apse1.oda.sas.com','odaws02-apse1.oda.sas.com'],\n#Asia Pacific Home Region 2\n#'iomhost' : ['odaws01-apse1-2.oda.sas.com','odaws02-apse1-2.oda.sas.com'],\n'iomport' : 8591,\n'authkey' : 'oda',\n'encoding' : 'utf-8'\n}\n\n\n_authinfo\nThe _authinfo file is located in the home folder and, for SAS On Demand for Academics, looks like this:\noda user &lt;username&gt; password &lt;password&gt;\nwhere  and  are the credentials to connect to oda.\n\n\ntesting SAS in Quarto\nNow that the SAS kernel has been installed and configured, we should be able to execute SAS code in a Quarto document by specifying the kernel in the yaml:\n---\ntitle: \"Quarto Demo with SAS\"\nformat: html\njupyter: sas\nself-contained: true\n---\n\n### Jupyter SAS kernel\n\n```{sas}\nproc candisc data=sashelp.iris out=outcan distance anova;\n   class Species;\n   var SepalLength SepalWidth PetalLength PetalWidth;\nrun;\n```"
  },
  {
    "objectID": "posts/2022/2022-01-05-hot_reload/index.html",
    "href": "posts/2022/2022-01-05-hot_reload/index.html",
    "title": "Shiny hot reload",
=======
    "text": "Finally, a licence file was added (MIT licence), README was edited and the extension was pushed to GitHub at https://github.com/harveyl888/comment. To install to a quarto project simply run:\nquarto add harveyl888/comment"
  },
  {
    "objectID": "posts/2023/2023-10-25-serverless_shiny/index.html",
    "href": "posts/2023/2023-10-25-serverless_shiny/index.html",
    "title": "Serverless shiny app embedded in a Quarto Website",
    "section": "",
    "text": "Inspired by Max Kuhn’s presentation at R/Pharma today I tried out embedding shiny a app within a Quarto website and hosting it on GitHub pages. The app itself is a chemistry quiz built to help my son who had a school test coming up. By running it within a Quarto website it’s available for him to use on the bus on the way to school for some quick revision.\n\n\n\n\n\n\nNote\n\n\n\nThanks so the app he scored 27/30!\n\n\n\n\nTo use shinylive in a Quarto document, you need to first install the shinylive Quarto extension:\nquarto add quarto-ext/shinylive\nalong with the shinylive R package\n\nremotes::install_github(\"posit-dev/r-shinylive\")\n\n\n\n\nThe _quarto.yml file is a project with some basic parameters to define the website. The only additional parameter of note is to include shinylive as a filter.\nproject:\n  type: website\n  output-dir: docs\n  \nformat: \n  html\n  \nwebsite:\n  title: \"shinylive elements quiz\"\n  navbar:\n    left:\n      - index.qmd\n\nfilters:\n  - shinylive\n\n\n\nThe shiny app is in a single chunk of the index.qmd file with a code chunk type of shinylive-r and the standalone option set.\n\n---\ntitle: \"Chem symbol test\"\n---\n\nThis is a simple chemical symbol test.  You'll be tested on chemical elements and their names.\n\n```{r}\n#| include: false\nlibrary(shinylive)\n```\n\n```{shinylive-r}\n#| viewerHeight: 300\n#| standalone: true\n\nchem &lt;- data.frame(\n  symbol = c(\"Al\", \"Sb\", \"Ar\", \"As\", \"Ba\", \"Be\", \"Bi\", \n             \"B\", \"Br\", \"Cd\", \"Ca\", \"C\", \"Cs\", \"Cl\", \"Cr\",\n             \"Co\", \"Cu\", \"F\", \"Au\", \"He\", \"H\", \"I\", \"Fe\",\n             \"Kr\", \"Pb\", \"Li\", \"Mg\", \"Mn\", \"Hg\", \"Ne\", \"Ni\",\n             \"N\", \"O\", \"P\", \"Pt\", \"K\", \"Rn\", \"Se\", \"Si\", \"Ag\",\n             \"Na\", \"Sr\", \"S\", \"Te\", \"Sn\", \"Ti\", \"W\",\n             \"U\", \"V\", \"Xe\", \"Zn\", \"Zr\"),\n  name = c(\"aluminum\", \"antimony\", \"argon\", \"arsenic\", \"barium\", \"beryllium\", \"bismuth\", \n           \"boron\", \"bromine\",\"cadmium\", \"calcium\", \"carbon\", \"cesium\", \"chlorine\", \"chromium\",\n           \"cobalt\", \"copper\", \"fluorine\", \"gold\", \"helium\", \"hydrogen\", \"iodine\", \"iron\",\n           \"krypton\", \"lead\", \"lithium\", \"magnesium\", \"mangenese\", \"mercury\", \"neon\", \"nickel\",\n           \"nitrogen\", \"oxygen\", \"phosphorus\", \"platinum\", \"potassium\", \"radon\", \"selenium\", \"silicon\", \"silver\",\n           \"sodium\", \"strontium\", \"sulfur\", \"tellurium\", \"tin\", \"titanium\", \"tungsten\",\n           \"uranium\", \"vanadium\", \"xenon\", \"zinc\", \"zirconium\")\n)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(5, offset = 1, checkboxGroupInput(\"chk_options\", \"Test me on\", choices = names(chem), selected = \"symbol\", inline = TRUE))\n  ),\n  fluidRow(\n    column(5, offset = 1, uiOutput(\"ui_question\")),\n    column(5, \n           fluidRow(uiOutput(\"ui_score\")),\n           fluidRow(uiOutput(\"ui_streak\"))\n           )\n  )\n  \n)\n\nserver &lt;- function(input, output, session) {\n\n  last_num &lt;- 0\n  rv &lt;- reactiveValues(\n    question_count = 0,\n    score = 0,\n    question_type = NULL,\n    question = NULL,\n    answer = NULL,\n    streak = 0\n  )\n  \n  question_index &lt;- reactive({\n    rv$question_count\n    num &lt;- last_num\n    while (num == last_num) {\n      num &lt;- sample(nrow(chem), size = 1)\n    }\n    last_num &lt;- num\n  })\n  \n  output$ui_question &lt;- renderUI({\n    if (length(input$chk_options) &gt; 0) {\n      rv$question_type &lt;- sample(input$chk_options, size = 1)\n      answer_type &lt;- names(chem)[!names(chem) == rv$question_type]\n      rv$question &lt;- chem[[rv$question_type]][question_index()]\n      rv$answer &lt;- chem[[answer_type]][question_index()]\n      tagList(\n        h3(paste(answer_type, \"for:\", rv$question)),\n        textInput(\"txt_answer\", label = NULL),\n        actionButton(\"but_answer\", \"Submit\")\n      )\n    }\n  })\n  \n  observeEvent(input$but_answer, {\n    if (rv$question_type == \"symbol\") {\n      answer &lt;- tolower(input$txt_answer)\n    } else {\n      answer &lt;- input$txt_answer\n    }\n    if (answer == rv$answer) {\n      rv$score &lt;- rv$score + 1\n      rv$streak &lt;- rv$streak + 1\n      showNotification(ui = \"CORRECT!\", type = \"message\")\n    } else {\n      rv$streak &lt;- 0\n      showNotification(ui = paste0(\"WRONG.  Correct answer is \", rv$answer), type = \"error\")\n    }\n    rv$question_count &lt;- rv$question_count + 1\n  })\n  \n  output$ui_score &lt;- renderUI({\n    h3(paste0(\"Score: \", rv$score, \"/\", rv$question_count), style = \"color: #388E3C\")\n  })\n  \n  output$ui_streak &lt;- renderUI({\n    if (rv$streak &gt; 29) {\n      col &lt;- \"#2E7D32\"\n    } else if (rv$streak &gt; 19) {\n      col &lt;- \"#00838F\"\n    } else if (rv$streak &gt; 9) {\n      col &lt;- \"#1E88E5\"\n    } else if (rv$streak &gt; 0) {\n      col &lt;- \"#8E24AA\"\n    } else {\n      col &lt;- \"#E53935\"\n    }\n    h3(paste0(\"Streak: \", rv$streak), style = paste0(\"color: \", col))\n  })\n\n}\n\napp &lt;- shinyApp(ui = ui, server = server)\n\n```\n\nThe app itself contains the typical ui and server along with the shinyapp() function to execute. It is basic and unoptimized (but it demonstrates the purpose). It takes very little effort to change a standalone app to an embedded one.\nThe quarto website with embedded app is available at https://harveyl888.github.io/shinylive-test/."
  },
  {
    "objectID": "posts/2023/2023-10-25-serverless_shiny/index.html#setup",
    "href": "posts/2023/2023-10-25-serverless_shiny/index.html#setup",
    "title": "Serverless shiny app embedded in a Quarto Website",
>>>>>>> origin/HEAD
    "section": "",
    "text": "To use shinylive in a Quarto document, you need to first install the shinylive Quarto extension:\nquarto add quarto-ext/shinylive\nalong with the shinylive R package\n\nremotes::install_github(\"posit-dev/r-shinylive\")"
  },
  {
<<<<<<< HEAD
    "objectID": "posts/2022/2022-01-01-dynamic_tabs/index.html",
    "href": "posts/2022/2022-01-01-dynamic_tabs/index.html",
    "title": "Shiny dynamic tabs",
    "section": "",
    "text": "This is a simple shiny app that demonstrates dynamic shiny tabs. Each tab contains a shiny module which returns a series of data parameters and tabs can be added and removed. In one use-case this construct was used in three higher level tabs, returning a complex, nested structure.\nCode is available at: https://github.com/harveyl888/shiny_dynamic_tabs\nThe concept is fairly simple - upon start up a tabsetPanel is built with a button prepended before the first tab. When clicked, this button adds a new tab containing a shiny module (the tab also contains a close button). The shiny module returns a series of data and these data, from all tabs, are stored in a reaciveValues list (rv$return_data). As tabs are added, deleted or their content changed, the contents of rv$return_data updates."
  },
  {
    "objectID": "posts/2022/2022-01-01-dynamic_tabs/index.html#screen-captures",
    "href": "posts/2022/2022-01-01-dynamic_tabs/index.html#screen-captures",
    "title": "Shiny dynamic tabs",
    "section": "Screen Captures",
    "text": "Screen Captures\nUpon start up, the tabPanel is built with a button and a single tab. Data returned is printed to the right of the tabPanel.\n\nAdding additional tabs and changing their content updates the returned data.\n\nRemoving tab #2 updates the returned data."
  },
  {
    "objectID": "posts/2022/2022-05-12-knit_child_quarto/index.html",
    "href": "posts/2022/2022-05-12-knit_child_quarto/index.html",
    "title": "knitr::knit_child with Quarto",
    "section": "",
    "text": "Quarto is the new publishing system from RStudio based on Pandoc. It’s a powerful tool for publising from R, Python and Julia, working in a very similar fashion to RMarkdown.\nThere are several great blog posts already highlighting features of Quarto and thoughts on changing from RMarkdown to Quarto.\nRecently, I’ve been building up dynamic documents using child documents. The aim is to identify the parts of a document (report) required and compile them into a main report as child documents. I’ve also started to use Quarto, but can Quarto build a document from a selection of child docs? The answer is ‘yes’."
  },
  {
    "objectID": "posts/2022/2022-05-12-knit_child_quarto/index.html#rmarkdown-version",
    "href": "posts/2022/2022-05-12-knit_child_quarto/index.html#rmarkdown-version",
    "title": "knitr::knit_child with Quarto",
    "section": "RMarkdown Version",
    "text": "RMarkdown Version\nknitr Child documents are a great way to manage long reports. They provide a method to break a document into sections and knit the sections together upon rendering. Below we have a main Rmd document and a child Rmd document. When rendered, the child document is incorporated into the main document.\n\nMain Document\n\n---\ntitle: \"Child docs (RMarkdown)\"\noutput: html_document\n---\n\nTest quarto document using child docs - RMarkdown verion\n\n```{r, include=FALSE}\nlibrary(knitr)\n```\n\n```{r, results='asis', echo=FALSE}\na &lt;- knitr::knit_child('child_doc_01.Rmd', quiet=T)\ncat(a, sep='\\n')\n```\n\n\n\nChild Document 1 (child_doc_01.Rmd)\n\n---\ntag: \"my child 01\"\ntitle: \"child doc 01\"\n---\n\n## Child Doc 1\n\nChild document #1 - this is an RMarkdown child document\n\n\n\nOutput"
  },
  {
    "objectID": "posts/2022/2022-05-12-knit_child_quarto/index.html#quarto-version",
    "href": "posts/2022/2022-05-12-knit_child_quarto/index.html#quarto-version",
    "title": "knitr::knit_child with Quarto",
    "section": "Quarto Version",
    "text": "Quarto Version\nQuarto child documents can be knitted in the same way as RMarkdown documents, using knitr::knit_child. In fact Quarto and RMarkdown child documents can be mixed as shown below.\n\nMain Document\n\n---\ntitle: \"Child docs\"\nformat: html\nexecute: \n  echo: false\nself-contained: true\n---\n\nQuarto child documents are compatible with knitr::knit_child\n\n```{r}\n#| include: false\nlibrary(knitr)\n```\n\n```{r, results='asis'}\na &lt;- knitr::knit_child('child_doc_01.Rmd', quiet=T)\ncat(a, sep=\"\\n\")\n```\n\n```{r, results='asis'}\na &lt;- knitr::knit_child('child_doc_02.qmd', quiet=T)\ncat(a, sep=\"\\n\")\n```\n\n\n\nChild Document 2 (child_doc_02.qmd)\n\n---\ntitle: \"Untitled\"\nformat: html\n---\n\n## Child Doc 2\n\nChild document #2 - this is a quarto child document running {ojs} cell\n\n```{r}\nojs_define(data = mtcars)\n```\n\n```{ojs}\nPlot.plot({\n  marks: [\n    Plot.dot(transpose(data), \n      {x: \"mpg\", y: \"hp\", stroke: \"cyl\"}\n    )\n  ]}\n)\n```\n\n\n\nOutput"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html",
    "href": "posts/2022/2022-01-11-distill_comments/index.html",
    "title": "{distill} Comments",
    "section": "",
    "text": "Following on from a post on including a contact form on a {distill} site hosted on RStudio Connect, here’s a post on how to include comments in blog posts.\nCommenting consists of two parts - a way to retrieve comments that belong to a page and a form to enter new comments.\nIn this implementation I connect a {distill} blog to a {pins} data frame via a {plumber} API. The pinned data frame holds the comments and comments can be added or retrieved through the API. The distill blog posts call javascript functions to post and retrieve comments. The blog, pin board and plumber API all sit on the same RStudio Connect instance."
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#new-comment-form",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#new-comment-form",
    "title": "{distill} Comments",
    "section": "New Comment Form",
    "text": "New Comment Form\nThe function comment_form takes site_id and page_id arguments and returns an HTML form. site_id is a unique identifier for a website and page_id is a unique identifier for a page on that site.\nThe form captures a comment and optional user name and passes each of these, along with site_id and page_id to a plumber API. The plumber API updates a pinned data frame with the new comment. In fact, a javascript function intercepts the submit button triggering an update of the page comments after adding the new one. This allows a new comment to be added without having to refresh the page manually.\nIn addition, the comment_form function adds a div with the id rtncomments which is a placeholder to display comments.\nThe comment_form R function along with the javascript eventListener are shown below. In the code, /addcomment refers to the plumber API endpoint for adding a new comment.\n\nlibrary(htmltools)\n\ncomment_form &lt;- function(page_id = 0, site_id = 0) {\n  \n  comment_html &lt;- paste0('\n  &lt;div class=\"comments\"&gt;\n    &lt;div class=\"form-container\"&gt;\n      &lt;h3 class=\"comment-header\"&gt;Post a Comment&lt;/h3&gt;\n      &lt;form action=\"&lt;rsconnect URL&gt;/addcomment\" id=\"my-form\"&gt;\n      \n        &lt;div class=\"form-contents\"&gt;\n          &lt;span class=\"comment-pic\"&gt;\n            &lt;i class=\"far fa-user\"&gt;&lt;/i&gt;\n          &lt;/span&gt;\n          \n          &lt;div class=\"form-details\"&gt;\n            &lt;div class=\"comment-comments\"&gt;\n              &lt;input type=\"text\" id=\"comment\" name=\"comment\" placeholder=\"Your comment\"&gt;&lt;/textarea&gt;\n            &lt;/div&gt;\n            &lt;div class=\"comment-user\"&gt;\n              &lt;span class=\"comment-short\"&gt;\n                &lt;input type=\"text\" id=\"user_name\" name=\"user_name\" placeholder=\"Your name (optional)\" /&gt;\n              &lt;/span&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n\n          &lt;input type=\"hidden\" name=\"site_id\" value=\"', site_id, '\" /&gt;\n          &lt;input type=\"hidden\" name=\"page_id\" value=\"', page_id, '\" /&gt;\n      \n          &lt;span class=\"button-container\"&gt;\n            &lt;input type=\"submit\" value=\"Comment\"&gt;\n          &lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n      &lt;div id=\"rtncomments\"&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  ')\n  htmltools::HTML(comment_html)\n}\n\n\nwindow.addEventListener(\"load\", function() {\n  \n  document.getElementById(\"my-form\").addEventListener(\"submit\", formsubmit);\n  \n  async function formsubmit(e) {\n    \n    e.preventDefault();\n    \n    // get event-handler element\n    const form = e.currentTarget;\n    \n    // get form url\n    const url = form.action;\n    \n    // get form data as json string\n    formdata = new FormData(form);\n    const plainFormData = Object.fromEntries(formdata.entries());\n    const jsonFormData = JSON.stringify(plainFormData);\n    \n    // send request and capture output\n    out = await fetch(form.action, {\n      method: 'POST',\n      body: jsonFormData,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n      }\n    })\n    .then(response =&gt; response.json());\n    \n    // update comments\n    update_comments(plainFormData.page_id, plainFormData.site_id);\n\n  };\n\n});"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#existing-comments",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#existing-comments",
    "title": "{distill} Comments",
    "section": "Existing Comments",
    "text": "Existing Comments\nTo retrieve existing comments we use a javascript function to build an HTML output. The function takes site_id and page_id arguments and calls a plumber API which returns comments belonging to the page in json form.\nHere, /page_comments refers to the plumber API endpoint for retrieving comments. The search parameters site_id and page_id are appended to the url so that we can limit the returning data to a specific page on a specific site. Since we are using fetch, the webpage and API must live on the same RStudio Connect instance.\nOnce the json-formatted response is returned, the function loops through the comments building an HTML response and updates #rtncomments. If a comment does not have an author it defaults to anonymous user.\n\nfunction update_comments(page_id, site_id) {\n\n  const url = \"&lt;rsconnect URL&gt;/page_comments?\"\n\n  fetch(url + new URLSearchParams({\n    site: site_id, \n    page: page_id,\n  }))\n  .then(response =&gt; response.json())  \n  .then(data =&gt; {\n    \n    // outer_div - placeholder for comments\n    div_outer = $('&lt;div/&gt;').attr('id', 'div_outer');\n    \n    // add comments count\n    div_outer.append('&lt;h3&gt;' + data.length + ' Comments&lt;/h3&gt;');\n\n    // loop through returned comments, adding each one to an unordered list\n    ul_list_comments = $('&lt;ul/&gt;', {id: 'list_comments', class: 'comment-list'});\n\n    $.each(data, function(i, obj) {\n      \n      user_name = obj.user_name == \"null\" ? \"anonymous user\" : obj.user_name\n\n      ul_list_comments.append(\n        $('&lt;li/&gt;', {class: 'comment-item'}).append([\n          $('&lt;div/&gt;', {class: 'comment-top'}).append([\n            $('&lt;h3/&gt;', {class: 'comment-name', text: user_name}),\n            $('&lt;span/&gt;', {class: 'date-holder'}).append([\n              $('&lt;i/&gt;', {class: 'far fa-clock'}),\n              $('&lt;h3/&gt;', {class: 'comment-date', text: obj.date})\n            ])\n          ]),\n          $('&lt;p/&gt;', {class: 'comment-text', text: obj.comment})\n        ])\n      );\n    });\n\n    div_outer.append(ul_list_comments);\n\n    $(\"#rtncomments\").html(div_outer);\n\n  })\n  .catch((err) =&gt; console.log(\"Can’t access \" + url + \" response. Blocked by browser?\" + err));\n  \n};"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#plumber-api",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#plumber-api",
    "title": "{distill} Comments",
    "section": "plumber API",
    "text": "plumber API\nThe {distill} blog pages are connected to the comments via a plumber API. The API contains two endpoints, a POST endpoint, addcomment which is used to add a new comment and a GET endpoint, page_comments which is used to retrieve comments for a specific page. The comments themselves are stored in a data frame which is accessible via the {pins} package. This allows mutiple sites to use the same data frame.\nIn the code below, board_register(\"rsconnect\", server = \"&lt;rsconnect URL&gt;, account = \"&lt;account id&gt;\", key = connectAPIKey) registers a pin board which holds a pin called blog_comment_table. Once again,  refers to the RStudio Connect URL and,  is the account associated with the pin. An RStudio Connect API key must be defined and exposed as an environment variable (see below).\n\nblog_comment_table is a data frame with columns for site_id, page_id, user_id, date and comment. The date is a timestamp set when the comment is added.\n\nlibrary(plumber)\nlibrary(jsonlite)\nlibrary(pins)\nlibrary(tibble)\nlibrary(lubridate)\nlibrary(dplyr)\n\n#* @apiTitle Comments\n\n#* Add a comment to the table\n#* @param req request body\n#* @post /addcomment\nfunction(req) {\n  \n  ## get the message body\n body &lt;- jsonlite::fromJSON(req$postBody)\n\n  ## RSConnect API Key\n  connectAPIKey &lt;- Sys.getenv(\"CONNECT_API_KEY\")\n\n  ## register rsconnect pin board\n  board_register(\"rsconnect\",\n                 server = \"&lt;rsconnect URL&gt;,\n                 account = \"&lt;account id&gt;\",\n                 key = connectAPIKey)\n\n  ## check for comments table and create if not present\n  if (nrow(pins::pin_find(\"blog_comment_table\", board = \"rsconnect\")) == 0) {\n    comments &lt;- tibble(\n      site_id = body$site_id,\n      page_id = body$page_id,\n      user_id = body$user_id,\n      date = lubridate::now(),\n      comment = body$comment\n    )\n  } else {\n    comments &lt;- pins::pin_get(name = \"blog_comment_table\", board = \"rsconnect\") %&gt;%\n      add_row(\n        site_id = body$site_id,\n        page_id = body$page_id,\n        user_id = body$user_id,\n        date = lubridate::now(),\n        comment = body$comment\n      )\n  }\n  pins::pin(comments, name = \"blog_comment_table\", board = \"rsconnect\")\n  \n}\n\n#* Retrieve all comments for a page\n#* @param site site id\n#* @param page page id\n#* @serializer unboxedJSON\n#* @get /page_comments\nfunction(site = 0, page = 0) {\n  \n  ## RSConnect API Key\n  connectAPIKey &lt;- Sys.getenv(\"CONNECT_API_KEY\")\n  \n  ## register rsconnect pin board\n  board_register(\"rsconnect\", \n                 server = \"&lt;rsconnect URL&gt;,\n                 account = \"&lt;account id&gt;\",\n                 key = connectAPIKey)\n  \n  ## get table and filter\n  pins::pin_get(name = \"blog_comment_table\", board = \"rsconnect\") %&gt;%\n    dplyr::filter(site_id == site & page_id == page) %&gt;%\n    dplyr::arrange(desc(date))\n  \n}"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#webpage-blog-post-with-comments",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#webpage-blog-post-with-comments",
    "title": "{distill} Comments",
    "section": "Webpage / Blog Post with Comments",
    "text": "Webpage / Blog Post with Comments\nAny page with comments follows the same approach. The page includes the javascript functions listed above (comments.js), some css styling (style.css, see below) and the comment_form function (sourced from comment.R).\nThere are a few things to note in the code below.\n\nThe two variables, site_id and page_id, are needed to identify comments for the webpage. Ideally, we’d define them in the yaml header and use them as parameters in the markdown text. Unfortunately, when using render_site, markdown parameters are not rendered (see open GitHub issue). site_id and page_id are therefore defined within a chunk.\nThe javascript function update_comments does not sit in a javascript chunk (you can include javascript in rmarkdown by including a chunk with js instead of r in the chunk header). Instead, the code is placed directly within a &lt;script&gt; tag. When processed this way, we can access variables (site_id and page_id) stored in r language chunks earlier in the document.\n\n\n    ---\n    title: \"test article number 1\"\n    description: |\n      A first test article with comments.\n    author:\n      - name: Harvey Lieberman\n    date: 01-10-2022\n    output:\n      distill::distill_article:\n        self_contained: false\n    ---\n\n    ```{r setup, include=FALSE}\n    knitr::opts_chunk$set(echo = FALSE)\n    ```\n\n    ```{r}\n    page_id &lt;- 1\n    site_id &lt;- 101\n    source(here::here(\"comment.R\"))\n    htmltools::includeCSS(here::here(\"style.css\"))\n    htmltools::includeScript(here::here(\"comments.js\"))\n    ```\n\n    This is a first blog post with comments.\n\n    ```{r}\n    comment_form(page_id = page_id, site_id = site_id)\n    ```\n\n    &lt;script&gt;\n    update_comments(page_id = `r page_id`, site_id = `r site_id`)\n    &lt;/script&gt;"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#css",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#css",
    "title": "{distill} Comments",
    "section": "css",
    "text": "css\nThe style.css file takes care of styling comments. The file is included below.\n.comments {\n  padding: 20px 10px;\n  margin: 0;\n}\n\n.form-contents {\n    padding: 10px;\n    margin: 10px;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\n.form-details {\n    display: flex;\n    flex-direction: column;\n    flex: 2 1 auto;\n}\n\n.form-details input[type=text] {\n    border-top: 0px;\n    border-bottom: 1px solid #ccc;\n    border-left: 0px;\n    border-right: 0px;\n    outline: 0px;\n    padding: 0;\n    margin-top: 20px;\n    margin-left: 20px;\n    font-weight: normal;\n}\n\n.form-details input[type=text]:focus {\n    border-color: #04AA6D;\n    border-width: 2px;\n}\n\n.form-contents .comment-pic {\n    display: flex;\n    font-size: 3em;\n    align-self: flex-end;\n}\n\n.button-container {\n    display: flex;\n    align-self: flex-end;\n}\n\n.comment-comments input[type=text]{\n    width: 90%;\n}\n\n.comment-short {\n    width: 50%;\n}\n\n.comment-short input[type=text]{\n    width: 80%;\n}\n\n.comment-user {\n    display: flex;\n    flex-direction: row;\n}\n\n.form-container input[type=submit] {\n  background-color: #04AA6D;\n  color: white;\n  padding: 12px 20px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n.button-container input[type=submit] {\n  margin: 2px 5px;\n  float: right;\n}\n\n.form-container input[type=submit]:hover {\n  background-color: #45a049;\n}\n\n.comment-header {\n  font-size: 1.5em;\n  line-height: 1.5em;\n  font-weight: 400;\n}\n\n.comment-holder {\n  margin-top: 50px;\n}\n\nul.comment-list {\n  list-style: none;\n  position: relative;\n  padding: 0;\n}\n\nli.comment-item {\n  padding: 20px 10px;\n  margin: 20px 0;\n  position: relative;\n  width: 100%;\n  background-color: #efefef;\n}\n\n.comment-top {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n}\n\n.comment-name {\n  font-size: 1.5em;\n  font-weight: 400;\n  margin: 5px 0;\n  color: #5d5d5d;\n  align-self: flex-start;\n}\n\n.date-holder {\n  color: #5d5d5d;\n  align-self: flex-end;\n  display: inline-flex;\n  align-items: baseline;\n}\n\n.comment-date {\n  font-size: 1em;\n  font-weight: 400;\n  margin: 5px 0 5px 10px;\n}\n\n.comment-text {\n  display: block;\n  margin: 0 0 10px 0;\n}"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#output",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#output",
    "title": "{distill} Comments",
    "section": "Output",
    "text": "Output\nAfter adding a couple of sample blog posts and a few comments the output is shown below. Here, I’ve added two comments to the first blog post and one to the second. The data frame retrieved from {pins} appears as follows:\n\n\n\n\n\n\n\n\n\n\nsite_id\npage_id\nuser_name\ndate\ncomment\n\n\n\n\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;dttm&gt;\n&lt;chr&gt;\n\n\n101\n1\nHarvey\n2022-01-10 22:24:00\nThis is my first blog comment!\n\n\n101\n1\nHarvey\n2022-01-10 22:24:34\nBlog comments can take a little time to appear once entered - possibly an artefact of RStudio Connect or {pins}\n\n\n101\n2\nHarvey\n2022-01-10 22:25:17\nHere’s a comment for blog entry #2"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#issues-to-resolve",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#issues-to-resolve",
    "title": "{distill} Comments",
    "section": "Issues to Resolve",
    "text": "Issues to Resolve\nThe refresh process is a little slow, sometimes taking a several seconds to load comments. At this point I’m not sure if it is related to the use of fetch or plumber.\nThis is a first proof-of-concept and certainly requires some more work but the principle works well."
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html",
    "title": "Porting to Quarto",
    "section": "",
    "text": "I’m a big fan of Hugo for building static sites but wanted to port this blog over to Quarto as it’s a framework I’m using more consistently. This post describes some of the extra styling and javascript used to build the blog."
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html#index-page",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html#index-page",
    "title": "Porting to Quarto",
    "section": "Index Page",
    "text": "Index Page\nThe landing page contains a little javascript typewriter effect along with a couple of navigation buttons. The typewriter effect is generated using the Typewriterjs library (https://github.com/tameemsafi/typewriterjs), built as a shortcode extension (see https://github.com/harveyl888/typewriter). The links are simply styled buttons that use Lord icons through the Quarto extension (https://github.com/jmgirard/lordicon)."
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html#lightdark-theme",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html#lightdark-theme",
    "title": "Porting to Quarto",
    "section": "Light/Dark Theme",
    "text": "Light/Dark Theme\nIt’s fairly simple to set a light/dark theme in Quarto and add additional styling. The _quarto.yaml file includes the following lines which specifies an override order. Light and dark themes use a default (flatly, darkly) which is replaced with some general styling in custom.scss. Finally, specific light and dark styles are applied using custom-light.scss and custom-dark.scss.\nformat:\n  html:\n    theme: \n      light: [flatly, custom.scss, custom-light.scss]\n      dark: [darkly, custom.scss, custom-dark.scss]\n\nLight and Dark Swtiching\nBy default, Quarto includes a switch to change from light to dark mode. The switch is, in fact, two icons (switch to the left and switch to the right) from Bootstrap icons. This discussion pointed to the code used to define the light and dark icons, which can be changed by simply copying the svg code from https://icons.getbootstrap.com/. The folllowing has been added to custom.scss to replace the switch with sun and moon icons.\n.navbar .quarto-color-scheme-toggle:not(.alternate) .bi::before { \n  background-image: url('data:image/svg+xml,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"#{colorToRGBA($navbar-light-color)}\" class=\"bi bi-sun\" viewBox=\"0 0 16 16\"&gt;&lt;path d=\"M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6m0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8M8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0m0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13m8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5M3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8m10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0m-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0m9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707M4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708\"/&gt;&lt;/svg&gt;'); \n} \n \n.sidebar-navigation .quarto-color-scheme-toggle:not(.alternate) .bi::before { \n  background-image: url('data:image/svg+xml,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"#{colorToRGBA(theme-dim($body-color, 10%))}\" class=\"bi bi-sun\" viewBox=\"0 0 16 16\"&gt;&lt;path d=\"M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6m0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8M8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0m0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13m8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5M3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8m10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0m-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0m9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707M4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708\"/&gt;&lt;/svg&gt;'); \n} \n \n.navbar .quarto-color-scheme-toggle.alternate .bi::before { \n  background-image: url('data:image/svg+xml,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"#{colorToRGBA($navbar-light-color)}\" class=\"bi bi-moon\" viewBox=\"0 0 16 16\"&gt;&lt;path d=\"M6 .278a.77.77 0 0 1 .08.858 7.2 7.2 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277q.792-.001 1.533-.16a.79.79 0 0 1 .81.316.73.73 0 0 1-.031.893A8.35 8.35 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.75.75 0 0 1 6 .278M4.858 1.311A7.27 7.27 0 0 0 1.025 7.71c0 4.02 3.279 7.276 7.319 7.276a7.32 7.32 0 0 0 5.205-2.162q-.506.063-1.029.063c-4.61 0-8.343-3.714-8.343-8.29 0-1.167.242-2.278.681-3.286\"/&gt;&lt;/svg&gt;'); \n} \n \n.sidebar-navigation .quarto-color-scheme-toggle.alternate .bi::before { \n  background-image: url('data:image/svg+xml,&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"#{colorToRGBA(theme-dim($body-color, 10%))}\" class=\"bi bi-moon\" viewBox=\"0 0 16 16\"&gt;&lt;path d=\"M6 .278a.77.77 0 0 1 .08.858 7.2 7.2 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277q.792-.001 1.533-.16a.79.79 0 0 1 .81.316.73.73 0 0 1-.031.893A8.35 8.35 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.75.75 0 0 1 6 .278M4.858 1.311A7.27 7.27 0 0 0 1.025 7.71c0 4.02 3.279 7.276 7.319 7.276a7.32 7.32 0 0 0 5.205-2.162q-.506.063-1.029.063c-4.61 0-8.343-3.714-8.343-8.29 0-1.167.242-2.278.681-3.286\"/&gt;&lt;/svg&gt;'); \n}"
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html#listing-layout",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html#listing-layout",
    "title": "Porting to Quarto",
    "section": "Listing Layout",
    "text": "Listing Layout\nQuarto has a few listing formats built in but also allows you to create your own by scripting in ejs. Initially I tried to build a cool looking listing for blog entries using ejs but realized that some of the interativity, related to clicking on categories, would require to include additional javascript (copied from the Quarto repo). An alternate approach is to keep a standard listing and style it using scss. This was how this site was built.\n\nListing Page Background Color\nTo set body properties for a single page you can add a &lt;style&gt; tag at the top of the quarto qmd file. For example, to set a body background color to grey you could insert the following code just after the yaml heading:\n&lt;style&gt;\n  body {\n    background-color: #eeeeee;\n  }\n&lt;/style&gt;\nSince we have a dark/light mode, I would like the body background color on the listing page to change with the theme of the site. Our themes are built with scss but the &lt;style&gt; tag takes css. In order to make the body background change according to the theme setting I’ve added a css variable to the top of the scss custom-light.scss and custom-dark.scss files. The variable is added before the first section commment.\ncustom-light.scss starts with:\n:root {\n  --post-page-background: #eeeeee;\n}\ncustom-dark.scss starts with:\n:root {\n  --post-page-background: #444444;\n}\nand posts/index.qmd contains the following code just after the yaml header:\n&lt;style&gt;\n  body {\n    background-color: var(--post-page-background);\n  }\n&lt;/style&gt;\nWhen the posts listing page is built the background color will be set to the css variable --post-page-background which is defined in the light and dark scss files."
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html#blog-categories",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html#blog-categories",
    "title": "Porting to Quarto",
    "section": "Blog Categories",
    "text": "Blog Categories\nBlog categories are listed to the side of the posts. They are styled using scss with a little javascript to remove the parentheses around the counts. Javascript is shown below. The code works by finding and looping over all instances of the quarto-category-count class and removing the first and last character. The document.addEventListener(\"DOMContentLoaded\", function() {}) code waits for the page to load before executing.\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  const counts = document.querySelectorAll('.quarto-category-count');\n  counts.forEach(count =&gt; {\n    let text = count.textContent;\n    if (text.length &gt; 1) {\n      count.textContent = text.slice(1, -1);\n    } else {\n      count.textContent = '';\n    }\n  });\n});  \nThe javascript script file is added to the bottom of each page by adding the following to _quarto.yml:\nformat:\n  html:\n    include-after-body:\n      - text: |\n          &lt;script type=\"text/javascript\" src=\"/_resources/js/scripts.js\"&gt;&lt;/script&gt;"
  },
  {
    "objectID": "posts/2025/2025-01-25-porting_to_quarto/index.html#notes",
    "href": "posts/2025/2025-01-25-porting_to_quarto/index.html#notes",
    "title": "Porting to Quarto",
    "section": "Notes",
    "text": "Notes\nPorting from Hugo to Quarto was simple and I can now execute R and python as blog entries are built. In addition, shinylive will allow shiny to be run from within Quarto pages."
  },
  {
    "objectID": "posts/2025/2025-01-13-gt_extensions/index.html",
    "href": "posts/2025/2025-01-13-gt_extensions/index.html",
    "title": "gt Extensions",
    "section": "",
    "text": "The {gt} package is a great R package for building tables and the outputs that can be generated, particularly in HTML, are stunning. The {gtExtras} pacakge, from Tom Mock, extends the functionality of {gt}. In developing a Quarto report, I found that I needed some tabular outputs that were not present in {gt}. Taking inspiration from {gtExtras}, here’s some code and explanation, on adding additional functions to {gt}."
  },
  {
    "objectID": "posts/2025/2025-01-13-gt_extensions/index.html#introduction",
    "href": "posts/2025/2025-01-13-gt_extensions/index.html#introduction",
    "title": "gt Extensions",
    "section": "",
    "text": "The {gt} package is a great R package for building tables and the outputs that can be generated, particularly in HTML, are stunning. The {gtExtras} pacakge, from Tom Mock, extends the functionality of {gt}. In developing a Quarto report, I found that I needed some tabular outputs that were not present in {gt}. Taking inspiration from {gtExtras}, here’s some code and explanation, on adding additional functions to {gt}."
  },
  {
    "objectID": "posts/2025/2025-01-13-gt_extensions/index.html#tldr",
    "href": "posts/2025/2025-01-13-gt_extensions/index.html#tldr",
    "title": "gt Extensions",
    "section": "TL/DR",
    "text": "TL/DR\nHere’s a quick illustration of the extensions discussed in the blog post.\n\n## table of dates\ndf_dates &lt;- tibble::tibble(\n  name = c(\"Alice\", \"Bob\", \"Carol\", \"Carol\", \"Dan\", \"Alice\", \"Bob\", \"Carol\", \"Carol\", \"Dan\", \"Alice\"),\n  var = c(rep(c(\"start\", \"end\"), each = 5), \"empty\"),\n  date = c(\"2024-10-05\", \"2024-10-13\", \"2024-09-10\", \"2024-11-11\", \"2024-10-01\", \"2025-01-03\", \"2024-12-20\", \"2025-01-04\", \"2024-12-20\", \"2025-01-10\", \"2024-12-05\")\n) |&gt;\n  tidyr::nest(dates = c(var, date))\n\n## table of employee details (inc. dates)\ndf &lt;- tibble::tibble(\n  name = c(\"Alice\", \"Bob\", \"Carol\", \"Dan\"),\n  level = c(\"Director\", \"VP\", \"Director\", \"Assoc Director\"),\n  division = c(\"HR\", \"sales\", \"sales\", \"HR\"),\n    notes = c(\"n/a\", \"n/a\", \"n/a\", \"Dan has been with us for 5 years\"),\n  projects = c(\"project 1;project 2;project 3\", \"project 2\", \"project 1;project 3\", \"project 2;project 3;project 4\"),\n  division_badge = c(\"HR\", \"sales\", \"sales\", \"HR\"),\n  alert = c(TRUE, TRUE, FALSE, FALSE)\n) |&gt;\n  dplyr::left_join(df_dates, by = \"name\")\n\n## create gt table\ndf |&gt;\n  gt::gt() |&gt; \n  gt_subtitle(col_title = name, col_subtitle = level, col_parenthesis = division, col_tootlip = notes) |&gt;\n  gt_dots(projects, items = c(\"project 1\", \"project 2\", \"project 3\", \"project 4\"), sep = \";\", tooltip = TRUE) |&gt;\n  gt_alert(alert) |&gt;\n  gt_badge(division_badge, palette = c(HR = \"#2244CC\", sales = \"#22CC44\")) |&gt;\n  gt_timeline(dates, min_date = \"2024-09-01\", max_date = \"2025-01-13\", palette = c(start = \"#00AA00\", end = \"#AA0000\"))\n\n\n\nHelper FunctionBadgesAlertsDotsSubtitle StackTimeline\n\n\n\n.gtIndex()\nThe gt_index() function is a useful function lifted from the {gtExtras} package. It returns the underlying data of a column and is used extensively in gtExtras functions. Rather than rely on a dependence to {gtExtras} I’ve extracted the function, included here as .gtindex().\n\n#' gtindex taken from gtExtras package\n#'\n.gtindex &lt;- function(gt_object, column, as_vector = TRUE) {\n  stopifnot(\"'gt_object' must be a 'gt_tbl', have you accidentally passed raw data?\" = \"gt_tbl\" %in% class(gt_object))\n  stopifnot(\"'as_vector' must be a TRUE or FALSE\" = is.logical(as_vector))\n\n  if (length(gt_object[[\"_row_groups\"]]) &gt;= 1) {\n    # if the data is grouped you need to identify the group column\n    # and arrange by that column. I convert to a factor so that the\n    # columns don't default to arrange by other defaults\n    #  (ie alphabetical or numerical)\n    gt_row_grps &lt;- gt_object[[\"_row_groups\"]]\n\n    grp_vec_ord &lt;- gt_object[[\"_stub_df\"]] |&gt;\n      dplyr::mutate(group_id = factor(group_id, levels = gt_row_grps)) |&gt;\n      dplyr::arrange(group_id) |&gt;\n      dplyr::pull(rownum_i)\n\n    df_ordered &lt;- gt_object[[\"_data\"]] |&gt;\n      dplyr::slice(grp_vec_ord)\n  } else {\n    # if the data is not grouped, then it will just \"work\"\n    df_ordered &lt;- gt_object[[\"_data\"]]\n  }\n\n  # return as vector or tibble in correct, gt-indexed ordered\n  if (isTRUE(as_vector)) {\n    df_ordered |&gt;\n      dplyr::pull({{ column }})\n  } else {\n    df_ordered\n  }\n}\n\n\n\n\n\ngt_badge\nthis first function simply replaces a column with colored badges. {gtExtras} includes a gt_badge() function itself but\n\nFor some reason it’s missing from the pkgdown site so I did not know it existed.\nI required additional functionality - for example, the ability to work with missing data.\nIt was a good first example to sink my teeth into.\n\nThe function is shown below followed by some explanatory text.\n\n#' Add a badge based on values\n#'\n#' This function differs from gtExtras::gt_badge() in that it accounts for values\n#'     missing in the color palette and missing in the data.  Those missing in the\n#'     color palette are displayed as a white badge with grey border and those missing\n#'     in the data are represented as an empty white badge.\n#'\n#' @param gt_object An existing gt object\n#' @param column The column to convert to dots\n#' @param palette Named vector of values and colors. \n#' \n#' @export\n#'\ngt_badge &lt;- function(gt_object, column, palette = c()) {\n  stopifnot(\"Table must be of class 'gt_tbl'\" = \"gt_tbl\" %in% class(gt_object))\n\n  cell_contents &lt;- .gtindex(gt_object, {{ column }})\n\n  gt::text_transform(\n    gt_object,\n    locations = gt::cells_body(columns = {{ column }}),\n    fn = function(x) {\n      purrr::map(cell_contents, function(y) {\n        if (is.na(y)) {\n          '&lt;span class = \"gtbadge gtbadge-empty\"&gt;none&lt;/span&gt;'\n        } else if (y %in% names(palette)) {\n          glue::glue('&lt;span class = \"gtbadge\" style = \"background-color: {palette[y]};\"&gt;{y}&lt;/span&gt;')\n        } else {\n          glue::glue('&lt;span class = \"gtbadge gtbadge-clear\"&gt;{y}&lt;/span&gt;')\n        }\n      })\n    }\n  ) |&gt;\n    gt::opt_css(\n      css = \"\n        .gtbadge {\n          display: inline-block;\n          color: #ffffff;\n          min-width: 30px;\n          padding: 2px 4px;\n          text-align: center;\n          border-radius: 7px;\n          font-size: .8em;\n        }\n        .gtbadge-empty {\n          background-color: #ffffff;\n          border: 1px solid #dddddd;\n        }\n        .gtbadge-clear {\n          background-color: #ffffff;\n          color: #999999;\n          border: 1px solid #dddddd;\n        }\n      \"\n    )\n}\n\nFirst we capture the contents of column by using the .gtindex() function:\ncell_contents &lt;- .gtindex(gt_object, {{ column }}) - return the contents of column column as a vector (this function is taken from {gtExtras}).\nNext, gt::text_transform() is used to replace the data in column with new values returned by a function. gt::text_transform() is a powerful function that takes three arguments: a gt table, locations for transformation (in this case a column identifier) and a function that returns a character vector the same length as the column entries. Here, our function iterates over cell_contents, the vector of data in column and returns a badge. Badges are colored according to a palette passed to gt_badge(), accounting for values missing in the palette as well as empty values.\nFinally, the output from gt::text_transform() is formatted by declaring the column as markdown and adding css classes.\n\n\nExample Output\n\ndf &lt;- data.frame(ref = seq(1:5), data = c(\"badge_1\", \"badge_2\", \"badge_1\", NA, \"badge_3\"))\ndf |&gt; gt::gt() |&gt; gt_badge(data, palette = c(badge_1 = \"#990000\", badge_2 = \"#009900\"))\n\n\n\n\n\n\n\nref\ndata\n\n\n\n\n1\nbadge_1\n\n\n2\nbadge_2\n\n\n3\nbadge_1\n\n\n4\nnone\n\n\n5\nbadge_3\n\n\n\n\n\n\n\n\n\n\n\ngt_alert()\nThis is another simple example. Here an icon is returned in a column based on TRUE/FALSE values.\n\n#' Replace a logical column with an alert indicator\n#'\n#' Replace TRUE values with an empty circle and any other values with a red exclamation\n#'     mark in a circle.  Setting `invert`=TRUE reverses this behavior.\n#'\n#' @param gt_object An existing gt object\n#' @param column The column to convert to dots\n#' @param invert If TRUE then invert the response so that TRUE = alert.  Default is FALSE\n#'\n#' @export\n#'\ngt_alert &lt;- function(gt_object, column, invert = FALSE) {\n  stopifnot(\"Table must be of class 'gt_tbl'\" = \"gt_tbl\" %in% class(gt_object))\n\n  cell_contents &lt;- .gtindex(gt_object, {{ column }})\n\n  gt::text_transform(\n    gt_object,\n    locations = gt::cells_body(columns = {{ column }}),\n    fn = function(x) {\n      purrr::map(cell_contents, function(y) {\n        true_val &lt;- isTRUE(y)\n        if (invert == TRUE) {\n          true_val &lt;- !true_val\n        }\n        if (true_val) {\n          fontawesome::fa(\"circle\", fill = \"#cccccc\")\n        } else {\n          fontawesome::fa(\"circle-exclamation\", fill = \"#990000\")\n        }\n      })\n    }\n  ) |&gt;\n    gt::fmt_markdown(columns = {{ column }})\n}\n\n\n\nExample Output\n\ndf &lt;- data.frame(ref = seq(1:5), data = c(TRUE, FALSE, NA, TRUE, FALSE))\ndf |&gt; gt::gt() |&gt; gt_alert(data, invert = TRUE)\n\n\n\n\n\n\n\n\n\n\n\nref\ndata\n\n\n\n\n1\n\n\n\n\n\n2\n\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngt_dots()\nThis function displays a vector of values as colored dots. It’s useful for groups containing multiple categorical values. Column data may be input through a list column, eg list(c(“A”, “B”, “C”)) or character-separated, eg “A,B,C”. gt_dots() also introduces the use of tooltips. Code explanation and an example follow below.\n\n#' Replace a column with a series of colored dot rows\n#'\n#' @param gt_object An existing gt object\n#' @param column The column to convert to dots\n#' @param items Vector of values for dots.  This represents all of the possible dots in\n#'     order\n#' @param sep Optional separation character.  If NULL (default) then it is assumed that\n#'     column `column` is a list column containing vectors where the member of each vector\n#'     can be a value in `items`.  For example, if `items` is c(\"A\", \"B\", \"C\") then `column`\n#'     could contain data such as \"A\" or c(\"A\", \"B\").  If a `sep` is a character then column\n#'     `column` should be a character vector with values separated by `sep`.  For example, if\n#'     `items` is c(\"A\", \"B\", \"C\") and `sep` is \";\" then `column` could contain data such as\n#'     \"A\" or \"A;B\".\n#' @param tooltip If TRUE then add a tooltip indicating the active values\n#'    \n#' @return gt table\n#'\n#' @export\n#'\ngt_dots &lt;- function(gt_object, column, items = c(), sep = NULL, tooltip = FALSE) {\n  stopifnot(\"Table must be of class 'gt_tbl'\" = \"gt_tbl\" %in% class(gt_object))\n  \n  cell_contents &lt;- .gtindex(gt_object, {{ column }})\n  \n  pal &lt;- colorRampPalette(c(\"#89CFF1\", \"#003A6B\"))\n  cols &lt;- pal(length(items))\n  l_dots &lt;- lapply(seq_along(items), function(i) {\n    fontawesome::fa(\"fas fa-circle\", fill = cols[i], margin_left = '.05em', margin_right = '.05em')\n  }) |&gt;\n    setNames(items)\n  blank &lt;- fontawesome::fa(\"far fa-circle\", fill = \"#cccccc\", margin_left = '.05em', margin_right = '.05em')\n  \n  col_name &lt;- rlang::quo_name(rlang::quo({{column}}))\n  width_val &lt;- length(items) * 1.1 + 1\n  colwidth &lt;- as.formula(paste0(col_name, \" ~ '\", width_val, \"em'\"))\n  \n  gt::text_transform(\n    gt_object,\n    locations = gt::cells_body(columns = {{ column }}),\n    fn = function(x) {\n      lapply(cell_contents, function(y) {\n        \n        # split to create a vector\n        if (!is.null(sep)) {\n          y &lt;- unlist(strsplit(y, sep, fixed = TRUE))\n        }\n        \n        # find matches\n        dot_matches &lt;- match(y, items)\n        dots &lt;- rep(blank, times = length(items))\n        if (!is.na(dot_matches[1])) {\n          for (i in dot_matches) {\n            dots[i] &lt;- l_dots[[i]]\n          }\n        }\n        \n        output_dots &lt;- paste(dots, collapse = \"\")\n        \n        if (tooltip == TRUE) {\n          if (!is.na(dot_matches[1])) {\n            tooltip_text &lt;- paste(items[dot_matches], collapse = \", \")\n          } else {\n            tooltip_text &lt;- NA\n          }\n          \n          glue::glue(\n            \"&lt;div data-bs-toggle='tooltip' data-bs-placement='right' data-bs-title=\\\"{tooltip_text}\\\"&gt;{output_dots}&lt;/div&gt;\"\n          )\n          \n        } else {\n          output_dots\n        }\n      })\n    }\n  ) |&gt;\n    gt::fmt_markdown(columns = {{ column }}) |&gt;\n    gt::cols_width(colwidth)\n}\n\nAt the beginning of the function we build a named vector of colors. We’ve hardcoded shades of blue but could easily pass the two color-extremes as parameters to gt_dots(). The output is l_dots, a named list of colored icons, and blank, an empty icon.\n  pal &lt;- colorRampPalette(c(\"#89CFF1\", \"#003A6B\"))\n  cols &lt;- pal(length(items))\n  l_dots &lt;- lapply(seq_along(items), function(i) {\n    fontawesome::fa(\"fas fa-circle\", fill = cols[i], margin_left = '.05em', margin_right = '.05em')\n  }) |&gt;\n    setNames(items)\n  blank &lt;- fontawesome::fa(\"far fa-circle\", fill = \"#cccccc\", margin_left = '.05em', margin_right = '.05em')\nThe next part of the code builds a formula defining the column width. The column width is defined by the number of dots. This keeps all the dots on a single line.\n  col_name &lt;- rlang::quo_name(rlang::quo({{column}}))\n  width_val &lt;- length(items) * 1.1 + 1\n  colwidth &lt;- as.formula(paste0(col_name, \" ~ '\", width_val, \"em'\"))\nFinally we run the gt::text_transform() function, looping over each vector of data. The output is a series of colored dots, corresponding to matches against a vector. If requested, a tootlip is added for each column cell.\n\n\n\n\n\n\nTooltips in Quarto\n\n\n\nNote, to use tooltips in a quarto HTML document, Bootstrap tooltips need to first be activated. This can be done by adding the following in the document’s yaml header:\ninclude-after-body:\n- text: \"&lt;script&gt;\\n  const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle=\\\"tooltip\\\"]')\\n\n    \\ const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl =&gt; new bootstrap.Tooltip(tooltipTriggerEl, {html: true}))\\n&lt;/script&gt;\\n\"\n\n\n\n\nExample Output\n\ndf &lt;- data.frame(ref = seq(1:5), data = c(\"p1,p2\", \"p1\", NA, \"p3\", \"p2,p3\"))\ndf |&gt; gt::gt() |&gt; gt_dots(data, items = c(\"p1\", \"p2\", \"p3\", \"p4\"), sep = \",\", tooltip = TRUE)\n\n\n\n\n\n\n\nref\ndata\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngt_subtitle()\nThis function is very similar to the {gtExtras} function gt_merge_stack(), taking two columns and stacking the text of the first above the second. This adds optional text in parenthesis (useful in the case of a grouping value or tag) and a tooltip. It demonstrates how a relatively simple function may be used to build some creative table columns.\n\n#' Add subtitle and tooltip to column\n#'\n#' This function is similar to gtExtras::gt_merge_stack().  It replaces the `col_title`\n#'     column with a formatted column that stacks `col_title` on top of `col_subtitle`. \n#'     The upper text is converted to small caps and the lower text is smaller and grey. \n#'     If `col_parenthesis` is included, values from an additional column are added to\n#'     the title in parenthesis.  This can be used to include a column grouping or tag.\n#'     If `col_tooltip` is included then values from this column will be used as data for\n#'     tooltips.  Output is returned in column `col_title` with columns `col_subtitle`,\n#'     `col_parenthesis` and `col_tooltip` removed.\n#'\n#' @param gt_object An existing gt object\n#' @param col_title The column holding the title\n#' @param col_subtitle The column holding the subtitle\n#' @param col_parenthesis Optional column holding data to be added in parentheses after\n#'     the title.  Often used to include a grouped column or tag\n#' @param col_tootlip Optional column holding data to be used as tooltip text\n#'\n#' @export\n#'\ngt_subtitle &lt;- function(gt_object, col_title, col_subtitle, col_parenthesis = NULL, col_tootlip = NULL) {\n  stopifnot(\"Table must be of class 'gt_tbl'\" = \"gt_tbl\" %in% class(gt_object))\n\n  col_subtitle_contents &lt;- .gtindex(gt_object, {{ col_subtitle }})\n  col_parenthesis_missing &lt;- rlang::quo_is_null(rlang::enquo(col_parenthesis))\n  col_tootlip_missing &lt;- rlang::quo_is_null(rlang::enquo(col_tootlip))\n\n  if (!col_parenthesis_missing) {\n    col_parenthesis_contents &lt;- .gtindex(gt_object, {{ col_parenthesis }})\n  }\n\n  if (!col_tootlip_missing) {\n    col_tootlip_contents &lt;- .gtindex(gt_object, {{ col_tootlip }})\n  }\n\n  rtn &lt;- gt::text_transform(\n    gt_object,\n    locations = gt::cells_body(columns = {{ col_title }}),\n    fn = function(x) {\n\n      if (!col_parenthesis_missing) {\n        txt &lt;- glue::glue(\"{x} ({col_parenthesis_contents})\")\n      } else {\n        txt &lt;- x\n      }\n      \n      if (!col_tootlip_missing) {\n        glue::glue(\n          \"&lt;div data-bs-toggle='tooltip' data-bs-placement='right' data-bs-title=\\\"{col_tootlip_contents}\\\"&gt;\n             &lt;div class='subtitle-top'&gt;\n               &lt;span&gt;{txt}&lt;/span&gt;\n             &lt;/div&gt;\n             &lt;div class='subtitle-bottom'&gt;\n               &lt;span&gt;{col_subtitle_contents}&lt;/span&gt;\n             &lt;/div&gt;\n           &lt;/div&gt;\"\n        )\n\n      } else {\n\n        glue::glue(\n          \"&lt;div class='subtitle-top'&gt;\n             &lt;span&gt;{txt}&lt;/span&gt;\n           &lt;/div&gt;\n           &lt;div class='subtitle-bottom'&gt;\n             &lt;span&gt;{col_subtitle_contents}&lt;/span&gt;\n           &lt;/div&gt;\"\n        )\n      }\n    }\n  ) |&gt;\n    gt::opt_css(\n      css = \"\n        .subtitle-top {\n          line-height:10px;\n          text-align:left;\n        }\n        .subtitle-top span {\n          font-weight: bold;\n          font-variant: small-caps;\n          font-size: 14px;\n        }\n        .subtitle-bottom {\n          line-height:12px;\n          text-align:left;\n        }\n        .subtitle-bottom span {\n          font-weight: bold;\n          color: grey;\n          font-size: 10px\n        }\n\n      \"\n    )\n\n  rtn &lt;- rtn  |&gt;\n    gt::cols_hide({{col_subtitle}})\n  if (!col_parenthesis_missing) {\n    rtn &lt;- rtn |&gt;\n      gt::cols_hide({{col_parenthesis}})\n  }\n  if (!col_tootlip_missing) {\n    rtn &lt;- rtn |&gt;\n      gt::cols_hide({{col_tootlip}})\n  }\n\n  rtn\n\n}\n\n\n\nExample Output\n\ndf &lt;- data.frame(name = c(\"Name 1\", \"Name 2\"), title = c(\"VP\", \"Chair\"), gp = c(\"AAA\", \"AAA\"), tt = c(\"First Person\", \"Second Person\"))\ndf |&gt; gt::gt() |&gt; gt_subtitle(col_title = name, col_subtitle = title, col_parenthesis = gp, col_tootlip = tt)\n\n\n\n\n\n\n\n\n\n\nname\n\n\n\n\n\n\nName 1 (AAA)\n\n\nVP\n\n\n\n\n\n\nName 2 (AAA)\n\n\nChair\n\n\n\n\n\n\n\n\n\n\n\n\n\ngt_timeline()\nThis function adds a timeline. Dates are plotted as markers along a time axis for each cell in a column. The dates are stored as tibbles for each row. The dates tibbles contain a var column for labels and a date column for dates. Dates can be color-coded by var and also include a hover to highlight var and date characteristics.\n\n#' Create a timeline\n#'\n#' Create a linear date line with markers representing dates.  The input column is\n#'     expected to be a list column of tibbles, each with a `var` column holding labels\n#'     and a `date` column holding dates.\n#'\n#' @param gt_object An existing gt object\n#' @param column The column to convert to a timeline\n#' @param min_date Minimum date (format = yyyy-mm-dd).  If missing then the minimum date\n#'     is determined from the data\n#' @param max_date Maximum date (format = yyyy-mm-dd).  If missing then the maximum date\n#'     is determined from the data\n#' @param palette Named vector of colors (optional).  If included then color named values\n#'     from the `var` column accordingly\n#' @param add_key If TRUE and a palette is included then include a color key as a table\n#'     footnote\n#'\ngt_timeline &lt;- function(gt_object, column, min_date = NULL, max_date = NULL, palette = c(), add_key = FALSE) {\n\n  stopifnot(\"Table must be of class 'gt_tbl'\" = \"gt_tbl\" %in% class(gt_object))\n\n  default_fill &lt;- \"#ADD8E6\"\n  if (length(palette) == 0) {\n    df_cols &lt;- tibble::tibble(var = character(), fill_color = character())\n  } else {\n    df_cols &lt;- tibble::enframe(palette, name = \"var\", value = \"fill_color\")\n  }\n\n  cell_contents &lt;- .gtindex(gt_object, {{ column }})\n\n  if (any(missing(min_date), missing(max_date))) {\n    v_times &lt;- cell_contents |&gt;\n      dplyr::bind_rows() |&gt;\n      dplyr::pull(date)\n    if (missing(min_date)) {\n      min_date &lt;- min(v_times)\n    }\n    if (missing(max_date)) {\n      max_date &lt;- max(v_times)\n    }\n  }\n\n  day_range &lt;- as.numeric(difftime(as.Date(max_date), as.Date(min_date), 'days'))\n  w &lt;- 150  # width\n\n  rtn &lt;- gt::text_transform(\n    gt_object,\n    locations = gt::cells_body(columns = {{ column }}),\n    fn = function(x) {\n\n      lapply(cell_contents, function(d) {\n\n        plt_d &lt;- d |&gt;\n          dplyr::mutate(days = as.numeric(difftime(as.Date(date), as.Date(min_date), 'days'))) |&gt;\n          dplyr::mutate(xval = w * days / day_range) |&gt;\n          dplyr::mutate(textanchor = dplyr::case_when(\n            xval &lt; 0.4 * w ~ \"start\",\n            xval &gt; 0.6 * w ~ \"end\",\n            .default = \"middle\"\n          )) |&gt;\n          dplyr::left_join(df_cols, by = \"var\") |&gt;\n          dplyr::mutate(fill_color = dplyr::if_else(is.na(fill_color), default_fill, fill_color))\n\n        svg_line &lt;- glue::glue('&lt;line x1=\"0\" y1=\"17\" x2=\"{w+10}\" y2=\"17\" style=\"stroke: #808080; stroke-width: 1\" /&gt;')\n\n        svg_pts &lt;- plt_d |&gt;\n          glue::glue_data('\n        &lt;g class = \"gttime\"&gt;\n        &lt;circle class=\"gttimedot\" cx=\"{xval+5}\" cy=\"17\" r=\"5\" stroke=\"#000\" stroke-width=\"1\" fill=\"{fill_color}\" /&gt;\n        &lt;text class=\"gttimelab\" x=\"{xval+5}\" y=\"9\" font-size=\".6em\" text-anchor=\"{textanchor}\"&gt;{var} ({date})&lt;/text&gt;\n        &lt;/g&gt;\n      ') |&gt;\n          glue::glue_collapse(sep = \"\")\n\n        glue::glue('&lt;svg width=\"{w+10}\" height=\"23\" xmlns=http://www.w3.org/2000/svg&gt;{svg_line}{svg_pts}&lt;/svg&gt;')\n        \n      })\n    }\n  ) |&gt;\n    gt::fmt_markdown(columns = {{ column }}) |&gt;\n    gt::opt_css(\n      css = \"\n        .gttime {\n          overflow: visible;\n        }\n        .gttimelab {\n          display: none;\n          overflow: visible;\n        }\n        .gttime:hover {\n           text {display: block;}\n        }\n      \"\n    )\n\n  if (add_key == TRUE & length(palette) &gt; 0) {\n\n    color_key &lt;- lapply(seq_along(palette), function(i) {\n      paste0(\"&lt;span style = 'margin-right: 15px'&gt;&lt;span style = 'margin-right: 5px'&gt;\", bsicons::bs_icon('circle-fill', color = palette[i]), \"&lt;/span&gt;&lt;span&gt;\", names(palette)[i], \"&lt;/span&gt;&lt;/span&gt;\")\n    }) |&gt;\n      paste(collapse = \"\")\n\n    color_key &lt;- paste0(\"&lt;span&gt;&lt;span style = 'margin-right: 20px;'&gt;Key:&lt;/span&gt;\", color_key, \"&lt;/span&gt;\")\n    \n    rtn &lt;- rtn |&gt;\n      gt::tab_footnote(footnote = gt::html(color_key), locations = gt::cells_column_labels({{column}}))\n\n  }\n\n  return(rtn)\n\n}\n\nThe function works by defining a variable day_range which is the number of days for the timeline (max - min). Next, each date is expressed as the fraction along the timeline multiplied by the width of the output. Cells are constructed by building up SVG graphics as follows:\n\nplot the timeline as a horizontal line just below the center of the cell\nfor each time point plot it on the timeline within a group of class gttime\nadd text for each timeline within the same group\n\nThe css added controls the visibility. Labels are initialized with display: none so they will be hidden. On hovering we set display: block so that the label is visible.\nHover labels are positioned so that if they fall in the first 40% of the timeline they are left-justified, if they fall in the last 40% of the timeline they are right-justified and if they fall in the middle 20% they are centered. This helps position labels within the timeline region, avoiding overflow.\n\n\nExample Output\n\ndf &lt;-  data.frame(ref = c(1, 1, 2, 2), \n                  var = c(\"start\", \"end\", \"start\", \"end\"), \n                  date = c(\"2024-10-04\", \"2024-12-05\", \"2024-10-25\", \"2024-12-07\")) |&gt;\n  tidyr::nest(dates = c(var, date))\n\ndf\n\n# A tibble: 2 × 2\n    ref dates           \n  &lt;dbl&gt; &lt;list&gt;          \n1     1 &lt;tibble [2 × 2]&gt;\n2     2 &lt;tibble [2 × 2]&gt;\n\n\n\ndf |&gt; gt::gt() |&gt; gt_timeline(dates, min_date = \"2024-10-01\", max_date = \"2024-12-31\", palette = c(start = \"#00AA00\", end = \"#AA0000\"))\n\n\n\n\n\n\n\n\n\n\n\nref\ndates\n\n\n\n\n1\n\n   start (2024-10-04)    end (2024-12-05) \n\n\n\n2\n\n   start (2024-10-25)    end (2024-12-07)"
  },
  {
    "objectID": "posts/2025/2025-08-01-rmd-hooks/index.html",
    "href": "posts/2025/2025-08-01-rmd-hooks/index.html",
    "title": "Working with RMarkdown Hooks",
    "section": "",
    "text": "knitr hooks and Quarto extensions are powerful methods to change the way that RMarkdown and Quarto work. In this post we explore building a verification extension, an RMarkdown and Quarto extension which allows chunks to be tagged as verified and included in output with a notice."
  },
  {
    "objectID": "posts/2025/2025-08-01-rmd-hooks/index.html#introduction",
    "href": "posts/2025/2025-08-01-rmd-hooks/index.html#introduction",
    "title": "Working with RMarkdown Hooks",
    "section": "Introduction",
    "text": "Introduction\nThe verification process is simple in concept. When a code chunk has been reviewed a user can set a chunk option, verified as TRUE. They can also include a username and date to capture metadata. For example, the following chunk is unverified:\n\n---\ntitle: my document\noutput: html_document\n---\n```{r}\nx &lt;- mtcars\nprint(x)\n```\n\nwhereas the following has been verified:\n\n---\ntitle: my document\noutput: html_document\nverify_filter: only\n---\n```{r, verified=TRUE, verified_by=\"Harvey\", verified_date=\"2026-06-30\"}\nx &lt;- mtcars\nprint(x)\n```\n\nThis simply adds metadata to the code chunk, but the great thing about RMarkdown and Quarto is how we work with this metadata. We want to define processes that will identify the value of verify_filter in the metadata header along with values for verified, verified_by and verified_date in code chunks and respond accordingly.\nverify_filter can take values of ignore, highlight and only. ignore will simply ignore the verfied chunk option and return a rendered RMarkdown as if nothing has been changed. highlight will look for chunks with verified=TRUE and highlight them with a grey header, executing all code chunks. only will look for chunks with verified=TRUE and highlight them with a yellow header, but execute only these chunks, i.e. chunks that do not have verified=TRUE as an option will not be executed."
  },
  {
    "objectID": "posts/2025/2025-08-01-rmd-hooks/index.html#knitr-hooks-and-pandoc-extensions",
    "href": "posts/2025/2025-08-01-rmd-hooks/index.html#knitr-hooks-and-pandoc-extensions",
    "title": "Working with RMarkdown Hooks",
    "section": "Knitr Hooks and Pandoc Extensions",
    "text": "Knitr Hooks and Pandoc Extensions\nRMarkdown and Quarto can be extended using knitr hooks and pandoc extensions. knitr hooks run during the knitting process, as code is evaluated, wheras pandoc extensions run once the markdown output has been generated. The flow of an RMarkdown or Quarto file to output is illustrated below:\n\n\n\n\n\nflowchart LR\n  subgraph RMarkdown/Quarto\n  A(RMD)==&gt;B(knitr)\n  B(knitr)==&gt;C(md)\n  C(md)==&gt;D(pandoc)\n  B1(hooks)--&gt;B(knitr)\n  B(knitr)--&gt;B1(hooks)\n  D1(extensions)--&gt;D(pandoc)\n  D(pandoc)--&gt;D1(extensions)\n  end\n  D(pandoc)===&gt;E(output document)\n\n  classDef bg fill:#ffffff;\n  class RMarkdown/Quarto bg;\n\n\n\n\n\n\nThere are three types of knitr hook:\n\noption hooks. Used to change how a chunk option (eg echo, eval) operates. Option hooks are triggered when a new chunk is processed.\nchunk hooks. Used to modify chunk output. Chunk hooks are executed before and after the chunk code is run and can be built with different code that runs before and after executing the code chunk.\noutput hooks. Used to customize an output. Output hooks are run after chunk output has been generated."
  },
  {
    "objectID": "posts/2025/2025-08-01-rmd-hooks/index.html#rmarkdown-approach",
    "href": "posts/2025/2025-08-01-rmd-hooks/index.html#rmarkdown-approach",
    "title": "Working with RMarkdown Hooks",
    "section": "RMarkdown Approach",
    "text": "RMarkdown Approach\nThe RMarkdown approach consists of two knitr hooks, an option hook and a chunk hook. The first, knitr::opts_hooks$set() redefines the eval option so that we can capture evaluated chunks, ignoring them if under specific conditions. The second, knitr::hooks$set() creates a new hook to respond to verified=TRUE as a code chunk option. In addition to the hooks, we’ll add some css though a css chunk and an R function %||% to help with logic.\n\nTop of the RMarkdown File\nThe top of the RMarkdown Rmd file is shown below. It contains so css for the styling and a utility function, %||%.\n---\ntitle: \"Verify Example - RMarkdown\"\noutput:\n  html_document:\n    self_contained: true\nverify_filter: ignore  # values = ignore, highlight, only\n---\n\n```{css, echo=FALSE}\n.verify {\n  display: inline-block;\n  color: black;\n  padding: 5px;\n  border-radius: 5px;\n  margin-bottom: 10px;\n  font-weight: bold;\n}\n\n.verify-checked {\n  background-color: #FFF59D;\n}\n\n.verify-notchecked {\n  background-color: #CFD8DC;\n  font-weight: normal;\n}\n```\n\n```{r, include=FALSE}\n## if x is null return y, otherwise return x\n`%||%` &lt;- function(x, y) {\n  if (!is.null(x)) x else y\n}\n```\n\n\nChunk Hook\nNext we define the chunk hook. This is the hook that is executed for each chunk. Chunk hooks run both before and after the code contained in the chunk and are built using this code:\n```{r}\nknitr::knitr_hooks$set(hookname = function(before, options) {\n  if (before == TRUE) {\n    ## code to run before chunk code is executed\n  } else {\n    ## code to run after chunk code is executed\n  }\n})\n```\nknitr_hooks$set() can actually take up to four arguments, all of which are optional. These arguments are:\n\nbefore. A boolean indicating if the hook is running before or after executing the code chunk.\noptions. A list of chunk options for the current chunk.\nenvir. The environment that the chunk is executing in.\nname. Name of the option that triggered the hook.\n\nOur chunk hook is as follows:\n```{r, echo=FALSE}\n\nknitr::knit_hooks$set(verified = function(before, options) {\n  if (isTRUE(rmarkdown::metadata[[\"verify_filter\"]] %in% c(\"only\", \"highlight\"))) {\n\n    ## check if the `verified` option is enabled (`TRUE`)\n    verified &lt;- isTRUE(options[[\"verified\"]])\n    verified_by &lt;- options[[\"verified_by\"]] %||% \"not specified\"\n    verified_date &lt;- options[[\"verified_date\"]] %||% \"not specified\"\n\n    ## code to run before the code chunk\n    if (verified && before) {\n      class = ifelse(rmarkdown::metadata[[\"verify_filter\"]] == \"only\", \"verify-checked\", \"verify-notchecked\")\n      glue::glue(\"&lt;div class = 'verify {class}'&gt;Verification: checked | Checked by: {verified_by} | Date: {verified_date}&lt;/div&gt;\")\n    }\n  }\n})\n\n```\nThe hook passed before, so that we can identify when this is triggered before the chunk and respond accordinly, and options, so that we can access the chunk options. rmarkdown::metadata[[\"verify_filter\"]] returns the verify_filter document metadata (rmarkdown::metadata is a great way to access document YAML metadata from within the document itself). Our function checks to see if the verify_filter metadata is only or highlight. If so it will return a div styled differently for only and highlight. Since the hook is run before the code chunk is executed (before == TRUE), the output div will sit above the chunk code in the output.\n\n\nOption Hook\nAfter the chunk hook we can define the option hook as follows:\n```{r, echo=FALSE}\n## redefine eval hook\nknitr::opts_hooks$set(eval = function(options) {\n  if (isTRUE(rmarkdown::metadata[[\"verify_filter\"]] == \"only\")) {\n    verified &lt;- isTRUE(options[[\"verified\"]])\n    options$echo &lt;- verified\n    options$eval &lt;- verified\n  }\n  return(options)\n})\n\n```\nThe option hook redefines how eval works. It runs before the chunk is executed but does not replace the eval function itself. It does, however, allow us to modify how eval operates. In this case, each chunk will be processed using the new eval chunk option as follows:\n\nIs the global metadata parameter verify_filter set to true? If so …\nIs the chunk variable verify_filter set to only? If so …\nSet the chunk echo and eval variables to the value of the verified chunk variable.\n\n\n\nPutting it all together\nNow we can include some chunks to process. The three chunks below define a variable, a, increase its value by one and print the result. The first and third chunk contain verified=TRUE whereas the second does not.\n```{r, verified=TRUE, verified_date=\"2025-06-30\"}\n## define variable a\na &lt;- 1\n```\n\n```{r, verified=FALSE}\n## change variable a\na &lt;- a + 1\n```\n\n```{r, verified=TRUE, verified_by=\"Harvey\", verified_date=\"2025-06-30\"}\n## return variable a\nprint(a)\n```\n\nRunning with verify_filter: ignore\nRendering the RMarkdown with verify_filter: ignore or without verify_filter set at all leads to regular RMarkdown output.\n\n\n\nRunning with verify_filter: highlight\nRendering the RMarkdown with verify_filter: highlight triggers the chunk hook but not the option hook. Each ‘verified’ chunk output contains a header with a grey background. All chunks have been evaluated (hence the result for a is 2).\n\n\n\nRunning with verify_filter: only\nRendering the RMarkdown with verify_filter: only triggers both the chunk hook and the option hook. Each ‘verified’ chunk output contains a header with a yellow background. Only chunks with verified: TRUE have been evaluated (hence the result for a is 1)."
  },
  {
    "objectID": "posts/2024/2024-02-15-toggle_plotly_errorbars/index.html",
    "href": "posts/2024/2024-02-15-toggle_plotly_errorbars/index.html",
    "title": "Toggling Error Bars in Plotly",
    "section": "",
    "text": "Plotly charts can be enhanced with custom controls. One use of controls is to update an existing chart. This post will show how to add a couple of buttons to a chart, toggling error bars on and off. It should be noted that coloring by group affects the order (and hence validity) of error bars in a Plotly plot so a workaround has to be employed.\n\nGenerate Some Demo Data\n\nset.seed(12345)\nd &lt;- data.frame(\n time = rep(0:9, 10),\n  group = sample(paste0(\"Group_\", seq(5)), size = 1000, replace = TRUE),\n  value = rnorm(n = 1000) + 1\n) |&gt;\n  dplyr::group_by(time, group) |&gt;\n  dplyr::summarise(mean = mean(value), se = sd(value) / sqrt(dplyr::n())) |&gt;\n  dplyr::ungroup()\n\n`summarise()` has grouped output by 'time'. You can override using the\n`.groups` argument.\n\n\n\n\nInitializing Chart and Adding Traces\nWe’ll build up the chart from the demo data by first initializing an empty plot as follows:\n\np &lt;- plotly::plot_ly(type = 'scatter', mode = 'lines+markers')\n\nThe next step is to add a series of traces, one for each group, without error bars:\n\nfor (x in unique(d$group)) {\n  p &lt;- p |&gt;\n    plotly::add_trace(data = d |&gt; dplyr::filter(group == x), visible = TRUE,\n                      x = ~time, y = ~mean, type = 'scatter', mode = 'lines+markers', color = ~group)\n} \n\nand then a second series of traces, this time with error bars but with the parameter visible=FALSE set to ensure that they are not visible when the chart is initially drawn:\n\nfor (x in unique(d$group)) {\n  p &lt;- p |&gt;\n    plotly::add_trace(data = d |&gt; dplyr::filter(group == x), visible = FALSE,\n                      x = ~time, y = ~mean, type = 'scatter', mode = 'lines+markers', color = ~group,\n                      error_y = ~list(array = se, color = group))\n}\n\nSince we have 5 groups, our plotly chart now contains 5 traces without error bars and 5 traces with error bars. It actually contains one additional empty trace corresponding to the initial plotly::plot_ly() call when the empty chart was built. This can be deduced using plotly::plotly_build() to observe the list object sent to plotly for plotting. At this stage the following code reveals a total of 11 traces:\n\np_obj &lt;- plotly::plotly_build(p)\nprint(length(p_obj$x$data))\n\n[1] 11\n\n\n\n\nBuilding the Menu Buttons\nPlotly does not have the option of a toggle switch or toggle button so we’ll add two buttons - one to plot without error bars and one to plot with error bars. The control works by changing the visible status so that only a subset of plots are visible. As mentioned above, we have 5 traces without error bars and 5 with. We also have the empty trace (the first trace), so in order to see just traces without error bars we’ll want to show only traces 2-6 and in order to see just traces with error bars we’ll want to show only traces 7-11. Here is the code to build the plotly menu buttons:\n\nnum_traces &lt;- length(unique(d$group))\nmenu &lt;- list(\n  active = 0,\n  type = 'buttons',\n  direction = 'right',\n  x = 1.2,\n  y = 0.1,\n  buttons = list(\n    list(\n      label = 'off',\n      method = 'update',\n      args = list(list(visible = c(F, rep(c(TRUE, FALSE), each = num_traces))))\n    ),\n    list(\n      label = 'on',\n      method = 'update',\n      args = list(list(visible = c(F, rep(c(FALSE, TRUE), each = num_traces))))\n    )\n  )\n)\n\nannotation &lt;- list(list(text = \"Error Bars\", x = 1.18, y = 0.13, xref = \"paper\", yref = \"paper\", showarrow = FALSE))\n\n\n\nPlotting\nFinally, the plot can be created by adding the menu items and annotation to the existing plotly object:\n\np |&gt;\n  plotly::layout(updatemenus = list(menu), annotations = annotation)"
  },
  {
    "objectID": "posts/2024/2024-08-07-dynamic_loops/index.html",
    "href": "posts/2024/2024-08-07-dynamic_loops/index.html",
    "title": "Building Dynamic Nested Loops in R",
    "section": "",
    "text": "lapply is a fundemental programming function in R, used to apply a function over a list ot a vector. Running lapply in a nested manner leads to a nested outcome. For example, the following code, when executed leads to the output below:\n\nlapply(c(\"A\", \"B\"), function(x) {\n  lapply(c(\"C\", \"D\"), function(y) {\n    paste0(x, y, collapse = \"\")\n  })\n})\n\n[[1]]\n[[1]][[1]]\n[1] \"AC\"\n\n[[1]][[2]]\n[1] \"AD\"\n\n\n[[2]]\n[[2]][[1]]\n[1] \"BC\"\n\n[[2]][[2]]\n[1] \"BD\"\n\n\nThere are situations where the inputs to the apply function may not be known in advance. Furthermore, we may not know how deep to nest. The following code uses a recursive approach to apply functions, returning output from a nested function without having to know how deep the nesting goes."
  },
  {
    "objectID": "posts/2024/2024-08-07-dynamic_loops/index.html#introduction",
    "href": "posts/2024/2024-08-07-dynamic_loops/index.html#introduction",
    "title": "Building Dynamic Nested Loops in R",
    "section": "",
    "text": "lapply is a fundemental programming function in R, used to apply a function over a list ot a vector. Running lapply in a nested manner leads to a nested outcome. For example, the following code, when executed leads to the output below:\n\nlapply(c(\"A\", \"B\"), function(x) {\n  lapply(c(\"C\", \"D\"), function(y) {\n    paste0(x, y, collapse = \"\")\n  })\n})\n\n[[1]]\n[[1]][[1]]\n[1] \"AC\"\n\n[[1]][[2]]\n[1] \"AD\"\n\n\n[[2]]\n[[2]][[1]]\n[1] \"BC\"\n\n[[2]][[2]]\n[1] \"BD\"\n\n\nThere are situations where the inputs to the apply function may not be known in advance. Furthermore, we may not know how deep to nest. The following code uses a recursive approach to apply functions, returning output from a nested function without having to know how deep the nesting goes."
  },
  {
    "objectID": "posts/2024/2024-08-07-dynamic_loops/index.html#coding",
    "href": "posts/2024/2024-08-07-dynamic_loops/index.html#coding",
    "title": "Building Dynamic Nested Loops in R",
    "section": "Coding",
    "text": "Coding\nWe’ll start with the calling function, called run_loops().\n\n#' run_loops\n#' Run a series of nested lapply functions, returning a nested\n#' or flattened list\n#' \n#' @param vals list of lists or vectors to run lapply over\n#' @param fn calling function\n#' @param flatten if TRUE then flatten the resulting output\n#' @param ... other named parameters passed to calling function\n#' \nrun_loops &lt;- function(vals, fn, flatten = FALSE, ...) {\n  rtn &lt;- .build_loop(vals = vals, params = list(), fn = fn, ...)\n  if (isTRUE(flatten)) {\n    return(.flatten(rtn, level = length(vals) - 1))\n  } else {\n    return(rtn)\n  }\n}\n\nIn this function, vals is a list of vectors to be called. To mimic the lapply() example above, vals = list(a = c(\"A\", \"B\"), b = c(\"C\", \"D\")). fn is the name of the function to call within the innermost lapply loop. flatten is a boolean specifying whether the resulting output should be flattened or kept as a nested list. ... allows additional parameters to be passed to fn. The function simply calls the recursive function .build_loop() with starting values and either returns the output or the flattened output once recursion has completed.\nNext comes the main recursive function, called .build_loop().\n\n#' .build_loop\n#' Add an lapply function or run the calling function\n#' \n#' @param vals list of lists or vectors to run lapply over\n#' @param params current list of parameters for calling function\n#' @param fn calling function\n#' @param ... other named parameters passed to calling function\n#' \n.build_loop &lt;- function(vals = list(), params = list(), fn, ...) {\n  if (length(vals) &gt; 0) {\n    lapply(vals[[1]], function(x) {\n      .build_loop(vals = vals[-1], params = c(params, setNames(x, names(vals)[1])), fn, ...)\n    })\n\n  } else {\n    return(fn(params, ...))\n  }\n}\n\n.build_loop() takes a number of parameters. vals, params and ... are initially passed from run_loops(). params is a named list of parameters, passed to fn. It’s worth spending a little time understanding this function as it powers the approach. Let’s provide an example and start to work through the logic.\nrun_loops(vals = list(a=c('a', 'b', 'c'), b=c('d', 'e'), c=c('f', 'g')), fn = f1)\nrun_loops() passes vals and fn to .build_loop() as initial values. .build_loop() checks the length of vals (in this case 3) and, if it’s greater than zero, continues. We then construct an lapply function to run over all values of vals[[1]], which, in this case is c(‘a’, ‘b’, ‘c’). Within the lapply function we recursively call .build_loop() on shorter and shorter iterations of vals, removing the first group each time and longer and longer iterations of params, the named list of parameters.\nthe recursive function’s terminal condition exists when vals has been reduced to an empty list and params contains a named list of parameters to pass to the calling function fn. The function fn runs on the named parameters, params which, in the first call will be c(a='a', b='d', c='f'), on the second call will be c(a='a', b='d', c='g'), and so on.\nThe final function is another recursive function, called .flatten(). This function recursively flattens a list to a specified level.\n\n#' .flatten\n#' Recursively flatten a list\n#' \n#' @param l list\n#' @param level level to flatten to\n#'\n.flatten &lt;- function(l, level = 1) {\n  if (purrr::pluck_depth(l) &gt; level) {\n    .flatten(purrr::list_flatten(l), level)\n  } else {\n    l\n  }\n}"
  },
  {
    "objectID": "posts/2024/2024-08-07-dynamic_loops/index.html#execution",
    "href": "posts/2024/2024-08-07-dynamic_loops/index.html#execution",
    "title": "Building Dynamic Nested Loops in R",
    "section": "Execution",
    "text": "Execution\nIn this example, we request a nested structure at three levels. For each combination we’ll run a function, f1. The lapply function has three levels of nesting with 3, 2, and 2 parameters, leading to 3x2x2 = 12 outputs.\nThe f1() function is:\n\n#' f1\n#' Function to test recursive lapply\n#' Paste a series of characters with an optional prefix\n#' \nf1 &lt;- function(params, ...) {\n  args &lt;- list(...)\n  paste0(c(args[[\"prefix\"]], params), collapse = \"\")\n}\n\nrun_loops() can be called as follows:\n\nrun_loops(vals = list(a=c('a', 'b', 'c'), b=c('d', 'e'), c=c('f', 'g')), fn = f1, flatten = FALSE, prefix = \"PRE_\")\n\n[[1]]\n[[1]][[1]]\n[[1]][[1]][[1]]\n[1] \"PRE_adf\"\n\n[[1]][[1]][[2]]\n[1] \"PRE_adg\"\n\n\n[[1]][[2]]\n[[1]][[2]][[1]]\n[1] \"PRE_aef\"\n\n[[1]][[2]][[2]]\n[1] \"PRE_aeg\"\n\n\n\n[[2]]\n[[2]][[1]]\n[[2]][[1]][[1]]\n[1] \"PRE_bdf\"\n\n[[2]][[1]][[2]]\n[1] \"PRE_bdg\"\n\n\n[[2]][[2]]\n[[2]][[2]][[1]]\n[1] \"PRE_bef\"\n\n[[2]][[2]][[2]]\n[1] \"PRE_beg\"\n\n\n\n[[3]]\n[[3]][[1]]\n[[3]][[1]][[1]]\n[1] \"PRE_cdf\"\n\n[[3]][[1]][[2]]\n[1] \"PRE_cdg\"\n\n\n[[3]][[2]]\n[[3]][[2]][[1]]\n[1] \"PRE_cef\"\n\n[[3]][[2]][[2]]\n[1] \"PRE_ceg\"\n\n\nThe function can also be run, returning a flattened list as follows:\n\nrun_loops(vals = list(a=c('a', 'b', 'c'), b=c('d', 'e'), c=c('f', 'g')), fn = f1, flatten = TRUE, prefix = \"PRE_\")\n\n[[1]]\n[1] \"PRE_adf\"\n\n[[2]]\n[1] \"PRE_adg\"\n\n[[3]]\n[1] \"PRE_aef\"\n\n[[4]]\n[1] \"PRE_aeg\"\n\n[[5]]\n[1] \"PRE_bdf\"\n\n[[6]]\n[1] \"PRE_bdg\"\n\n[[7]]\n[1] \"PRE_bef\"\n\n[[8]]\n[1] \"PRE_beg\"\n\n[[9]]\n[1] \"PRE_cdf\"\n\n[[10]]\n[1] \"PRE_cdg\"\n\n[[11]]\n[1] \"PRE_cef\"\n\n[[12]]\n[1] \"PRE_ceg\""
  },
  {
    "objectID": "posts/2024/2024-08-07-dynamic_loops/index.html#alternative-method",
    "href": "posts/2024/2024-08-07-dynamic_loops/index.html#alternative-method",
    "title": "Building Dynamic Nested Loops in R",
    "section": "Alternative method",
    "text": "Alternative method\nAn alternative approach would be to build all combinations of parameters and then send them to the calling function, f1. The base R function expand.grid() can be used to run in this manner.\n\ng &lt;- expand.grid(list(a=c('a', 'b', 'c'), b=c('d', 'e'), c=c('f', 'g')))\napply(g, 1, f1, prefix = \"PRE_\")\n\n [1] \"PRE_adf\" \"PRE_bdf\" \"PRE_cdf\" \"PRE_aef\" \"PRE_bef\" \"PRE_cef\" \"PRE_adg\"\n [8] \"PRE_bdg\" \"PRE_cdg\" \"PRE_aeg\" \"PRE_beg\" \"PRE_ceg\"\n\n\nThe advantage of expand.grid() is that it is far simpler in nature, however the nested structure is lost. The recursive approach outlined above offers additional advantages when working with more complex logic."
  },
  {
    "objectID": "posts/2024/2024-06-09-plotly_group_select/index.html",
    "href": "posts/2024/2024-06-09-plotly_group_select/index.html",
    "title": "Selectable Groups in Plotly",
    "section": "",
    "text": "This is a short tutorial on building a plotly stripchart with a dropdown to select a dataset. It covers a few points such as how to handle stripcharts with jitter in plotly, building the plotly menu programatically and how to format a dataset to work with plotly dropdowns.\nOf course, the same effect can be accomplished with a selectizeInput in shiny but this method does not rely on the use of a server 1 and can be embedded in an HTML report."
  },
  {
    "objectID": "posts/2024/2024-06-09-plotly_group_select/index.html#generating-some-dummy-data",
    "href": "posts/2024/2024-06-09-plotly_group_select/index.html#generating-some-dummy-data",
    "title": "Selectable Groups in Plotly",
    "section": "Generating Some Dummy Data",
    "text": "Generating Some Dummy Data\nFirst, we build some dummy data for the plots.\n\n## build a data frame for demo\ndf &lt;- data.frame(\n  id = rep(seq(30), 3),\n  group_name = rep(rep(c(\"A\", \"B\", \"C\"), each = 10), 3),\n  time = rep(paste(\"Time\", seq(3)), each = 30),\n  value = lapply(seq(9), function(x) runif(min=x, max=x+1, n=10)) |&gt; unlist()\n) |&gt; \n  dplyr::mutate(group_name = as.factor(group_name))\n\nhead(df)\n\n  id group_name   time    value\n1  1          A Time 1 1.187803\n2  2          A Time 1 1.443192\n3  3          A Time 1 1.971346\n4  4          A Time 1 1.862019\n5  5          A Time 1 1.683518\n6  6          A Time 1 1.440731"
  },
  {
    "objectID": "posts/2024/2024-06-09-plotly_group_select/index.html#programatically-building-plotly-dropdown",
    "href": "posts/2024/2024-06-09-plotly_group_select/index.html#programatically-building-plotly-dropdown",
    "title": "Selectable Groups in Plotly",
    "section": "Programatically Building Plotly Dropdown",
    "text": "Programatically Building Plotly Dropdown\nChanging a dataset interactively in plotly is not as straightforward as a shiny approach of linking a selectizeInput to a parameter. Plotly’s approach requires passing all data to the plot and toggling visibility. The updatemenus parameter in plotly::layout() is used to build menus (see https://plotly.com/r/dropdowns/).\nThe examples on the plotly site show how to restyle a graph, passing a series of parameters through updatemenus. updatemenus itself is a list and can therefore be built programatically. The code below shows how we can build the UI and logic required to select one of the three values of time in our dataset.\n\n## identify the unique values in the time column\ntime_vals &lt;- df$time |&gt; \n  unique() |&gt; \n  sort()\n\n## count the number of values for each time\nv_time_group &lt;- df |&gt;\n  dplyr::select(time, group_name) |&gt;\n  dplyr::distinct() |&gt;\n  dplyr::arrange(time) |&gt;\n  dplyr::group_by(time) |&gt;\n  dplyr::summarise(count = dplyr::n()) |&gt;\n  dplyr::pull(count)\n\n## build a set of vectors to send to updatemenus.\n## each member is a set of TRUE/FALSE values denoting visibility.\nTF_time_vals &lt;- lapply(seq(length(v_time_group)), function(i) {\n  if (i == 1) {\n    values_false_start &lt;- 0\n  } else {\n    values_false_start &lt;- sum(v_time_group[1:(i-1)])\n  }\n\n  if (i == length(v_time_group)) {\n    values_false_end &lt;- 0\n  } else {\n    values_false_end &lt;- sum(v_time_group[(i+1):length(v_time_group)])\n  }\n  c(rep(FALSE, values_false_start), rep(TRUE, v_time_group[i]), rep(FALSE, values_false_end))\n})\n\n\n### OUTPUTS for updatemenus\ntime_vals\n\n[1] \"Time 1\" \"Time 2\" \"Time 3\"\n\nTF_time_vals\n\n[[1]]\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n[[2]]\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\n[[3]]\n[1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n\nThe updatemenus list is built using the code below. Essentially it is a list of a label, for each time point, and vector of boolean values denoting visibility, for each group at each time point. It should be noted that each vector for visibility has nine values denoting the three groups (A, B and C) at the three time points (Time 1, Time 2 and Time 3). In the first, TF_time_vals[[1]], we specify that all three groups are visible for Time 1 but not Time 2 or Time 3.\n\nupdate_menus_buttons &lt;- lapply(seq_along(time_vals), function(i) {\n  list(method = \"update\",\n       args = list(list(visible = TF_time_vals[[i]])),\n       label = time_vals[i]\n  )\n})"
  },
  {
    "objectID": "posts/2024/2024-06-09-plotly_group_select/index.html#build-the-chart",
    "href": "posts/2024/2024-06-09-plotly_group_select/index.html#build-the-chart",
    "title": "Selectable Groups in Plotly",
    "section": "Build the Chart",
    "text": "Build the Chart\nIf we build our plot, passing all data at once, the dropdown menu logic fails. This is because plotly expects a series of separate traces for the dropdown menu.\nTherefore this code will not work:\np &lt;- plotly::plot_ly(\n  data = df, x = ~jitter(as.numeric(group_name)), y = ~value, type = \"scatter\", mode = \"markers\", color = ~group_name\n)\n\np\n\n\nBut this will:\n## start with an empty plotly object\np &lt;- plotly::plot_ly(data = df)\n\nfor (t in time_vals) {\n  d &lt;- df |&gt; dplyr::filter(time == t)\n  p &lt;- p |&gt;\n    plotly::add_trace(data = d,\n                      x = ~jitter(as.numeric(group_name)),\n                      y = ~value,\n                      type = 'scatter', mode = 'markers',\n                      color = ~group_name, visible = t==time_vals[1])\n}\n\np\n\n\nSince we’ll be selecting by time, we neede to create a separate trace, one for each time. A small amount of jitter is added to the x values. This is achieved by taking the numeric value of group_name (a factor) and applying the base R jitter() function. A caveat to this approach is that the x-axis value are now numeric as opposed to the group name. Initial visibility is defined as t==time_vals[1], which will take the first value in the time_vals vector, namely Time 1.\nFinally, we add some axis labels and dropdown, and return the plot.\np &lt;- p |&gt; plotly::layout(\n  xaxis = list(title = \"Group\", showticklabels = FALSE, showgrid = FALSE),\n  yaxis = list(title = \"Values\"))\n\np &lt;- p |&gt; plotly::layout(\n  updatemenus = list(\n    list(x = 0.1, y = 1.1, buttons = update_menus_buttons)\n  )\n)\n\np"
  },
  {
    "objectID": "posts/2024/2024-06-09-plotly_group_select/index.html#footnotes",
    "href": "posts/2024/2024-06-09-plotly_group_select/index.html#footnotes",
    "title": "Selectable Groups in Plotly",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nshiny apps can now be built server-free using webR.↩︎"
  },
  {
    "objectID": "posts/2024/2024-10-15-comparing_numerics/index.html",
    "href": "posts/2024/2024-10-15-comparing_numerics/index.html",
    "title": "Testing for a Float in a Vector",
    "section": "",
    "text": "Equality between floating points is always challening when programming (see https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems). One way to determine if two numbers are equal is to set a precision. In this short snippet I create a function (%noVwithin%) to determine if a number exists in a vector of floating point numbers. The function is then vectorized so that it can be used in tidyverse expressions."
  },
  {
    "objectID": "posts/2024/2024-10-15-comparing_numerics/index.html#function---novwithin",
    "href": "posts/2024/2024-10-15-comparing_numerics/index.html#function---novwithin",
    "title": "Testing for a Float in a Vector",
    "section": "Function - %noVwithin%",
    "text": "Function - %noVwithin%\n\nprecision &lt;- 1e-10\n\n`%noVwithin%` &lt;- function(x, y) {\n  any(\n    sapply(y, function(z) {\n      abs(x - z) &lt;= precision\n    })\n  )\n}\n\nThe function %noVwithin% takes two variables, checking to see if x is within the vector y. It is similar to the R function %in% but works with floating point numbers. The example below illustrates both %in% and %noVwithin%\n\na &lt;- 0.8\nb &lt;- 0.4\nval &lt;- a + b\n\nprint(val %in% c(1.1, 1.2, 1.3))\n\n[1] FALSE\n\nprint(val %noVwithin% c(1.1, 1.2, 1.3))\n\n[1] TRUE"
  },
  {
    "objectID": "posts/2024/2024-10-15-comparing_numerics/index.html#vectorizing-the-function",
    "href": "posts/2024/2024-10-15-comparing_numerics/index.html#vectorizing-the-function",
    "title": "Testing for a Float in a Vector",
    "section": "Vectorizing the Function",
    "text": "Vectorizing the Function\nOur function works but fails when used in a tidyverse pipe:\n\nd &lt;- tibble::tibble(\n  a = seq(0.1, 0.5, 0.1),\n  b = seq(1.1, 1.5, 0.1), \n  val = a + b\n)\n\nprint(d)\n\n# A tibble: 5 × 3\n      a     b   val\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1   0.1   1.1   1.2\n2   0.2   1.2   1.4\n3   0.3   1.3   1.6\n4   0.4   1.4   1.8\n5   0.5   1.5   2  \n\nmyVals &lt;- seq(1, 1.6, 0.2)\nprint(myVals)\n\n[1] 1.0 1.2 1.4 1.6\n\nd |&gt;\n  dplyr::mutate(in_myVals = val %noVwithin% myVals)\n\n# A tibble: 5 × 4\n      a     b   val in_myVals\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;    \n1   0.1   1.1   1.2 TRUE     \n2   0.2   1.2   1.4 TRUE     \n3   0.3   1.3   1.6 TRUE     \n4   0.4   1.4   1.8 TRUE     \n5   0.5   1.5   2   TRUE     \n\n\nHere, val is identified as present in myVals even when it is not.\nVectorizing is simple. We just pass the function to Vectorize(), passing a list of argument names that we wish to vectorize. In this case we are passing just the x variable as y is fixed when calling.\n\n`%within%` &lt;- Vectorize(`%noVwithin%`, vectorize.args = \"x\")\n\nOur new function, %within%, is the vectorized version. Running the code above with %within% gives the expected result.\n\nd |&gt;\n  dplyr::mutate(in_myVals = val %within% myVals)\n\n# A tibble: 5 × 4\n      a     b   val in_myVals\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;    \n1   0.1   1.1   1.2 TRUE     \n2   0.2   1.2   1.4 TRUE     \n3   0.3   1.3   1.6 TRUE     \n4   0.4   1.4   1.8 FALSE    \n5   0.5   1.5   2   FALSE"
  },
  {
    "objectID": "posts/2024/2024-10-15-comparing_numerics/index.html#using-the-in-function",
    "href": "posts/2024/2024-10-15-comparing_numerics/index.html#using-the-in-function",
    "title": "Testing for a Float in a Vector",
    "section": "Using the %in% Function",
    "text": "Using the %in% Function\nRunning the above code with the base R %in% function (which, like many base R functions, is vectorized) in place of %within% produces an interesting output:\n\nd |&gt;\n  dplyr::mutate(in_myVals = val %in% myVals)\n\n# A tibble: 5 × 4\n      a     b   val in_myVals\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;    \n1   0.1   1.1   1.2 FALSE    \n2   0.2   1.2   1.4 FALSE    \n3   0.3   1.3   1.6 TRUE     \n4   0.4   1.4   1.8 FALSE    \n5   0.5   1.5   2   FALSE    \n\n\nEverything is false, as expected, except for 1.6. Looking at val and myVals illustrates why.\nHere are the values of val at 20 decimal places:\n\nd$val  |&gt; formatC(digits = 20, format = 'f')\n\n[1] \"1.20000000000000017764\" \"1.40000000000000013323\" \"1.60000000000000008882\"\n[4] \"1.80000000000000026645\" \"2.00000000000000000000\"\n\n\nand here are the values stored in the myVals vector:\n\nmyVals |&gt; formatC(digits = 20, format = 'f')\n\n[1] \"1.00000000000000000000\" \"1.19999999999999995559\" \"1.39999999999999991118\"\n[4] \"1.60000000000000008882\"\n\n\nIt’s interesting to note that both values for 1.6 (d[3, ]$val and myvals[4]) are identical, hence the %in% comparison works for 1.6."
  },
  {
    "objectID": "posts/2024/2024-10-15-comparing_numerics/index.html#alternative-approaches",
    "href": "posts/2024/2024-10-15-comparing_numerics/index.html#alternative-approaches",
    "title": "Testing for a Float in a Vector",
    "section": "Alternative approaches",
    "text": "Alternative approaches\n\ndplyr::rowwise()\nThe non-vectorized version works when used in conjunction with dplyr::rowwise() as rowwise computes one row at a time.\n\nd |&gt;\n  dplyr::rowwise() |&gt;\n  dplyr::mutate(in_myVals = val %noVwithin% myVals)\n\n# A tibble: 5 × 4\n# Rowwise: \n      a     b   val in_myVals\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;    \n1   0.1   1.1   1.2 TRUE     \n2   0.2   1.2   1.4 TRUE     \n3   0.3   1.3   1.6 TRUE     \n4   0.4   1.4   1.8 FALSE    \n5   0.5   1.5   2   FALSE    \n\n\n\n\npurrr::map\nThe purrr::map() functions can work with non-vectorized functions within a mutate().\n\nd |&gt;\n  dplyr::mutate(in_myVals = purrr::map_lgl(val, `%noVwithin%`, myVals))\n\n# A tibble: 5 × 4\n      a     b   val in_myVals\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;    \n1   0.1   1.1   1.2 TRUE     \n2   0.2   1.2   1.4 TRUE     \n3   0.3   1.3   1.6 TRUE     \n4   0.4   1.4   1.8 FALSE    \n5   0.5   1.5   2   FALSE"
  },
  {
    "objectID": "posts/2023/2023-11-10-sortable_add/index.html",
    "href": "posts/2023/2023-11-10-sortable_add/index.html",
    "title": "Adding to a sortable bucketlist",
    "section": "",
    "text": "The {sortable} package\n{sortable} is an incredibly useful R package built upon the sortbale.js javascript library, allowing drag-and-drop features to be incorporated into shiny apps. The package works with two types of sortable lists:\n\nrank list: items can be sorted within a list\nbucket list: a single object containing multiple rank lists, allowing for drag-and-drop between lists.\n\nThe second option (bucket list) is useful when a user wishes to divide a set of values between two or more buckets. {sortable} integrates well within shiny but requires a few tweaks if data are added to the sortable object once it has been created.\n\n\n\n\n\n\nNote\n\n\n\n{sortable} includes a function, update_bucket_list() which is used to update header text but not list items.\n\n\n\n\nCase One. Dragging Existing Values Between Lists\nHere’s a simple scenario. Suppose you have a list of objects in list 1 and you wish to subset to list 2, returning the values in list 2. Using {sortable} you could define a bucket list containing two rank lists (list 1 and list 2), populate list 1 and drag-and-drop values to list 2. In a shiny app this could be coded as follows:\n\nlibrary(shiny)\nlibrary(sortable)\n\nui &lt;- fluidPage(\n  uiOutput(\"ui_sort\"),\n  verbatimTextOutput(\"txt_output\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$ui_sort &lt;- renderUI({\n    \n    ## create styled list 1\n    list_1_tags &lt;- lapply(LETTERS[1:5], function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    ## create styled list 2\n    list_2_tags &lt;- lapply(LETTERS[6:8], function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    ## sortbale bucket list\n    sortable::bucket_list(\n      header = \"Move values from list 1 to list 2\",\n      group_name = \"reorder_list\",\n      sortable::add_rank_list(\n        input_id = \"reorder_list_1\",\n        text = \"list 1\",\n        labels = list_1_tags\n      ),\n      sortable::add_rank_list(\n        input_id = \"reorder_list_2\",\n        text = \"list 2\",\n        labels = list_2_tags\n      ))\n  })\n  \n  output$txt_output &lt;- renderPrint({\n    print(input$reorder_list)\n  })\n  \n}\n\nshinyApp(ui, server)\n\nIn this example, every time list 1 or list 2 changes, input$reorder_list updates with the ordered values for each list.\n\n\nCase Two. Adding a New Value to an Existing List\nUpdating the code above with an actionButton linked to insertUI allows us to add a new option to list 2 when the button is pressed. This approach works but you’ll see that it does not update input$reorder_list until the list is updated (by moving an item).\n\nlibrary(shiny)\nlibrary(sortable)\n\nui &lt;- fluidPage(\n  uiOutput(\"ui_sort\"),\n  actionButton(\"but_add\", \"Add\"),\n  verbatimTextOutput(\"txt_output\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$ui_sort &lt;- renderUI({\n    \n    ## create styled list 1\n    list_1_tags &lt;- lapply(LETTERS[1:5], function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    ## create styled list 2\n    list_2_tags &lt;- lapply(LETTERS[6:8], function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    ## sortbale bucket list\n    sortable::bucket_list(\n      header = \"Move values from list 1 to list 2\",\n      group_name = \"reorder_list\",\n      sortable::add_rank_list(\n        input_id = \"reorder_list_1\",\n        text = \"list 1\",\n        labels = list_1_tags\n      ),\n      sortable::add_rank_list(\n        input_id = \"reorder_list_2\",\n        css_id = \"css_reorder_list_2\",\n        text = \"list 2\",\n        labels = list_2_tags\n      ))\n  })\n  \n  observeEvent(input$but_add, {\n    ## insert a new value into list 2\n    val &lt;- \"ZZ\"\n    new_tag &lt;- tags$div(class = \"rank-list-item\", draggable = FALSE,\n                        tags$span(id = paste0('lab_', val), val, class = \"label label-primary\", `data-rank-id` = val)\n    )\n    insertUI(selector = \"#css_reorder_list_2\", where = \"beforeEnd\", ui = new_tag, immediate = TRUE)\n  })\n  \n  output$txt_output &lt;- renderPrint({\n    print(input$reorder_list)\n  })\n  \n}\n\nshinyApp(ui, server)\n\n\nIn order to make this approach work we can manage the ordered list, list 2 through a shiny input, input$sort_list_2. This shiny variable is kept up to date through two methods:\n\nsortable::sortable_options() updates input$sort_list_2 when list 2 is first initialized, a new item is dragged from list 1 or the order is changed.\nWhen the new item is added, a javascript function is executed, updating input\\(sort_list_2* with the newly ordered list.  The javascript function works but identifying the identifer of the list and looping through its members, populating *input\\)sort_list_2.\n\n\nlibrary(shiny)\nlibrary(sortable)\n\nui &lt;- fluidPage(\n  \n  tagList(\n    tags$head(tags$script(src = \"script.js\")),\n    uiOutput(\"ui_sort\"),\n    actionButton(\"but_add\", \"Add\"),\n    verbatimTextOutput(\"txt_output\")\n  )\n  \n)\n\nl1 &lt;- LETTERS[1:5]\nl2 &lt;- LETTERS[6:8]\n\nserver &lt;- function(input, output, session) {\n  \n  output$ui_sort &lt;- renderUI({\n    \n    list_1_tags &lt;- lapply(l1, function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    list_2_tags &lt;- lapply(l2, function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    sortable::bucket_list(\n      header = \"Reorder values in 'ordered values' column\",\n      group_name = \"reorder_list\",\n      sortable::add_rank_list(\n        input_id = \"reorder_list_1\",\n        text = \"list 1\",\n        labels = list_1_tags\n      ),\n      sortable::add_rank_list(\n        input_id = \"reorder_list_2\",\n        css_id = \"css_reorder_list_2\",\n        text = \"list 2\",\n        labels = list_2_tags,\n        options = sortable_options(\n          onSort = sortable_js_capture_input(\"sort_list_2\"),\n          onLoad = sortable_js_capture_input(\"sort_list_2\"))\n      ))\n  })\n  \n  observeEvent(input$but_add, {\n    print(\"adding ZZ\")\n    val &lt;- \"ZZ\"\n    new_tag &lt;- tags$div(class = \"rank-list-item\", draggable = FALSE,\n                        tags$span(id = paste0('lab_', val), val, class = \"label label-primary\", `data-rank-id` = val)\n    )\n    insertUI(selector = \"#css_reorder_list_2\", where = \"beforeEnd\", ui = new_tag, immediate = TRUE)\n    session$sendCustomMessage('update_sortable', list(id = \"css_reorder_list_2\", shinyinput = \"sort_list_2\"))\n  })\n  \n  output$txt_output &lt;- renderPrint({\n    print(input$sort_list_2)\n  })\n  \n}\n\nshinyApp(ui, server)\n\nShiny.addCustomMessageHandler('update_sortable', function(x) {\n  if (typeof Shiny !== 'undefined') {\n    el = document.getElementById(x.id);\n    shinyinputname = x.shinyinput + ':sortablejs.rank_list'\n    Shiny.setInputValue(shinyinputname, $.map(el.children, function(child) {\n      return $(child).attr('data-rank-id') || $.trim(child.innerText);\n    }))\n  }\n})\n\n\n\nConclusion\nThe code above demonstrates a suitable approach to add items to a sortable bucket list in a shiny app. The concept can be extended to work with multiple lists, returning the content of each."
  },
  {
    "objectID": "posts/2023/2023-09-04-internal_label/index.html",
    "href": "posts/2023/2023-09-04-internal_label/index.html",
    "title": "Internal labels in textInput box",
    "section": "",
    "text": "Shiny textInput label\nThis is just a short post highlighing how you can move a textInput label so that it is within the textbox textInput box itself. This is a style that can be used when you have multiple textInputs and wish to preserve screen height.\nFirst we define a css class to reduce the size of the label text and reposition it relative to the text box.\n.internal-label .control-label {\n  position: relative;\n  display: inline-block;\n  width: 100%;\n  top: 20px;\n  right: 5px;\n  text-align: right;\n  font-size: 50%;\n  color: #888;\n  z-index: 2;\n}\nThen add the class to a textInput widget to move the label.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  tags$head(tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"style.css\")),\n  br(),\n  fluidRow(column(6, offset = 1, textInput(\"txt1\", label = \"Original Textbox Label\", value = \"Textbox Text\"))),\n  fluidRow(column(6, offset = 1, textInput(\"txt1\", label = \"Internal Textbox Label\", value = \"Textbox Text\") |&gt;\n      tagAppendAttributes(class = \"internal-label\")))\n)\n\nserver &lt;- function(input, output, session) {}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2023/2023-01-27-selectizeinput_order/index.html",
    "href": "posts/2023/2023-01-27-selectizeinput_order/index.html",
    "title": "Ordering Pre-selected Items in selectizeInput",
    "section": "",
    "text": "SelectizeInput\nSelectizeInput is a powerful shiny widget built on the selectize.js library. The behavior of selectize.js can be extended using plugins, which are available in the shiny::selectizeInput() functon. One particularly useful plugin is “drag_drop” which allows a user to re-order the items selected in a selectizeInput. When paired with the “remove_button” plugin this makes a powerful UI in which a user may select, reorder and remove items from a list.\nWhen building a selectizeInput widget, we can list items that have been pre-selected, which allows us to start in a specific state. With drag-drop and remove_button added, these pre-selected items will appear in the selectizeInput box, already selected.\nFor example, the code below produces the following output:\n\n\nshiny::selectizeInput(inputId = \"sel\", \n                      label = \"Selection\", \n                      choices = 1:10, \n                      selected = 1:5, \n                          multiple = TRUE, \n                          options = list(\n                            plugins= list(\"remove_button\", \"drag_drop\")\n                          ))\n\nThere is one caveat in this approach which is that the order of selected items is not honored. For example, the code below produces the following output:\n\n\nshiny::selectizeInput(inputId = \"sel\", \n                      label = \"Selection\", \n                      choices = 1:10, \n                      selected = c(4, 7, 2, 3), \n                          multiple = TRUE, \n                          options = list(\n                            plugins= list(\"remove_button\", \"drag_drop\")\n                          ))\n\nThe correct items are selected but their order has not been preserved. Instead, they are ordered according to the order of the choices parameter. This is normal behavior and is an artefact in the way that selectize.js works.\n\n\nSolution to Order of Pre-selected Items\nA solution to this issue lies in re-ordering the choices parameter. The following shiny app will also fail to maintain the order of the selected items:\n\nlibrary(shiny)\n\nvals &lt;- setNames(1:10, sapply(1:10, function(i) paste(\"Row\", i)))\nvals_start &lt;- c(4, 7, 2, 3)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(6, uiOutput(\"ui_selectize\")),\n    column(6, verbatimTextOutput(\"ui_selected_values\"))\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$ui_selectize &lt;- renderUI({\n    shiny::selectizeInput(inputId = \"sel\", \n                          label = \"Selection\", \n                          choices = vals, \n                          selected = vals_start, \n                          multiple = TRUE, \n                          options = list(\n                            plugins= list(\"remove_button\", \"drag_drop\")\n                          ))\n  })\n  \n  output$ui_selected_values &lt;- renderPrint({\n    input$sel\n  })\n  \n}\n\nshinyApp(ui, server)\n\nBut, with the addition of a line at the start of output$ui_selectize, we maintain the order:\n\nlibrary(shiny)\n\nvals &lt;- setNames(1:10, sapply(1:10, function(i) paste(\"Row\", i)))\nvals_start &lt;- c(4, 7, 2, 3)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(6, uiOutput(\"ui_selectize\")),\n    column(6, verbatimTextOutput(\"ui_selected_values\"))\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$ui_selectize &lt;- renderUI({\n    vals &lt;- c(vals[match(vals_start, vals)], vals[which(!vals %in% vals_start)])\n    shiny::selectizeInput(inputId = \"sel\", \n                          label = \"Selection\", \n                          choices = vals, \n                          selected = vals_start, \n                          multiple = TRUE, \n                          options = list(\n                            plugins= list(\"remove_button\", \"drag_drop\")\n                          ))\n  })\n  \n  output$ui_selected_values &lt;- renderPrint({\n    input$sel\n  })\n  \n}\n\nshinyApp(ui, server)\n\nThe additional line vals &lt;- c(vals[match(vals_start, vals)], vals[which(!vals %in% vals_start)]) simply reorders vals so that our selected items come first in their correct order and the other items follow.\n\nvals &lt;- setNames(1:10, sapply(1:10, function(i) paste(\"Row\", i)))\nprint(vals)\n\n Row 1  Row 2  Row 3  Row 4  Row 5  Row 6  Row 7  Row 8  Row 9 Row 10 \n     1      2      3      4      5      6      7      8      9     10 \n\nvals_start &lt;- c(4, 7, 2, 3)\nvals &lt;- c(vals[match(vals_start, vals)], vals[which(!vals %in% vals_start)])\nprint(vals)\n\n Row 4  Row 7  Row 2  Row 3  Row 1  Row 5  Row 6  Row 8  Row 9 Row 10 \n     4      7      2      3      1      5      6      8      9     10 \n\n\nThe shiny output now looks like this. The order of our pre-selected items is honored."
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover the concept of framework instructions, how and where to store them and introduce the concept of interpreters."
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#introduction",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#introduction",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover the concept of framework instructions, how and where to store them and introduce the concept of interpreters."
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#shiny-framework-instructions",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#shiny-framework-instructions",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "Shiny Framework Instructions",
    "text": "Shiny Framework Instructions\nAs mentioned in part 1, the concept of a shiny framework is to build an app or its content using instructions. The instructions are parsed through an interpreter which converts the instructions into code. Instructions are the soul of the framework. They can be considered a recipe or lists of steps that are read and executed by an interpreter. Instructions may be a single sequence of steps which might be used to set up parts of an app, such as defining a consistent UI. More likely, the instructions are a collection where performs a specific task. The latter is where the strengths of a framework are realized as this approach is highly flexible and scales quickly compared to a traditional shiny app."
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#instruction-format",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#instruction-format",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "Instruction Format",
    "text": "Instruction Format\nTwo common formats to store instructional information are JSON and YAML. When imported into R using the {jsonlite} or {yaml} packages these instructional data are converted into a named list, which works very well when parsing instructions.\nSome key differences between the two formats: - JSON uses brackets to represent objects whereas YAML uses indentation. - JSON requires all strings to be in double quotes whereas single/double quotes are optional when using YAML. - Comments can be included in YAML but not in JSON. - JSON typically parses faster than YAML.\n\nJSON Format\nA simple JSON example is shown below:\n{\n  \"param_01\": \"value_01\",\n  \"param_02\": \"value_02\",\n  \"param_03\": \"value_03\",\n}\nFor a list of instructions we can use a JSON array. An advantage of this format, when working with a collection of instructions, is that each instruction set can contain different parameters:\n[\n  {\n    \"ref\": 1,\n    \"param_01\": \"value_01A\",\n    \"param_02\": \"value_02A\",\n  },\n  {\n    \"ref\": 2,\n    \"param_01\": \"value_01B\",\n    \"param_02\": \"value_02B\",\n    \"param_03\": \"value_03B\",\n  }\n]\nwhich is interpreted by R as follows (simplifyVector = FALSE ensures that the input is not converted to a data frame):\n\njsonlite::fromJSON(\"json_file.json\", simplifyVector = FALSE)\n\n\n\n[[1]]\n[[1]]$ref\n[1] 1\n\n[[1]]$param_01\n[1] \"value_01A\"\n\n[[1]]$param_02\n[1] \"value_02A\"\n\n\n[[2]]\n[[2]]$ref\n[1] 2\n\n[[2]]$param_01\n[1] \"value_01B\"\n\n[[2]]$param_02\n[1] \"value_02B\"\n\n[[2]]$param_03\n[1] \"value_03B\""
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#yaml-format",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#yaml-format",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "YAML Format",
    "text": "YAML Format\nA simple YAML example is shown below:\nparam_01: value_01\nparam_02: value_02\nparam_03: value_03\nFor a list of instructions we can use a YAML array. An advantage of this format, when working with a collection of instructions, is that each instruction set can contain different parameters:\n-  ref: 1\n   param_01: value_01A\n   param_02: value_02A\n-  ref: 2\n   param_01: value_01A\n   param_02: value_02A\n   param_03: value_03A\nwhich is interpreted by R as follows:\n\nyaml::read_yaml(\"yaml_file.json\")\n\n\n\n[[1]]\n[[1]]$ref\n[1] 1\n\n[[1]]$param_01\n[1] \"value_01A\"\n\n[[1]]$param_02\n[1] \"value_02A\"\n\n\n[[2]]\n[[2]]$ref\n[1] 2\n\n[[2]]$param_01\n[1] \"value_01B\"\n\n[[2]]$param_02\n[1] \"value_02B\"\n\n[[2]]$param_03\n[1] \"value_03B\""
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#how-and-where-to-store-instructions",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#how-and-where-to-store-instructions",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "How and Where to Store Instructions",
    "text": "How and Where to Store Instructions\n\nFlat File\nJson and yaml are language-agnostic formats designed to be stored in a simple flat file. For smaller frameworks, this is an ideal way to store instructions. When working with a flat file, the entire contents are read into memory and converted to a list in R before processing.\n\n\nNoSQL Database\nWhen working with a collection of instructions, a NoSQL database works better than a flat file. Each instruction set is separated from the others and can be imported indepedently. NoSQL databases based on JSON such as MongoDB and CouchDB are ideally suited for a framework approach as this format can store complex data in a convenient format and work with hierarchical data. Moreover, there are simple R libraries that can interact with these databases, returning data as a named list.\n\n\nDatabase vs File\nThere are some advantages in considering a database over a flat file format. Firstly, individual records can be accessed far more readily from a database as compared to a file. Secondly, databases scale better than files, which tend to require reading the entire structure into memory before processing. An advantage of the file format is that there is a greater flexibility on where it can be located. A database generally requires a server, whereas a JSON file can be stored on a shared drive or pinned on a board using the {pins} library."
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#parsing",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#parsing",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "Parsing",
    "text": "Parsing\nWhether instructions are stored in a flat file or database, it makes sense to define a single set of functions to access the details. The parser or interpreter takes an instruction set and converts it from a series of parameters to a series of functional steps."
  },
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "Blog",
    "section": "",
    "text": "Working with RMarkdown Hooks\n\n\n\nRMarkdown\n\nQuarto\n\n\n\nWorking with RMarkdown Hooks\n\n\n\n\n\nAug 1, 2025\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nCapturing functions in R\n\n\n\nR\n\n\n\nCapturing a function in R\n\n\n\n\n\nJul 14, 2025\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nInserting Code Chunks into RMarkdown/Quarto\n\n\n\nRMarkdown\n\nQuarto\n\n\n\nA simple way to work with a library of code chunks\n\n\n\n\n\nJul 1, 2025\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nPorting to Quarto\n\n\n\nQuarto\n\n\n\nPorting the site from Hugo to Quarto\n\n\n\n\n\nJan 25, 2025\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\ngt Extensions\n\n\n\nR\n\n\n\nAdding Additional Functionality to the gt Package\n\n\n\n\n\nJan 13, 2025\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nNew Year Fun with Quarto\n\n\n\nQuarto\n\n\n\nA New Year’s balloon pop updated using Quarto.\n\n\n\n\n\nJan 2, 2025\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nTesting for a Float in a Vector\n\n\n\nR\n\n\n\nHow to check if a floating point is in a Vector\n\n\n\n\n\nOct 15, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding Dynamic Nested Loops in R\n\n\n\nR\n\n\n\nBuilding Dynamic Nested Loops in R - an exercise in recursion to retain a nested structure\n\n\n\n\n\nAug 7, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nSelectable Groups in Plotly\n\n\n\nR\n\nShiny\n\n\n\nHow to build a series of selectable groups in Plotly\n\n\n\n\n\nJun 9, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nFun With R6 Classes\n\n\n\nR\n\n\n\nchild R6 classes that update a parent\n\n\n\n\n\nApr 28, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nResizable bslib Cards\n\n\n\nR\n\nShiny\n\n\n\nbslib dashboards with resizable cards\n\n\n\n\n\nMar 1, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nToggling Error Bars in Plotly\n\n\n\nR\n\nShiny\n\n\n\nadding buttons to turn error bars on and off\n\n\n\n\n\nFeb 15, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nPassing and R6 Class to Quarto\n\n\n\nR\n\nQuarto\n\n\n\nHow to pass an R6 class to Quarto as a parameter\n\n\n\n\n\nFeb 2, 2024\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding a Quarto Extension\n\n\n\nQuarto\n\n\n\nFirst attempt at building a Quarto extension\n\n\n\n\n\nNov 20, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nAdding to a sortable bucketlist\n\n\n\nR\n\nShiny\n\n\n\nDynamically updating a sortable bucketlist upon adding a new element\n\n\n\n\n\nNov 10, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nServerless shiny app embedded in a Quarto Website\n\n\n\nR\n\nShiny\n\nQuarto\n\n\n\nServerless shiny app embedded in a Quarto Website\n\n\n\n\n\nOct 25, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nInternal labels in textInput box\n\n\n\nR\n\nShiny\n\n\n\nMoving a shiny textInput label to inside the textbox\n\n\n\n\n\nSep 4, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Frameworks 04 - Importing Data\n\n\n\nR\n\nShiny\n\nShiny Framework\n\n\n\nShiny Frameworks 04 - Importing Data\n\n\n\n\n\nMar 15, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Frameworks 03 - A Simple Interpreter\n\n\n\nR\n\nShiny\n\nShiny Framework\n\n\n\nShiny Frameworks 03 - A Simple Interpreter\n\n\n\n\n\nMar 10, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Frameworks 02 - Instructions and Parsing\n\n\n\nR\n\nShiny\n\nShiny Framework\n\nOpinion\n\n\n\nShiny Frameworks 02 - Instructions and Parsing\n\n\n\n\n\nMar 5, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Frameworks 01 - Introduction\n\n\n\nR\n\nShiny\n\nShiny Framework\n\nOpinion\n\n\n\nShiny Frameworks 01 - Introduction\n\n\n\n\n\nFeb 16, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nOrdering Pre-selected Items in selectizeInput\n\n\n\nR\n\nShiny\n\n\n\nMaintaining the order of pre-selected items in selectizeInput\n\n\n\n\n\nJan 27, 2023\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nplumber API as a package\n\n\n\nR\n\nPlumber\n\nRSConnect\n\n\n\nBuilding a plumber API as an R package\n\n\n\n\n\nNov 11, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nRunning SAS in Quarto. Part 2\n\n\n\nQuarto\n\nPython\n\n\n\nRunning SAS in Quarto. Part 2\n\n\n\n\n\nJul 2, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nRunning SAS in Quarto. Part 1\n\n\n\nQuarto\n\nPython\n\n\n\nRunning SAS in Quarto. Part 1\n\n\n\n\n\nJun 27, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nAdding and Retrieving metadata in RMarkdown Documents\n\n\n\nR\n\nRMarkdown\n\n\n\nInclude abitrary metadata in RMarkdown documents\n\n\n\n\n\nMay 31, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nAdding Metadata to R Functions\n\n\n\nR\n\n\n\nThree ways to embed metadata in R functions\n\n\n\n\n\nMay 28, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nknitr::knit_child with Quarto\n\n\n\nRMarkdown\n\nQuarto\n\n\n\nknitr::knit_child with Quarto\n\n\n\n\n\nMay 12, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\n{distill} Comments With Replies\n\n\n\nR\n\nJavascript\n\nRSConnect\n\n\n\nIncluding a comments (plus replies) section in {distill} pages\n\n\n\n\n\nMar 5, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\n{distill} Comments\n\n\n\nR\n\nJavascript\n\nRSConnect\n\n\n\nIncluding a comments section in {distill} pages\n\n\n\n\n\nJan 11, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny hot reload\n\n\n\nR\n\nShiny\n\n\n\nHot reload when working with a parameter file\n\n\n\n\n\nJan 5, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny dynamic tabs\n\n\n\nR\n\nShiny\n\n\n\nExtend and reduce tab count in shiny app\n\n\n\n\n\nJan 1, 2022\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nEmbedding {learnr} in {distill}\n\n\n\nR\n\n\n\nHow to share a {learnr} lesson within a {distill} website page\n\n\n\n\n\nNov 30, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nMultiwindow App - RStudio Connect and pins\n\n\n\nR\n\nShiny\n\nJavascript\n\nRSConnect\n\n\n\nBuilding a multiwindow shiny app running on RStudio Connect with pins\n\n\n\n\n\nNov 16, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nConnecting shiny modules through R6\n\n\n\nR\n\nShiny\n\nShiny Modules\n\n\n\nUsing an R6 class to share data between multiple shiny modules\n\n\n\n\n\nOct 10, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\n{distill} Contact Form\n\n\n\nR\n\nJavascript\n\nRSConnect\n\n\n\nIncluding a contact form on a {distill} site\n\n\n\n\n\nSep 8, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nMultiwindow App\n\n\n\nR\n\nShiny\n\nJavascript\n\n\n\nBuilding a multiwindow shiny app\n\n\n\n\n\nAug 30, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nUsing tidyselect in your own package\n\n\n\nR\n\n\n\nUsing tidyselect in your own package\n\n\n\n\n\nJul 22, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nImplementing magrittr\n\n\n\nR\n\n\n\nUsing the magrittr pipe in your own package\n\n\n\n\n\nJul 16, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nPassing a Mixture of Reactive and Non-Reactives to a Shiny Module\n\n\n\nR\n\nShiny\n\nShiny Modules\n\n\n\nPassing a Mixture of Reactive and Non-Reactives to a Shiny Module\n\n\n\n\n\nJun 20, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Reactivity\n\n\n\nR\n\nShiny\n\nShiny Modules\n\n\n\nList of Reactives vs Reactive List\n\n\n\n\n\nJun 2, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nBeer Trip Around the World\n\n\n\nR\n\n\n\nTraveling Salesman Problem between breweries\n\n\n\n\n\nMay 19, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nEmailing under Windows using R\n\n\n\nR\n\n\n\nUsing vbs scripting to email from R\n\n\n\n\n\nMay 10, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nA Switch to Hugo\n\n\n\nOpinion\n\n\n\nFrom Jekyll to Hugo\n\n\n\n\n\nMay 3, 2021\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nChecking internal consistency of CAS numbers\n\n\n\nR\n\nChemistry\n\n\n\nChecking internal consistency of CAS numbers\n\n\n\n\n\nDec 26, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nCAS from pdf\n\n\n\nR\n\nChemistry\n\n\n\nExtracting CAS numbers from a PDF\n\n\n\n\n\nDec 24, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nTowards Lab IoT Part Two\n\n\n\nPython\n\nIoT\n\n\n\nMoving towards IoT in a lab (part two - python test)\n\n\n\n\n\nOct 16, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nTowards Lab IoT Part One\n\n\n\nIoT\n\n\n\nMoving towards IoT in a lab (part one - installing and command-line testing)\n\n\n\n\n\nOct 16, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nStar Checkbutton\n\n\n\nR\n\nShiny\n\n\n\nIcon star as a checkbox in a shiny app\n\n\n\n\n\nSep 21, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nExtracting data from LCMS PDF\n\n\n\nR\n\nChemistry\n\n\n\nExtracting data from Agilent LCMS PDF\n\n\n\n\n\nAug 26, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nSetting up Shiny Apps - An Opinionated View\n\n\n\nR\n\nShiny\n\n\n\nHow I like to set up shiny apps on a single server\n\n\n\n\n\nJun 15, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nvisNetwork Continuous Colors\n\n\n\nR\n\n\n\nBuilding a visNetwork graph with a continuous color-coded fill\n\n\n\n\n\nMar 15, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nAlerts in Chrome and IE\n\n\n\nR\n\nShiny\n\nJavascript\n\n\n\nDisplaying Browser-Dependent alerts in Shiny Apps\n\n\n\n\n\nFeb 19, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nFormattable - color data according to RSD\n\n\n\nR\n\n\n\nHow to color a formattable table using data from another source. This is useful in coloring a table of averages according to RSD\n\n\n\n\n\nJan 31, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nStopping a crashed RStudio Server Instance\n\n\n\nR\n\n\n\nFinding and Stopping a Crashed Linux RStudio Server Instance\n\n\n\n\n\nJan 8, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny app startup options\n\n\n\nR\n\nShiny\n\n\n\nStartup a shiny app with options in interactive or server mode\n\n\n\n\n\nJan 3, 2019\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nMimic Button Press with Enter Key\n\n\n\nR\n\nShiny\n\nJavascript\n\n\n\nMinic a button press with the Enter key\n\n\n\n\n\nNov 9, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nRestarting a Shiny App\n\n\n\nR\n\nShiny\n\n\n\nForcing a shiny app restart\n\n\n\n\n\nNov 7, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nDatatable Callback in Shiny Module\n\n\n\nR\n\nShiny\n\nShiny Modules\n\n\n\nDatatable Callback in Shiny Module\n\n\n\n\n\nOct 11, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\ncron, python and slack - a beautiful combination\n\n\n\nPython\n\n\n\nTracking Fantasy Football injuries using cron, python and slack\n\n\n\n\n\nAug 5, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nUsing CSS Variables with Shiny\n\n\n\nR\n\nShiny\n\nJavascript\n\n\n\nHow to change a CSS variable in a shiny app\n\n\n\n\n\nJul 13, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nInterrupting a background process: asynchronous shiny\n\n\n\nR\n\nShiny\n\n\n\nHow to Interrupt a long-running background process in Shiny\n\n\n\n\n\nJun 13, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nR 3.5.0 Package Update\n\n\n\nR\n\n\n\nWorking with user and system libraries in R\n\n\n\n\n\nMay 23, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nUsing Redmine with RStudio\n\n\n\nR\n\n\n\nIntegrating Redmine in RStudio\n\n\n\n\n\nFeb 21, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nCode instead of Spreadsheet\n\n\n\nOpinion\n\n\n\nWhy can’t we break the Spreadsheet mold in Science?\n\n\n\n\n\nJan 7, 2018\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nPlotly Error Bar Hack\n\n\n\nR\n\nShiny\n\n\n\nHack to fix error bar issue when using plotly\n\n\n\n\n\nOct 26, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nFancy Headers in Automated Reports\n\n\n\nR\n\nRMarkdown\n\n\n\nCreating a fancy header in an automated markdown report\n\n\n\n\n\nSep 15, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nKEGG and neo4j\n\n\n\nNeo4j\n\n\n\nImporting the KEGG database into neo4j\n\n\n\n\n\nSep 8, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nSQL Server\n\n\n\nR\n\n\n\nConnecting to a SQL Server database\n\n\n\n\n\nAug 10, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nparallel dplyr\n\n\n\nR\n\n\n\nMultidplyr - A parallel version of dplyr\n\n\n\n\n\nMay 24, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nShiny Background Process\n\n\n\nR\n\nShiny\n\n\n\nRunning a background process under Shiny\n\n\n\n\n\nApr 8, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nqueryBuilder\n\n\n\nR\n\nShiny\n\n\n\nAn htmlwidget for jQuery QueryBuilder\n\n\n\n\n\nApr 6, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nRStudio Connect and Databases\n\n\n\nR\n\nRSConnect\n\n\n\nAccessing a shared space from RStudio Connect\n\n\n\n\n\nMar 30, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nChemSymWords\n\n\n\nR\n\nChemistry\n\n\n\nBuilding words using chemical symbols\n\n\n\n\n\nMar 29, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nRapid ANOVA p-value Calculation\n\n\n\nR\n\n\n\nFast calculation of multiple p-values\n\n\n\n\n\nMar 20, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nDatatable Embedded Tables\n\n\n\nR\n\nJavascript\n\n\n\nEmbedding subtables in datatables\n\n\n\n\n\nMar 6, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nIn The Cloud\n\n\n\nOpinion\n\n\n\nI’m now totally cloud-based\n\n\n\n\n\nFeb 21, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nSplit-Apply-Combine\n\n\n\nR\n\n\n\nA complex split-apply-combine procedure run three different ways\n\n\n\n\n\nFeb 6, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nMonitoring Fantasy Football Transfers\n\n\n\nR\n\n\n\nLet me know when there’s an update to the Fantasy Premierleague Player List\n\n\n\n\n\nJan 14, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nManaging Users\n\n\n\nR\n\nShiny\n\n\n\nManaging users in a Shiny App\n\n\n\n\n\nJan 13, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nFantasy football\n\n\n\nR\n\n\n\nOptimizing a fantasy football team\n\n\n\n\n\nJan 9, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nSortable Tables\n\n\n\nR\n\nShiny\n\nJavascript\n\n\n\nSorting rows in a datatable\n\n\n\n\n\nJan 7, 2017\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nR-Notebooks Collapse Button\n\n\n\nR\n\n\n\nAdding an open/collapse button to an R Notebook\n\n\n\n\n\nDec 20, 2016\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nScraping for Dishwashers\n\n\n\nR\n\n\n\nScraping Home Depot to gather dishwasher information (using rvest)\n\n\n\n\n\nNov 24, 2016\n\n\nHarvey\n\n\n\n\n\n\n\n\n\n\n\n\nWhy blog? Why now?\n\n\n\nOpinion\n\n\n\nWhy am I starting to blog now?\n\n\n\n\n\nNov 23, 2016\n\n\nHarvey\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2017/2017-01-13-managing_users/index.html",
    "href": "posts/2017/2017-01-13-managing_users/index.html",
    "title": "Managing Users",
    "section": "",
    "text": "There are several ways that users can be managed in Shiny apps but they all require access to the config file. User access can be managed within the app itself using a database to hold user information. Two examples are given below: The first utilizes a simple database in which the passwords are not encrypted (not recommended for multiple reasons!) The second is very similar but it uses the sodium library to encode the passwords in the database. These are very simplistic examples and contain no functions for password management (such as users being able to change their passwords or password reset) but these would be straight forward to add."
  },
  {
    "objectID": "posts/2017/2017-01-13-managing_users/index.html#user-login---no-encrpytion",
    "href": "posts/2017/2017-01-13-managing_users/index.html#user-login---no-encrpytion",
    "title": "Managing Users",
    "section": "User login - No encrpytion",
    "text": "User login - No encrpytion\nhttps://gist.github.com/harveyl888/a85e17c3048e0da03cf4e6b52d1da3db\n\n## Authentication\n## This is a small app to demonstrate user-managed authentication without encoded passwords.\n## Users are stored in a SQL database with passwords along with roles.  \n## Once a user is logged in the shiny app responds to the user's role.\n## In order to use in a real setting, additional code for password management,\n## changing and resetting would need to be implemented.\n\nlibrary(shiny)\nlibrary(RSQLite)\n\n## create the initial password database\n## This code should be run once to create the initial database of users, passwords and roles\n##\n# db.pw &lt;- data.frame(user = c('Augustin', 'Matt', 'Harvey'), role = c('Manager', 'User', 'User'), password = c('ABC', 'DEF', 'GHI'))\n# db = dbConnect(SQLite(), dbname = 'auth_nohash.sqlite')\n# dbSendQuery(db, 'CREATE TABLE pw (user TEXT, password TEXT, role TEXT)')\n# apply(db.pw, 1, function(x) dbSendQuery(db, paste0('INSERT INTO pw VALUES(\"', x['user'], '\", \"', x['password'], '\", \"', x['role'], '\")')))\n# dbDisconnect(db)\n\n## Connect to the database (may be a remote connection)\ndb = dbConnect(SQLite(), dbname = 'auth_nohash.sqlite')\n\nserver &lt;- function(input, output, session) {\n  \n  ## Initialize - user is not logged in\n  user &lt;- reactiveValues(login = FALSE, name = NULL, role = NULL, header = NULL)\n  \n  ## Display login modal\n  observe({\n    showModal(modalDialog(\n      title = \"Enter Login Details\",\n      textInput('userInp', 'Login'),\n      passwordInput('pwInp', 'Password'),\n      actionButton('butLogin', 'Login', class = 'btn action-button btn-success', icon = icon('sign-in')),\n      size = 's',\n      easyClose = FALSE,\n      footer = NULL\n    ))\n  })\n  \n  ## Check for user in database\n  observeEvent(input$butLogin, {  ## login button pressed\n    req(input$userInp, input$pwInp)  ## ensure we have inputs\n    removeModal()  ## remove the modal\n    pw_out &lt;- dbGetQuery(db, paste0('SELECT password FROM pw WHERE user = \\\"', input$userInp, '\\\"'))  ## query database\n    if (nrow(pw_out) == 0) {  ## user does not exist\n      user$login &lt;- FALSE\n      user$header &lt;- 'ERROR - UNKNOWN USER'\n    } else {\n      pw &lt;- as.character(pw_out$password)[[1]]  ## grab password from database\n      passwordVerified &lt;- pw == input$pwInp  ## check that it matches user input\n      if (passwordVerified) {  ## match\n        user$login &lt;- TRUE\n        user$name &lt;- input$userInp\n        user$role &lt;- db.pw[db.pw$user == input$userInp, 'role']\n        user$header &lt;- paste0(user$name, ' (', user$role, ')')\n      } else {  ## no match\n        user$login &lt;- FALSE\n        user$header &lt;- 'ERROR - INCORRECT PASSWORD'\n      }\n    }\n  })\n  \n  ## close database on exit\n  session$onSessionEnded(function(){\n    dbDisconnect(db)\n  })\n  \n  output$data &lt;- renderUI({\n    h4(user$header)\n  })\n  \n  output$myPlot &lt;- renderPlot({\n    req(user$login)\n    if (user$role == 'Manager') {  ## If manager role, display iris plot\n      plot(iris$Sepal.Length, iris$Sepal.Width)\n    } else {  ## If user role, display mtcars plot\n      plot(mtcars$mpg, mtcars$cyl)\n    }\n  })\n  \n}\n\nui &lt;- fluidPage(\n  uiOutput('data'),\n  plotOutput('myPlot')\n)\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2017/2017-01-13-managing_users/index.html#user-login---with-encrpytion",
    "href": "posts/2017/2017-01-13-managing_users/index.html#user-login---with-encrpytion",
    "title": "Managing Users",
    "section": "User login - With encrpytion",
    "text": "User login - With encrpytion\nhttps://gist.github.com/harveyl888/3e5123a6469fbdc3830123e3efb31a2a\n\n## Authentication\n## This is a small app to demonstrate user-managed authentication using a hash to encode passwords.\n## Users are stored in a SQL database with passwords along with roles.\n## Once a user is logged in the shiny app responds to the user's role.\n## In order to use in a real setting, additional code for password management,\n## changing and resetting would need to be implemented.\n\nlibrary(shiny)\nlibrary(RSQLite)\nlibrary(sodium)\n\n## create the initial password database\n## This code should be run once to create the initial database of users, passwords and roles\n##\n# db.pw &lt;- data.frame(user = c('Augustin', 'Matt', 'Harvey'), role = c('Manager', 'User', 'User'), password = c('ABC', 'DEF', 'GHI'))\n# db.pw$encrypt &lt;- apply(db.pw, 1, function(x) password_store(x['password']))\n# db = dbConnect(SQLite(), dbname = 'auth_hash.sqlite')\n# dbSendQuery(db, 'CREATE TABLE pw (user TEXT, password TEXT, role TEXT)')\n# apply(db.pw, 1, function(x) dbSendQuery(db, paste0('INSERT INTO pw VALUES(\"', x['user'], '\", \"', x['encrypt'], '\", \"', x['role'], '\")')))\n# dbDisconnect(db)\n\n## Connect to the database (may be a remote connection)\ndb = dbConnect(SQLite(), dbname = 'auth_hash.sqlite')\n\nserver &lt;- function(input, output, session) {\n  \n  ## Initialize - user is not logged in\n  user &lt;- reactiveValues(login = FALSE, name = NULL, role = NULL, header = NULL)\n  \n  ## Display login modal\n  observe({\n    showModal(modalDialog(\n      title = \"Enter Login Details\",\n      textInput('userInp', 'Login'),\n      passwordInput('pwInp', 'Password'),\n      actionButton('butLogin', 'Login', class = 'btn action-button btn-success', icon = icon('sign-in')),\n      size = 's',\n      easyClose = FALSE,\n      footer = NULL\n    ))\n  })\n  \n  ## Check for user in database\n  observeEvent(input$butLogin, {  ## login button pressed\n    req(input$userInp, input$pwInp)  ## ensure we have inputs\n    removeModal()  ## remove the modal\n    pw_out &lt;- dbGetQuery(db, paste0('SELECT password FROM pw WHERE user = \\\"', input$userInp, '\\\"'))  ## query database\n    if (nrow(pw_out) == 0) {  ## user does not exist\n      user$login &lt;- FALSE\n      user$header &lt;- 'ERROR - UNKNOWN USER'\n    } else {\n      pw &lt;- as.character(pw_out$password)[[1]]  ## grab password from database\n      passwordVerified &lt;- password_verify(pw, input$pwInp)  ## check that it matches user input\n      if (passwordVerified) {  ## match\n        user$login &lt;- TRUE\n        user$name &lt;- input$userInp\n        user$role &lt;- db.pw[db.pw$user == input$userInp, 'role']\n        user$header &lt;- paste0(user$name, ' (', user$role, ')')\n      } else {  ## no match\n        user$login &lt;- FALSE\n        user$header &lt;- 'ERROR - INCORRECT PASSWORD'\n      }\n    }\n  })\n  \n  ## close database on exit\n  session$onSessionEnded(function(){\n    dbDisconnect(db)\n  })\n  \n  output$data &lt;- renderUI({\n    h4(user$header)\n  })\n  \n  output$myPlot &lt;- renderPlot({\n    req(user$login)\n    if (user$role == 'Manager') {  ## If manager role, display iris plot\n      plot(iris$Sepal.Length, iris$Sepal.Width)\n    } else {  ## If user role, display mtcars plot\n      plot(mtcars$mpg, mtcars$cyl)\n    }\n  })\n  \n}\n\nui &lt;- fluidPage(\n  uiOutput('data'),\n  plotOutput('myPlot')\n)\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2017/2017-03-06-DT_embedded_table/index.html",
    "href": "posts/2017/2017-03-06-DT_embedded_table/index.html",
    "title": "Datatable Embedded Tables",
    "section": "",
    "text": "Here’s an example of how to embed subtables in a datatable. It’s an enhancement of the child rows example found at https://rstudio.github.io/DT/002-rowdetails.html and works by storing JSON versions of subtables as a column in the main table dataframe. The current release of the DT library converts the JSON format into a javascript array which can simply be rendered to an HTML table (DT version 1.x returned a JSON string which must be converted using JSON.parse).\n\n##\n## EmbeddedTable\n## \n## Shiny app demonstrating how to embed subtables into a datatable\n##\n\nlibrary(shiny)\nlibrary(DT)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output) {\n  \n  ## Generate a data frame containing grouped data\n  ## Subtable is included, formatted as JSON\n  df.start &lt;- data.frame(car = row.names(mtcars), mtcars, row.names = NULL, stringsAsFactors = FALSE)\n  l.df &lt;- split(df.start, df.start$carb)\n  l.cars &lt;- lapply(l.df, function(x) list(num = nrow(x),\n                                          max_hp = max(x$hp),\n                                          cyl_range = ifelse(min(x$cyl) == max(x$cyl), min(x$cyl), paste(range(x$cyl), collapse = '-')),\n                                          subTable = toJSON(x)))\n  df &lt;- data.frame(carb = names(l.cars), do.call('rbind', l.cars), stringsAsFactors = FALSE)\n  \n  \n  output$dt1 &lt;- DT::renderDataTable({\n    DT::datatable(mtcars)\n  })\n  \n  ## shiny table output\n  ## datatable with expand/collapse buttons\n  ## on expanding, subtable is rendered from JSON to HTML\n  output$dt &lt;- DT::renderDataTable({\n    df &lt;- cbind(' ' = '&oplus;', df)\n    datatable(\n      df, \n      escape = -2,\n      options = list(\n        dom = 't',\n        columnDefs = list(\n          list(visible = FALSE, targets = c(0, 6)),  \n          list(orderable = FALSE, className = 'details-control', targets = 1)\n        )\n      ),\n      \n      callback = JS(\"\n                    var format = function(d) {\n                      var table = document.createElement('table');\n                      var tableBody = document.createElement('tbody');\n                      var embeddedTableRows = d[6];  // JSON automatically converted to array\n                      var subtable = [];\n                      var arr = [];\n                      $.each(embeddedTableRows, function (index, item) {\n                        arr = [];\n                        $.each(item, function(k, v) {\n                          arr.push(v);\n                        })\n                        subtable.push(arr);\n                      });\n                      \n                      // Add table headers\n                      headers = [];\n                        $.each(embeddedTableRows[0], function(k, v) {\n                        headers.push(k);\n                      })\n                      for(var i=0; i&lt;headers.length; i++){\n                        table.appendChild(document.createElement('th')).\n                        appendChild(document.createTextNode(headers[i]));\n                      }\n                      \n                      // Add table body\n                      for (var i = 0; i &lt; subtable.length; i++) {\n                        var row = document.createElement('tr');\n                        for (var j = 0; j &lt; subtable[i].length; j++) {\n                          var cell = document.createElement('td');\n                          cell.appendChild(document.createTextNode(subtable[i][j]));\n                          cell.style.backgroundColor = 'lightblue';\n                          row.appendChild(cell);\n                        }\n                        tableBody.appendChild(row);\n                      }\n                      table.appendChild(tableBody);\n                      return(table);\n                    };\n                    \n                    // Event handler - expand inner table\n                    table.on('click', 'td.details-control', function() {\n                      var td = $(this), row = table.row(td.closest('tr'));\n                      if (row.child.isShown()) {\n                        row.child.hide();\n                        td.html('&oplus;').css('color', 'green');\n                      } else {\n                        row.child(format(row.data())).show();\n                        td.html('&CircleMinus;').css('color', 'red');\n                      }\n                    });\"\n      ),\n      selection = 'none') %&gt;% \n      formatStyle(1,  color = 'green', fontWeight = 'bold', fontSize = '150%', cursor = 'pointer')\n  })\n}\n\nui &lt;- fluidPage(\n  br(),\n  h4('Example of embedding subtables in a datatable'),\n  br(),\n  DT::dataTableOutput('dt')\n)\n\nshinyApp(server = server, ui = ui)"
  },
  {
    "objectID": "posts/2017/2017-03-20-rapid_anova/index.html",
    "href": "posts/2017/2017-03-20-rapid_anova/index.html",
    "title": "Rapid ANOVA p-value Calculation",
    "section": "",
    "text": "There are times when we need to perform ANOVA calculations on multiple sets of features in order to generate a list of p-values. A traditional approach is to use the base function aov and extract the p-value from it. This can be slow when analyzing thousands of features. An alternative is to use the multtest library and calculate the p-values from the F-values.\nAn example is shown below using a matrix of 20 samples (5 groups of 4) and 10000 features. Calculating p-values within an apply loop takes about 18 seconds. Calculating p-values from the F-values using the multtest library takes about 15 milliseconds. Both were determined on a Z640.\n## create an (g x s) x f matrix where g is the number of groups, s is the number of samples in each group and f is the number of features\ng &lt;- 5\ns &lt;- 4\nf &lt;- 10000\ndf.raw &lt;- replicate(g * s, sample(100:100000, f, rep = TRUE))  ## matrix of data\ngroups &lt;- factor(rep(seq(g), each = s))  ## column ids of groups\n## using an apply loop\nmultAnova1 &lt;- function(df.raw, groups) {\n pVector &lt;- apply(df.raw, 1, function(x) {\n   submodel &lt;- lm(x~groups)\n   subanova &lt;- aov(submodel)\n   summary(subanova)[[1]][['Pr(&gt;F)']][[1]]\n })\n p.adjust(pVector, method='BH')\n}\n\nlibrary(multtest)\n## using multtest\nmultAnova2 &lt;- function(df.raw, groups) {\n F_new &lt;- mt.teststat(df.raw, groups, test='f')\n P_new &lt;- pf(F_new, length(levels(groups))-1, length(groups)-length(levels(groups)), lower.tail = F)\n p.adjust(P_new, method='BH')\n}\n\n## benchmarking\nlibrary(microbenchmark)\nlibrary(ggplot2)\nmb &lt;- microbenchmark(\n multAnova1(df.raw, groups),\n multAnova2(df.raw, groups),\n times = 10\n)\nprint(mb)\nautoplot(mb)\nTiming (milliseconds)\n\n\n\n\n\n\n\n\n\n\n\n\n\nexpr\nmin\nlq\nmean\nmedian\nuq\nmax\nnval\n\n\n\n\nmultAnova1(df.raw, groups)\n17467.11\n17609.23\n18085.73\n17882.93\n18203.27\n19628.12\n10\n\n\nmultAnova2(df.raw, groups)\n13.89\n14.25\n15.66\n15.68\n16.31\n18.72\n10"
  },
  {
    "objectID": "posts/2017/2017-09-08-KEGG_neo4j/index.html",
    "href": "posts/2017/2017-09-08-KEGG_neo4j/index.html",
    "title": "KEGG and neo4j",
    "section": "",
    "text": "The KEGG (Kyoto Encyclopedia of Genes and Genomes) database is a useful reference of biochemical pathways often employed in metabolomics and proteomics studies. Various tables from the database can be downloaded in flat file format via ftp (ftp://ftp.pathway.jp/kegg). In addition, xml files containing information on pathway reactions can be download. Although these provide a useful interface to query properties, the real interest in pathways is in their connectivity.\nOf the KEGG tables, the following are most of interest:\n\nreaction: Information on individual reactions (id tag(entry), reaction name, definition of reaction, equation, list of rclass, pathways on which it can be found, enzyme involved in reaction)\nrclass: Information on different reaction classes (id tag (entry), definition of reaction class, pathways on which it can be found, series of pairs of compounds which undergo the reaction (substrate and product pairs), reactions in which this reaction class can be found)\ncompound: Information on compounds (id tag (entry), name, formula, accurate mass, pathways on which it can be found)\nenzyme: Information on enzymes (id tag (entry), name, reaction in which its involved, substrate and product information, pathways on which it can be found)\n\nThe xml files contain three types of element, namely entry (compounds and enzymes), relation (connections between entries) and *reaction^ (information on reactions between substrates/products).\nThere’s considerable redundancy between the tables and it’s relatively straightforward to create a neo4j database from these pieces of information.\nThe command used to populate the database is simply:\n\"MERGE (c1:Compound{properties}) MERGE (c2:Compound{properties}) CREATE (c1)-[:REACTION{properties}]-&gt;(c2)\"\nwhere properties refer to the properties associated with nodes and relations (in JSON notation).\nTo run this within a transaction it’s:\ntx = graph.begin()\nfor t in triples:\n   mergeText = \"MERGE (c1:Compound{properties}) MERGE (c2:Compound{properties}) CREATE (c1)-[:REACTION{properties}]-&gt;(c2)\"\n   tx.append(mergeText)\ntx.commit()\nreplacing the properies with properties of each reaction.\nThree neo4j databases were constructed, comparing the success and information available in each case.\n\nconstruct from rclass file\nThe most straightforward approach is to use the data stored in the rclass file. Each rclass record contains an identifier (entry) and pairs of molecules which undergo the reaction. The database is constructed by Simply taking the pairs of molecules and constructing a series of merge and create records. This method is successful, however the records do not contain information about the direction of the reaction (A-&gt;B, A&lt;-B, A&lt;-&gt;B).\n\n\n\nMapping Connections\n\n\n\n\nconstruct from xml files\nThe xml files contain data on the nodes (compounds / enzymes) and relationships (reactions). They also include the reaction direction (reversible or irreversible). Once read and parsed, the reaction information can be used to populate the database (cross-referencing to information in additional tables). Upon inspection, however, its apparent that the xml files are missing some connectivity information. Indeed, the files have been constructed to aid in visual interpretation of the data which leads to redundancy and missing information.\n\n\n\n\n\n\nMapping Connections\n\n\n\n\n\n\n\nMapping Reactions\n\n\n\n\n\n\n\nconstruct from reaction and file\nCross-referencing the reaction file with the compound, rclass and enzyme files provides the richest information. Two types of relationships can be constructed here - each individual reaction (multiple connections between each pair of compounds) as well as single points of connection between each pair (equivalent to rclass). This highlights the ability of neo4j to store multiple types of relationship between nodes.\n\n\n\n\n\n\nMapping Connections\n\n\n\n\n\n\n\nMapping Reactions\n\n\n\n\n\nThe code can be found at https://github.com/harveyl888/neo4jKEGG"
  },
  {
    "objectID": "posts/2017/2017-03-29-chemSymWords/index.html",
    "href": "posts/2017/2017-03-29-chemSymWords/index.html",
    "title": "ChemSymWords",
    "section": "",
    "text": "There seems to be a fad right now of merchandising articles containing words made up of chemical symbols. Beryllium Erbium (BeEr) is particularly popular and I have to admit I have a T-Shirt claiming “Call me NErDy”. I’ve put together a small code in R which will check to see if a word can be created purely by element symbols and then output a PNG.\nThe algorithm to turn a word into symbols is fairly straightforward and involves a little recursion. The recursive function is shown below. It comprises of an outer function (chemwordRecurse) and an inner one chemwordRecurseInternal. The output variable (a list) is initialized in the outer function and utilized within the inner one. This allows a single output to be updated which can be a problem when recursion traverses a tree-like pathway as there could be multiple instances of the output. Recall is a way to recursively call using a placeholder as opposed to specifying the function name.\n\nchemWordRecurse &lt;- function(w, t, sym=elements) {\n  out &lt;- list()\n\n  chemWordRecurseInternal &lt;- function(w, t, sym) {\n    if (nchar(w) == 0) {\n      out[[length(out) + 1]] &lt;&lt;- unlist(t)\n    }\n    for (i in 1:min(max(nchar(sym)), nchar(w))) {\n      find_el &lt;- match(toupper(substring(w, 1, i)),toupper(sym))\n      if (!is.na(find_el)) {\n        Recall(substring(w, i + 1), c(t, find_el), sym)\n      }\n    }\n  }\n  chemWordRecurseInternal(w, t, sym)\n  return(out)\n}\n\nAn old stackexchange thread (http://puzzling.stackexchange.com/questions/5456/the-longest-word-made-from-chemical-symbols) challenges the longest word which can be made out of chemical symbols. At the time of this writing it’s Floccinaucinihilipilifications at 30 letters.\n\nThe code can be found at https://github.com/harveyl888/chemSymWords."
  },
  {
    "objectID": "posts/2017/2017-01-09-fantasy_football_optimize/index.html",
    "href": "posts/2017/2017-01-09-fantasy_football_optimize/index.html",
    "title": "Fantasy football",
    "section": "",
    "text": "For the 2016/17 Premiership season some friends set up a fantasy football league for kids to play against their dads. My son wanted his own team but doesn’t know much about Premiership players and their abilities so we decided to look into writing some code to pick a team for him. Our target was to pick a team, within certain constraints, with the potential for scoring the maximum points - sounds a lot like a linear optimization. A quick search led me to a blog entry where this has already been applied and we took this as the basis of our code (all written in R).\nFirst we want a list of the players with some information such as the team they play for and their cost. We’d also like some assessment of how much they are likely to score as this is what we’ll be aiming to maximize. In this case we’ll be using last season’s score. The player list can be easily scraped from the fantasy premierleague site.\n## Read in the current player list\n## This reads in the player list from premierleague.com.\n\nlibrary(rvest)\nlibrary(xml2)\n url &lt;- 'https://fantasy.premierleague.com/player-list/'\n pos &lt;- c('GLK', 'DEF', 'MID', 'FWD')\n tabs &lt;- url %&gt;% read_html() %&gt;% html_nodes('.ism-table') %&gt;% html_table()\n \n for (i in seq_along(tabs)) {\n   tabs[[i]]$Pos &lt;- pos[(i+1) %/% 2]\n }\n df &lt;- dplyr::bind_rows(tabs)\nScraping from the site provides an up to date player list including any additions / subtractions from the beginning of the season as well as the current score. We pulled back the list before the season started which included last season’s score and stored it in a Gist.\ndf &lt;- read.csv('https://gist.githubusercontent.com/harveyl888/269ee507a9dc2939c84bfd1f550a6931/raw/3f4c8986623af7a06831fc51322261e95a350024/playerlist_2016_start.csv', stringsAsFactors = FALSE, check.names = FALSE)\nAt this point we have a data frame that contains player name, team, points scored last season, cost and position. Points scored last season can be used as an approximate indicator of performance this year but what about players who are new to the Premiership? A very crude estimation can be made by assuming that cost is somewhat proportional to points accrued. Of course, every season there are players who under- or over-perform based on their cost and we’re not taking into account random events such as season-ending injuries, but we’ll assume that the gurus at the Premiership have got the price assessment somewhat right and will use this to estimate the new players.\n## Load a few libraries\nlibrary(dplyr)\nlibrary(lpSolve)\nlibrary(formattable)\nlibrary(ggplot2)\n\n## Pull out the numeric cost\ndf$Cost_Val &lt;- as.numeric(substring(df$Cost, 2))\n\n## Define positions\npos &lt;- c('GLK', 'DEF', 'MID', 'FWD')\n\nl.cost &lt;- lapply(pos, function(x) \n  df %&gt;% \n    filter(Pos == x & Points &gt; 0) %&gt;% \n    select(c(Cost_Val, Points))\n)\n\nl.sum &lt;- lapply(l.cost, function(x) \n  summary(lm(x$Points ~ x$Cost_Val))\n)\n\n## Estimate points for new players based on associated cost\ndf$newPoints &lt;- apply(df, \n                      1, \n                      function(x) ifelse(as.numeric(x['Points']) &gt; 0, \n                                         as.numeric(x['Points']), \n                                         as.numeric(l.sum[[match(x['Pos'], pos)]]$coefficients[[2]]) * as.numeric(x['Cost_Val']) + as.numeric(l.sum[[match(x['Pos'], pos)]]$coefficients[[1]])\n                                         ))\n\n## Generate plots\nl.plot &lt;- lapply(pos, function(x) {\n  df %&gt;% filter(Pos == x) %&gt;%\n    mutate(PredPoints = ifelse(Points == 0, newPoints, Points)) %&gt;%\n    mutate(Pred = ifelse(Points == 0, 2, 4)) %&gt;%\n    select(Cost_Val, PredPoints, Pred)\n})\n\nlapply(seq_along(l.plot), function(x) \n  ggplot(l.plot[[x]], aes(x=Cost_Val, y=PredPoints, col=Pred)) + \n  geom_point(aes(size = Pred)) + \n  theme(legend.position = \"none\") +\n  labs(title = paste0('Position = ', pos[x]))\n)\nIn the plots below the red dots represent predicted points for new players based on cost alone.\nNow we have cost and points assigned to each player we can build out linear solver. First we define some constraints. In the fantasy Premierleague game, a squad comprises of 15 players (2 goalkeepers, 5 defenders, 5 midfielders and 3 forwards). The total cost of the squad cannot exceed £100M. These constraints are defined below.\n### Constraints\nnum_gk = 2\nnum_def = 5\nnum_mid = 5\nnum_fwd = 3\nmax_cost = 100\nIn addition, the maximum number of players from any one team is capped at 3. I prefer to stack the odds and bias the squad to teams that, history has shown, are likely to score higher in fantasy football. Finally, several players have been injured prior to the start of the season. These are players that I wouldn’t want to select and so an injury flag of 0 or 1 is added.\n## Add player positions as flag 0 or 1\nfor (p in pos) {\n  df[[p]] &lt;- ifelse(df$Pos == p, 1, 0)\n}\n\n## flag injured players\ndf[['inj']] &lt;- 0\ndf[df$Player %in% c('Bellerín', 'Mertesacker', 'Welbeck', 'Mings', 'Stanislas', 'Mikel',\n                    'Zouma', 'Campbell', 'Sako', 'Besic', 'Browning', 'Pennington', 'Bruce',\n                    'Dawson', 'Maguire', 'McGregor', 'Odubajo', 'Karius', 'Gündogan', 'Ayala',\n                    'Bernardo', 'Husband', 'Leadbitter', 'Bertrand', 'Afellay', 'Ireland',\n                    'Cattermole', 'Kirchhoff', 'Larsson', 'Baston', 'Dja Djédjé', 'Cresswell',\n                    'Lanzini', 'Sakho'), 'inj'] &lt;- 1\n\nteams &lt;- unique(df$Team)\nteam_max &lt;- c(3,3,3,3,3,2,2,2,2,2,2,1,2,1,0,1,0,0,0,1)\ndf.teams &lt;- data.frame(team = unique(df$Team), 'max pick' = team_max)\nNow we’re ready to build our optimizer.\n## Now let's build our constraint matrix\n## The first 4 columns define the player position as either goalkeeper, defender, midfielder \n## or forward.  Players either play in that position (1) or not (0)\n## Column 5 contains the player cost\n## Columns 6-25 cover the team (1 if they player plays for the team and 0 if he does not)\n## The last column contains injury information (0 if healthy and 1 if injured)\nteam_constraint = unlist(lapply(unique(df$Team), function(x, df) {\n  ifelse(df$Team==x, 1, 0)\n}, df=df))\n\nconst_mat = matrix(c(df$GLK, df$DEF, df$MID, df$FWD,\n                     df$Cost_Val, team_constraint, df$inj),\n                   nrow=(6 + length(unique(df$Team))),\n                   byrow=TRUE)\n\n## Next we need to define the righthand side of the constraints.\n## Each of these terms have been defined above.\nconst_rhs = c(num_gk, num_def, num_mid, num_fwd, max_cost, team_max, 0)\n\n## Finally we define the constraint direction.  This defines how the left and righthand sides\n## are related.\n## In this case we hold the number of goalkeepers, defenders, midfielders and forwards constant.\n## The total cost should be less than or equal to max_cost and the number of players per team is\n## less than or equal to each team's maximum.\n## The number of injured players has been set to zero.\nconst_dir &lt;- c(\"=\", \"=\", \"=\", \"=\", rep(\"&lt;=\", 21), '=')\nWe have our optimizer ready. Repeated runs will lead to the same outcome but it’s useful to generate more than one team for comparison therefore we’ll repeat the calculation with a slight jitter to the predicted score.\nnum_repeats &lt;- 100  ## generate 100 teams\n\ndf.rep &lt;- df\nl.out &lt;- list()\nfor (i in seq(num_repeats)) {\n  \n  ## Add a little jitter to the predicted points\n  df.rep$newPoints &lt;- jitter(df.rep$newPoints, factor = 250)\n\n  # Define the vector to optimize against\n  objective = df.rep$newPoints\n\n  ## Perform the optimization\n  x = lp(\"max\", objective, const_mat, const_dir, const_rhs, all.bin=TRUE, all.int=TRUE)\n  \n  ## Get the best solution\n  l.out[[i]] &lt;- arrange(df.rep[which(x$solution==1),], desc(GLK), desc(DEF), desc(MID), desc(FWD), desc(newPoints))\n}\n\n## plot the scores\nplot(sapply(l.out, function(x) sum(x$newPoints)))\nThis generates 100 teams. The predicted scores will generally increase over time due to the fact that we’re starting from an optimized team each time.\nI put this together for my son and he went through the teams, selecting one that appealed to him. We’re around 1/2 way through the season now - how is he doing?\nlibrary(jsonlite)\n\n#leagueID &lt;- ?????\n\n## Get league information\nurl &lt;- paste0('https://fantasy.premierleague.com/drf/leagues-classic-standings/', leagueID, '?phase=1')\nleagueTableData &lt;- fromJSON(url)\nl.man &lt;- leagueTableData$standings$results$entry\n\n## Get team history information\nl.teams &lt;- lapply(l.man, function(x) {\n  Sys.sleep(0.2)\n  url &lt;- paste0('https://fantasy.premierleague.com/drf/entry/', x, '/history')\n  fromJSON(url)\n})\n\n## Put together a table of scores\nl.teamleague &lt;- lapply(seq(l.teams), function(x) {\n  data.frame(team = x, week = l.teams[[x]]$history$event, score = l.teams[[x]]$history$points, total_score = l.teams[[x]]$history$total_points)\n})\n\ndf.teamleague &lt;- bind_rows(l.teamleague)\ndf.teamleague$team &lt;- factor(df.teamleague$team, levels = unique(df.teamleague$team))\ndf.teamleague &lt;- df.teamleague %&gt;% \n  arrange(week, total_score) %&gt;% \n  group_by(week) %&gt;% \n  mutate(rank = 8 - row_number()) %&gt;%\n  arrange(week, rank)\n\nggplot(df.teamleague, aes(x=week, y=score, group=team)) + geom_line(aes(col=team))\nggplot(df.teamleague, aes(x=week, y=total_score, group=team)) + geom_line(aes(col=team))\nggplot(df.teamleague, aes(x=week, y=rank, group=team)) + \n  geom_line(aes(col=team)) + \n  scale_y_reverse(breaks=seq(1,7))\nHe’s doing pretty good! His team is team #1 in the graphs below. At week 8 he took the lead and has manage to hold it. We’re at week 20 so we’ll see how the rest of the season goes. As the season goes on he’s learning more about players but is still at a disadvantage compared to other managers in terms of Premiership knowledge. Next season we’ll work changing the team thoughout the season."
  },
  {
    "objectID": "posts/2017/2017-01-09-fantasy_football_optimize/index.html#update-may-22-2017",
    "href": "posts/2017/2017-01-09-fantasy_football_optimize/index.html#update-may-22-2017",
    "title": "Fantasy football",
    "section": "Update (May 22, 2017)",
    "text": "Update (May 22, 2017)\nOh so close! Jake led up to the penultimate week and was then caught."
  },
  {
    "objectID": "posts/2017/2017-04-08-shiny_background_process/index.html",
    "href": "posts/2017/2017-04-08-shiny_background_process/index.html",
    "title": "Shiny Background Process",
    "section": "",
    "text": "R is a very powerful language but was designed to run single-threaded. There are libraries that will run parallel code but there is no inherent support to run a background process and monitor for completion in the same way that you can in, for example, C++.\nOne way to overcome this is to launch a second instance of R and run the process in the background. If the background process generates a log file it can be monitored within Shiny using the reactivePoll or reactiveFileInput functions. Once completed subsequent action can be taken. The advantage of this method is that the second process is run under a second instance of R and does not interfere with the user interface of the Shiny app.\nBy way of example, there are two apps below. The first attempts to run the process within an observer which ties up the UI – the UI will only respond to changes once the calculation is completed. The second launches a second instance and the UI is not affected – the UI is fully responsive during the calculation."
  },
  {
    "objectID": "posts/2017/2017-04-08-shiny_background_process/index.html#running-as-a-single-process",
    "href": "posts/2017/2017-04-08-shiny_background_process/index.html#running-as-a-single-process",
    "title": "Shiny Background Process",
    "section": "Running as a Single Process",
    "text": "Running as a Single Process\nThe gist for the code can be found at https://gist.github.com/harveyl888/fa6ff9823b9c5a5fff11c946d8e7c9f5\n\n## Data creation\n## \n## Create a large Excel spreadsheet within a Shiny app\n##\n\nlibrary(shiny)\nlibrary(openxlsx)\n\n## Create a dummy matrix\n\nserver &lt;- function(input, output, session) {\n  \n  mydata &lt;- reactiveValues(wb = NULL)\n  status &lt;- reactiveValues(text = 'Waiting')\n  \n  ## Disable download button\n  observe({\n    session$sendCustomMessage('disableButton', 'butDownload')\n  })\n\n  ## Generate Excel output\n  observeEvent(input$butCreate, {\n    session$sendCustomMessage('disableButton', 'butDownload')\n    session$sendCustomMessage('disableButton', 'butCreate')\n    \n    ## Included for comparison - the status text will not update until after the spreadsheet is built\n    status$text &lt;- 'Building'\n    \n    m &lt;- matrix(rexp(input$numRows * input$numCols, rate = 0.1), ncol = input$numCols)\n    \n    wb &lt;- createWorkbook()\n    addWorksheet(wb, 'sheet1')\n    writeData(wb, 'sheet1', m)\n    mydata$wb &lt;&lt;- wb\n    session$sendCustomMessage('enableButton', 'butDownload')\n    session$sendCustomMessage('enableButton', 'butCreate')\n    status$text &lt;- 'Completed'\n  })\n  \n  output$butDownload &lt;- downloadHandler(\n    filename = function() {\n      'output.xlsx'\n    },\n    content = function(file) {\n      showNotification('Writing Excel File')\n      saveWorkbook(mydata$wb, file, overwrite = TRUE)\n    }\n  )\n  \n  output$uiStatus &lt;- renderUI(\n    h4(paste0('STATUS: ', status$text), style=\"color:red;\")\n  )\n\n  output$plt &lt;- renderPlot({\n    hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),\n         xlab = 'Duration (minutes)', main = 'Geyser eruption duration')\n    dens &lt;- density(faithful$eruptions, adjust = input$bw_adjust)\n    lines(dens, col = 'blue')\n  })\n}\n\nui &lt;- fluidPage(\n  singleton(tags$head(HTML('\n    &lt;script type=\"text/javascript\"&gt;\n    $(document).ready(function() {\n      // Enable button\n      Shiny.addCustomMessageHandler(\"enableButton\", function(id) {\n        $(\"#\" + id).removeAttr(\"disabled\");\n      });\n      // Disable button\n      Shiny.addCustomMessageHandler(\"disableButton\", function(id) {\n        $(\"#\" + id).attr(\"disabled\", \"true\");\n      });\n      })\n    &lt;/script&gt;\n    ')\n  )),\n  fluidRow(\n    column(4,\n           wellPanel(\n             fluidRow(\n               column(6, numericInput('numRows', 'Number of Rows', value = 100000, min = 1000, step = 1000)),\n               column(6, numericInput('numCols', 'Number of Columns', value = 50, min = 10, step = 10))\n             )\n           ),\n           fluidRow(\n             column(11, offset = 1,\n                    actionButton('butCreate', 'Create Data', class = 'btn action-button btn-success'),\n                    downloadButton('butDownload', 'Download Data', class = 'btn btn-warning'),\n                    br(),\n                    uiOutput('uiStatus')\n             )\n           )\n    ),\n    column(8,\n           wellPanel(\n             fluidRow(\n               column(4, selectInput('n_breaks', label = 'Number of bins:', choices = c(10, 20, 35, 50), selected = 20)),\n               column(4, sliderInput('bw_adjust', label = 'Bandwidth adjustment:', min = 0.2, max = 2, value = 1, step = 0.2))\n             )\n           ),\n           plotOutput('plt')\n           )\n    )\n  )\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2017/2017-04-08-shiny_background_process/index.html#running-as-an-asynchronous-process",
    "href": "posts/2017/2017-04-08-shiny_background_process/index.html#running-as-an-asynchronous-process",
    "title": "Shiny Background Process",
    "section": "Running as an Asynchronous Process",
    "text": "Running as an Asynchronous Process\nThe gist for the code can be found at https://gist.github.com/harveyl888/bf05d902b10c138a02acd5c9c65fc5da\n\n## Data creation\n## \n## Create a large Excel spreadsheet as a asynchronous process\n##\n\nlibrary(shiny)\n\n## Temporary files to store log, script, rds data and excel output\nlogfile &lt;- tempfile()\nscriptfile &lt;- tempfile()\ndatafile &lt;- tempfile()\nexcelfile &lt;- tempfile()\n\nserver &lt;- function(input, output, session) {\n\n  status &lt;- reactiveValues(text = 'Waiting')\n    \n  ## Disable download button\n  observe({\n    session$sendCustomMessage('disableButton', 'butDownload')\n  })\n  \n  # reactivePoll - look for changes in log file every second\n  logData &lt;- reactivePoll(1000, session,\n                          checkFunc = function() {\n                            if (file.exists(logfile))\n                              file.info(logfile)$mtime[1]\n                            else\n                              ''\n                            },\n                          valueFunc = function() {\n                            if (file.exists(logfile))\n                              readLines(logfile)\n                            else\n                              ''\n                            }\n  )\n\n  ## React to an update in the logfile\n  observe({\n    if (grepl('COMPLETED', logData())) {\n      session$sendCustomMessage('enableButton', 'butDownload')\n      session$sendCustomMessage('enableButton', 'butCreate')\n      status$text &lt;- 'Completed'\n    } \n  })\n\n  ## Generate Excel output\n  ## Once button is pressed create an R Script and run as a second process\n  ## to avoid tying up Shiny\n  observeEvent(input$butCreate, {\n    session$sendCustomMessage('disableButton', 'butDownload')\n    session$sendCustomMessage('disableButton', 'butCreate')\n    status$text &lt;- 'Building'\n\n    m &lt;- matrix(rexp(input$numRows * input$numCols, rate = 0.1), ncol = input$numCols)\n    \n    ## Write data to an rds file\n    saveRDS(m, file = datafile)\n    \n    ## Create script file\n    vfile &lt;- c('library(openxlsx)',\n               paste0('m &lt;- readRDS(\\\"', datafile, '\\\")'),\n               'wb &lt;- createWorkbook()',\n               'addWorksheet(wb, \\\"sheet1\\\")',\n               'writeData(wb, \\\"sheet1\\\", m)',\n               paste0('saveWorkbook(wb, \\\"', excelfile, '\\\", overwrite = TRUE)'),\n               paste0('fileConn &lt;- file(\\\"', logfile, '\\\")'),\n               'writeLines(\\\"COMPLETED\\\", fileConn)',\n               'close(fileConn)'\n               )\n    \n    ## Save script file\n    fileConn &lt;- file(scriptfile)\n    writeLines(vfile, fileConn)\n    close(fileConn)\n    \n    ## Execute script file\n    system(paste0(Sys.getenv('R_HOME'), '/bin/Rscript ', scriptfile), wait = FALSE)\n  })\n  \n  output$butDownload &lt;- downloadHandler(\n    filename &lt;- function() {\n      'excel-out.xlsx'\n    },\n    content &lt;- function(file) {\n      file.copy(excelfile, file)\n    }\n  )\n  \n  output$uiStatus &lt;- renderUI(\n    h4(paste0('STATUS: ', status$text), style=\"color:red;\")\n  )\n  \n  output$plt &lt;- renderPlot({\n    hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),\n         xlab = 'Duration (minutes)', main = 'Geyser eruption duration')\n    dens &lt;- density(faithful$eruptions, adjust = input$bw_adjust)\n    lines(dens, col = 'blue')\n  })\n}\n\nui &lt;- fluidPage(\n  singleton(tags$head(HTML('\n    &lt;script type=\"text/javascript\"&gt;\n    $(document).ready(function() {\n      // Enable button\n        Shiny.addCustomMessageHandler(\"enableButton\", function(id) {\n      $(\"#\" + id).removeAttr(\"disabled\");\n      });\n      // Disable button\n        Shiny.addCustomMessageHandler(\"disableButton\", function(id) {\n      $(\"#\" + id).attr(\"disabled\", \"true\");\n      });\n    })\n    &lt;/script&gt;\n    ')\n  )),\n  fluidRow(\n    column(4,\n           wellPanel(\n             fluidRow(\n               column(6, numericInput('numRows', 'Number of Rows', value = 100000, min = 1000, step = 1000)),\n               column(6, numericInput('numCols', 'Number of Columns', value = 50, min = 10, step = 10))\n             )\n           ),\n           fluidRow(\n             column(11, offset = 1,\n               actionButton('butCreate', 'Create Data', class = 'btn action-button btn-success'),\n               downloadButton('butDownload', 'Download Data', class = 'btn btn-warning'),\n               br(),\n               uiOutput('uiStatus')\n             )\n           )\n    ),\n    column(8,\n           wellPanel(\n             fluidRow(\n               column(4, selectInput('n_breaks', label = 'Number of bins:', choices = c(10, 20, 35, 50), selected = 20)),\n               column(4, sliderInput('bw_adjust', label = 'Bandwidth adjustment:', min = 0.2, max = 2, value = 1, step = 0.2))\n             )\n           ),\n           plotOutput('plt')\n           )\n    )\n  )\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2017/2017-08-10-SQL_server/index.html",
    "href": "posts/2017/2017-08-10-SQL_server/index.html",
    "title": "SQL Server",
    "section": "",
    "text": "Connecting R to a SQL Server can be achieved using the RODBC or RJDBC libraries. Under CentOS this is a little more challenging than Windows and is generally achieved by installing the freeTDS ODBC driver and using the RODBC library. I found compilation a little difficult under CentOS 5.7 and so I moved on to JDBC instead.\nAfter installing the JDBC from https://www.microsoft.com/en-us/download/details.aspx?id=21599 and unpacking to /etc, it was simple to connect to a database as follows:\ndrv &lt;- JDBC(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\", \"/etc/sqljdbc_3.0/enu/sqljdbc4.jar\")\nconn &lt;- dbConnect(drv, 'jdbc:sqlserver://server_address', 'user', 'password')\ndbListTables(conn)"
  },
  {
    "objectID": "posts/2019/2019-01-03-startup_options/index.html",
    "href": "posts/2019/2019-01-03-startup_options/index.html",
    "title": "Shiny app startup options",
    "section": "",
    "text": "Using parseQueryString in conjunction with session$clientData$url_search can be used to pass variables to a shiny app from the url address. It can also be used with Sys.getenv('SHINY_PORT') to follow programming paths based on variable values and execution environment. In the example below, the code points to different instances of a database, depending on user-specification and execution environment. Running locally or on the server points to different default databases and includes the ability to override. This code is useful when placed at the top of an app during development.\n\nlibrary(shiny)\n\n## allowed_databases stores the names of the allowable databases\nallowed_databases &lt;- c('test', 'production', 'uploadtest')\n\n## default database names for interactive and server modes\ndafault_interactive &lt;- 'test'\ndafault_server &lt;- 'production'\n\n## override database defaults for interactive mode\n## to override the default database set override_default_database to TRUE and \n## override_use_database to the database name\noverride_default_database &lt;- FALSE\noverride_use_database &lt;- 'production'\n\nserver &lt;- function(input, output, session) {\n  \n  val &lt;- reactiveValues(db = NULL)\n  \n  db_set_database &lt;- function(name) {\n    val$db &lt;- name\n  }\n  \n  ## set database\n  observe({\n    if(Sys.getenv('SHINY_PORT') == \"\") {\n      ## if running locally then use test database unless override set\n      if (override_default_database) {\n        ## run against specified instance\n        if (!override_use_database %in% allowed_databases) override_use_database &lt;- dafault_interactive\n        db_set_database(override_use_database)\n      } else {\n        ## run against default interactive instance\n        db_set_database(dafault_interactive)\n      }\n    } else {\n      ## if running on server then look for database in url\n      query &lt;- parseQueryString(session$clientData$url_search)\n      if (!is.null(query[['database']])) {\n        ## get database name from url and check that it is in the list of allowed database names\n        my_database &lt;- tolower(query[['database']])\n        if (!my_database %in% allowed_databases) my_database &lt;- dafault_server\n        ## run against selected instance\n        db_set_database(my_database)\n      } else {\n        ## default - run against default server instance\n        db_set_database(dafault_server)\n      }\n    }\n  })\n  \n  output$txt1 &lt;- renderPrint(paste0('Using database ', val$db))\n  \n}\n\nui &lt;- fluidPage(\n  verbatimTextOutput('txt1')\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2019/2019-10-16-towards_lab_iot_02/index.html",
    "href": "posts/2019/2019-10-16-towards_lab_iot_02/index.html",
    "title": "Towards Lab IoT Part Two",
    "section": "",
    "text": "In order to test communication we’ll set up two clients, each representing an instrument, along with a server which acts as the MQTT broker, database and visualization. The three machines are all running ubuntu under VirtualBox.\nIn this case client1 sends measurement1 data which resets to a random value between 20 and 50 when it receives a signal from trigger. client2 sends measurement2 data which resets to 20 when it receives a signal from trigger. The controller monitors measurement1 and signals the trigger when measurement1 is above 50. The controller also updates influxDB with data from measurement1 and measurement2. client1 and client2 represent the two clients, running instruments and the server is controller. Codes for each are below.\n\n\ncontroller (virtual machine 1 - ip address = 10.0.2.15)\n## controller\n## \n## this is the controller code that runs in the background\n## it subscribes to measurement1 and when that value\n## reaches the threshold of 50 it publishes a trigger\n## event that client 1 and client 2 both respond to\n##\n## It also doubles up as the subscriber for the influxDB\n## database which is code that can be run in a separate\n## thread or program\n## \n## publish: trigger1\n## subscribe: measurement1\n## response: if measurement1 &gt; 50 then publish trigger \n \nimport paho.mqtt.client as mqtt\nfrom influxdb import InfluxDBClient\nimport datetime\nimport logging\nimport socket\nimport time\n \nMQTT_BROKER = '10.0.2.15'\nHOSTNAME = socket.gethostname()\nIPADDR = socket.gethostbyname(HOSTNAME)\nINSTRUMENT_ID = 'controller'\nINFLUX_CLIENT = '10.0.2.15'\nINFLUX_DATABASE = 'lab1'\n \n# influxDB\ninflux_client = InfluxDBClient(INFLUX_CLIENT, database = INFLUX_DATABASE)\n \n## define logging file\nFORMAT = '%(asctime)-15s %(clientip)s %(instrumentid)-10s %(message)s'\nlogging.basicConfig(filename = '/home/harvey/controller.log', format = FORMAT, datefmt = '%m/%d/%Y %I:%M:%S %p', level = logging.DEBUG)\nd = {'clientip': IPADDR, 'instrumentid': INSTRUMENT_ID}\n \n# Define the callback to handle CONNACK from the broker, if the connection created normal, the value of rc is 0\ndef on_connect(client, userdata, flags, rc):\n    logging.info(\"Connection returned with result code:\" + str(rc), extra = d)\n \n# Define the callback to hande publish from broker\ndef on_message(client, userdata, msg):\n    # log the response\n    logging.info(\"Received message, topic:\" + msg.topic + \"  payload:\" + str(msg.payload), extra = d)\n    \n    # push to influxDB\n    current_time = datetime.datetime.utcnow().isoformat()\n    topic = msg.topic.split('/')\n    measurement_type = topic[2]\n    json_body = [\n        {\n            \"measurement\": measurement_type,\n            \"tags\": {},\n            \"time\": current_time,\n            \"fields\": {\n                \"value\": int(msg.payload)\n            }\n        }\n    ]\n    influx_client.write_points(json_body)\n \n    # fire the trigger if measurement1 &gt; 50\n    if (msg.topic == 'sensor/expt1/measurement1'):\n        if (int(msg.payload) &gt; 50):\n            client.publish(\"sensor/trigger/client1\", payload = str(msg.payload))\n \n# Callback handles disconnection, log the rc value\ndef on_disconnect(client, userdata, rc):\n    logging.info(\"Disconnection returned with result code:\" + str(rc), extra = d)\n \ndef main():\n \n    # Create an instance of `Client`\n    client = mqtt.Client()\n    client.on_connect = on_connect\n    client.on_disconnect= on_disconnect\n    client.on_message = on_message\n \n    # Connect to broker\n    client.connect(MQTT_BROKER, 1883, 60)\n \n    # Subscribe to all topics and start the loop\n    client.subscribe(\"sensor/+/+\", 0)\n    client.loop_forever()\n \nif __name__ == '__main__':\n    logging.info('Starting Broadcast from ' + INSTRUMENT_ID, extra = d)\n    main()\n\n\nclient1 (virtual machine 2 - ip address = 10.0.2.4)\n## client 1 communications\n## \n## this is an MQTT client code that runs in the background\n## of client 1\n## publish: measurement1\n## subscribe: trigger1\n## response: if trigger1 then reset measurement1 to a \n## random value between 20 and 50\n \nimport paho.mqtt.client as mqtt\nimport logging\nimport socket\nimport random\nimport time\n \nMQTT_BROKER = '10.0.2.15'\nHOSTNAME = socket.gethostname()\nIPADDR = socket.gethostbyname(HOSTNAME)\nINSTRUMENT_ID = 'machine 1'\n \n## define logging file\nFORMAT = '%(asctime)-15s %(clientip)s %(instrumentid)-10s %(message)s'\nlogging.basicConfig(filename = '/home/harvey/client1.log', format = FORMAT, datefmt = '%m/%d/%Y %I:%M:%S %p', level = logging.DEBUG)\nd = {'clientip': IPADDR, 'instrumentid': INSTRUMENT_ID}\n \n# Define the callback to handle CONNACK from the broker, if the connection created normal, the value of rc is 0\ndef on_connect(client, userdata, flags, rc):\n    logging.info(\"Connection returned with result code:\" + str(rc), extra = d)\n \n# Define the callback to hande publish from broker\ndef on_message(client, userdata, msg):\n    global measurement\n    logging.info(\"Received message, topic:\" + msg.topic + \"  payload:\" + str(msg.payload), extra = d)\n    if (msg.topic == 'sensor/trigger/client1'):\n        measurement = random.randrange(20, 50)\n        logging.info(\"Trigger 1: measurement reset to \" + str(measurement), extra = d)\n \n# Callback handles disconnection, log the rc value\ndef on_disconnect(client, userdata, rc):\n    logging.info(\"Disconnection returned with result code:\" + str(rc), extra = d)\n \ndef main():\n \n    # Create an instance of `Client`\n    client = mqtt.Client()\n    client.on_connect = on_connect\n    client.on_disconnect= on_disconnect\n    client.on_message = on_message\n \n    # Connect to broker\n    client.connect(MQTT_BROKER, 1883, 60)\n \n    # initial value of measurement\n    global measurement\n    measurement = 0\n \n    ## start MQTT client loop\n    client.loop_start()\n \n    # Subscribe to a topic\n    client.subscribe(\"sensor/trigger/client1\", 0)\n \n    ## continuously update measurement value every second\n    ## simulates instrument operation\n    while True:\n        client.publish(\"sensor/expt1/measurement1\", payload = measurement)\n        time.sleep(1)\n        measurement += 1\n \n    # Disconnection\n    time.sleep(1) # wait till all messages are processed\n    client.loop_stop()\n    client.disconnect()\n \nif __name__ == '__main__':\n    logging.info('Starting Broadcast from ' + INSTRUMENT_ID, extra = d)\n    main()\n\n\nclient2 (virtual machine 3 - ip address = 10.0.2.5)\n## client 2 communications\n## \n## this is an MQTT client code that runs in the background\n## of client 2\n## publish: measurement2\n## subscribe: trigger1\n## response: if trigger1 then reset measurement2 to 20 \n \nimport paho.mqtt.client as mqtt\nimport logging\nimport socket\nimport time\n \nMQTT_BROKER = '10.0.2.15'\nHOSTNAME = socket.gethostname()\nIPADDR = socket.gethostbyname(HOSTNAME)\nINSTRUMENT_ID = 'machine 2'\n \n## define logging file\nFORMAT = '%(asctime)-15s %(clientip)s %(instrumentid)-10s %(message)s'\nlogging.basicConfig(filename = '/home/harvey/client2.log', format = FORMAT, datefmt = '%m/%d/%Y %I:%M:%S %p', level = logging.DEBUG)\nd = {'clientip': IPADDR, 'instrumentid': INSTRUMENT_ID}\n \n# Define the callback to handle CONNACK from the broker, if the connection created normal, the value of rc is 0\ndef on_connect(client, userdata, flags, rc):\n    logging.info(\"Connection returned with result code:\" + str(rc), extra = d)\n \n# Define the callback to hande publish from broker\ndef on_message(client, userdata, msg):\n    global measurement\n    logging.info(\"Received message, topic:\" + msg.topic + \"  payload:\" + str(msg.payload), extra = d)\n    if (msg.topic == 'sensor/trigger/client1'):\n        measurement = 20\n        logging.info(\"Trigger 1: measurement reset to \" + str(measurement), extra = d)\n \n# Callback handles disconnection, log the rc value\ndef on_disconnect(client, userdata, rc):\n    logging.info(\"Disconnection returned with result code:\" + str(rc), extra = d)\n \ndef main():\n \n    # Create an instance of `Client`\n    client = mqtt.Client()\n    client.on_connect = on_connect\n    client.on_disconnect= on_disconnect\n    client.on_message = on_message\n \n    # Connect to broker\n    client.connect(MQTT_BROKER, 1883, 60)\n \n    ## start MQTT client loop\n    client.loop_start()\n \n    # Subscribe to a topic\n    client.subscribe(\"sensor/trigger/client1\", 0)\n \n    # initial value of measurement\n    global measurement\n    measurement = 0\n \n    ## continuously update measurement value every second\n    ## simulates instrument operation\n    while True:\n        client.publish(\"sensor/expt1/measurement2\", payload = measurement)\n        time.sleep(1)\n        measurement += 1\n \n    # Disconnection\n    time.sleep(1) # wait till all messages are processed\n    client.loop_stop()\n    client.disconnect()\n \nif __name__ == '__main__':\n    logging.info('Starting Broadcast from ' + INSTRUMENT_ID, extra = d)\n    main()\n\n\nVisualization\nRunning all three codes leads to continuous output which updates every second. measurement1 and measurement2 are stored in the InfluxDB under database lab1 which can be visualized using grafana (default = localhost, port 3000).\nmeasurement1 and measurement2 increment every second. When measurement1 reaches 50 it resets itself to a random value between 20 and 50 and resets measurement2 to 20."
  },
  {
    "objectID": "posts/2019/2019-10-16-towards_lot_iot_01/index.html",
    "href": "posts/2019/2019-10-16-towards_lot_iot_01/index.html",
    "title": "Towards Lab IoT Part One",
    "section": "",
    "text": "Chemistry scale-up labs tend to have multiple pieces of equipment connected to a single reactor. These items can work indepentently, co-dependently or fully-dependently with respect to each other. Automated reactors have been in existence for a number of years. These systems can generally collect and store data for a limited number of interfaces and typically work through wired connections. Here I’m documenting the first step towards a fully-functioning internet-of-things (IoT) lab so that multiple reactors can run processes that may be dependent on one another.\nThe final system should allow for the following:\n\nunidirectional and bidirectional communication\nsoftware-managed PID control so that one input can be controlled by another output\nalarms and failsafes - raise an alarm when out of spec and provide the ability to return to a setpoint\ncontinual monitor of connection and checking for disconnect (drop leads to alarm and return to failsage)\ndatabase to store measurements\nvisualization to monitor data\n\nI settled on a few hardware and software solutions to put this into effect. Much of the MQTT and database development was inspired by several thingsmatic blog entries\n\nHardware Solutions\nEach instrument can be controlled by a small controller. The controller should be able to interface with the instrument and publish and receive data. It should run background code that allows it to react to received data. It should also communicate wirelessly via wifi and allow ssh communication. Obvious choice is the Raspberry Pi ZeroW but we could also consider the Adafruit Feather HUZZAH ESP8266 (a little more challenging to add ssh).\n\n\nSoftware Solutions\nI chose to implement MQTT as a protocol. It’s a lightweight messaging protocol that runs over TCP/IP. MQTT works by having clients publish messages through topics to a broker, which manages all the traffic. Clients can also subscribe to any topics, receiving messages from the broker as they arrive. This routes all messages through a central location as well as allowing clients to communicate with each other (via the broker). For IoT data received from multiple sources with time being a key piece of metadata a time series database (in this case InfluxDB) is a suitable choice for data storage. The data can then be displayed in real-time using grafana.\n\n\nTest Sandbox\nI used virtualbox to test the concept. Ultimately I created three ubuntu instances to mimic a server and two remote linux controllers.\n\n\nInstalling software\nInfluxDB and grafana were installed to the server instance and MQTT was installed on the server as well as the two other virtual machines.\n\nInstalling InfluxDB\nAdd the InfluxData repository\nwget -qO- https://repos.influxdata.com/influxdb.key | sudo apt-key add -\nsource /etc/lsb-release\necho \"deb https://repos.influxdata.com/${DISTRIB_ID,,} ${DISTRIB_CODENAME} stable\" | sudo tee /etc/apt/sources.list.d/influxdb.list\nInstall and start the InfluxDB service\nsudo apt-get update && sudo apt-get install influxdb\nsudo service influxdb start\nConfiguration file is located under /etc/influxdb/influxdb.conf\nMost settings are commented out and take the default. Apply the following changes for a simple system:\n# remove data-usage reporting\nreporting-disabled = true\n\n[http]\n  # Determines whether HTTP endpoint is enabled.\n  enabled = true\n\n  # The bind address used by the HTTP service.\n  bind-address = \":8086\"\n\n  # Determines whether user authentication is enabled over HTTP/HTTPS.\n  auth-enabled = false\nLaunch / relaunch with config file\ninfluxd -config /etc/influxdb/influxdb.conf\nsudo service influxd restart -config /etc/influxdb/influxdb.conf\n\n\nTesting InfluxDB\n$ influx  -precision rfc3339  // starts the InfluxDB shell and shows time in rfc3339 format\nConnected to http://localhost:8086 version 1.2.0\nInfluxDB shell version: 1.2.0\n&gt; create database demo        // Creates a new database\n&gt; use demo\nUsing database demo\n&gt; insert mysensor1 value=0.51 // Insert new datapoints\n&gt; insert mysensor1 value=0.53 // for the measurement\n&gt; insert mysensor1 value=0.45 // \"mysensor1\"\n&gt; select * from mysensor1     // Get the whole time series\nname: mysensor1                \ntime                           value\n----                           -----\n2017-02-26T13:33:49.00279827Z  0.51\n2017-02-26T13:33:53.045762633Z 0.53\n2017-02-26T13:33:57.015427575Z 0.45\n\n\nInstalling grafana\nAdd repository\nsudo add-apt-repository \"deb https://packages.grafana.com/oss/deb stable main\"\nwget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add -\nInstall grafana\nsudo apt-get update\nsudo apt-get install grafana\nStart service\nsudo service grafana-server start\nTo start at bootup:\nsudo update-rc.d grafana-server defaults\nThe configuration file is found at /etc/grafana/grafana.ini and we’ll need to enable http protocol before use:\n[server]\n# Protocol (http, https, socket)\nprotocol = http\n\n# The ip address to bind to, empty will bind to all interfaces\n;http_addr =\n\n# The http port  to use\nhttp_port = 3000\nService can be relaunched with\nsudo service grafana-server restart\n\n\nTesting grafana\nConnect database Point browser to http://localhost:3000/ A getting-started guide can be found at https://grafana.com/docs/guides/getting_started/\nlog in (default = admin/admin) and click on “add data source” select InfluxDB as the source and then set the following parameters:\nName: InfluxDB\nHTTP URL: http://10.0.2.15:8086  (obtained from ifconfig command)\nDatabase name: demo\nCreate dashboard Dashboards can be built using “create dashboard”. Add a query that reads\nQuery: sensordata\nFROM default mysensor1 WHERE\nSELECT field(value) mean()\nThe grafana time plot should show data from the Influx database, for example:\n\n\n\nInstalling MQTT\nMQTT (MQ Telemetry Protocol) is a lightweight protocol for communication in IoT devices. In order to utilize it we must install Mosquitto, a message broker that implements the MQTT protocol. Mosquitto is lightweight and is suitable for use on all devices from low power single board computers to full servers.\nMosquitto is available in the Ubuntu repositories:\nsudo apt-get install mosquitto\nsudo apt-get install mosquitto-clients  # Mosquitto cmd line clients (use via bash)\nTesting Mosquitto is running\nservice mosquitto status\n\n\nRunning a test communication between two servers (command line)\nIn order to ensure that each VM has a separate IP address do the following:\n\nVirtualBox control Panel: File -&gt; Preferences -&gt; Network\nselect NAT networks tab and create a new network called “NatNetwork”\nin each VM: Settings -&gt; Network -&gt; Attached to: change to “Nat Network” and select “NatNetwork” from the Name dropdown\nRestart all VMs\n\nThe following lines will create a subscriber on machine 1 which will listen for messages from machine 2 which have a topic starting with message followed by any other sub-topic. More details on how to use the protocol can be found at https://mosquitto.org/\nmachine 1 (ip address = 10.0.2.15)\nmosquitto_sub -h 10.0.2.15 -t 'message/+' &\nlistens for message in background\nmachine 2 (ip address = 10.0.2.4)\nmosquitto_pub -h 10.0.2.15 -t 'message/my_comp' -m 'Hi there'\nPublish message\nIf all works well machine 1 should display ‘Hi there’ each time the mosquitto_pub command is run."
  },
  {
    "objectID": "posts/2019/2019-01-08-crashed_rstudio_session/index.html",
    "href": "posts/2019/2019-01-08-crashed_rstudio_session/index.html",
    "title": "Stopping a crashed RStudio Server Instance",
    "section": "",
    "text": "RStudio Server is a fantastic IDE. Amongst its numerous features is the STOP button which allows execution to be halted. This works well in most instances but there are times when its use can cause a session to hang, in particular when the interrupted code is running a C function (this is a behavior of R rather than RStudio Server). The process can still be stopped through the linux command line, however after running the following command to identify rsessions running under a specific user id (my user id is nm61135n):\nps aux |grep \"rsession.*nm61135n\"\n\nThe output returns the process id along with the rsession identifier allowing the culprit to be shut down using the kill command."
  },
  {
    "objectID": "posts/2019/2019-09-21-star_checkbutton/index.html",
    "href": "posts/2019/2019-09-21-star_checkbutton/index.html",
    "title": "Star Checkbutton",
    "section": "",
    "text": "Here’s a short shiny app along with some css that allows a font-awesome icon to behave as a checkbox. The font-weight setting in the css file determines if the icon should be solid (font-weight = 900 for TRUE) or regular (font-weight = 400 for FALSE).\n\n\ncheckbox.css\n.fancy-checkbox input[type=\"checkbox\"] {\n    display: none;\n}\n \n.fancy-checkbox span:before {\n    content: \"\\f005\"; \n    font-family: \"Font Awesome 5 Free\";\n    font-size: 1.5em;\n    font-style: normal;\n    font-weight: 400;\n    text-decoration: inherit;\n}\n \n.fancy-checkbox input[type=\"checkbox\"]:checked ~ span:before {\n    font-weight: 900;\n}\n\n\napp.R\n\nlibrary(shiny)\n\ncheckboxbutton &lt;- function(inputId, value = FALSE, color = \"#000000\") {\n  \n  if (value) {\n    checked_str &lt;- 'checked=\"checked\"'\n  } else {\n    checked_str &lt;- NULL\n  }\n  inputTag &lt;- HTML(paste0('&lt;input id=\"', inputId, '\" type = \"checkbox\" ', checked_str, '\" /&gt;'))\n  tags$div(class=\"checkbox\",\n           tags$label(NULL, class=\"fancy-checkbox\", style = paste0(\"color: \", color),\n                      inputTag,\n                      tags$span()\n                      )\n           )\n}\n\nserver &lt;- function(input, output, session) {\n  \n  output$txt1 &lt;- renderPrint(\n    input$chk1\n  )\n  \n}\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.3.1/css/all.min.css\"),\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"checkbox.css\")\n  ),\n  br(),\n  fluidRow(\n    column(1, checkboxbutton('chk1', color = \"darkred\")),\n    column(2, verbatimTextOutput('txt1'))\n  )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2019/2019-06-15-app_setup/index.html",
    "href": "posts/2019/2019-06-15-app_setup/index.html",
    "title": "Setting up Shiny Apps - An Opinionated View",
    "section": "",
    "text": "I work with a single server and hence cannot set up a dev, test, prod environment. We also cannot use CI/CD and so I’ve developed a particular way of working under these constraints.\nAll code is stored under a codes folder, residing under the home folder. The folder structure of the app is shown below and subfolders are explained below the image.\n\n\n\nWorking folder contents\n\n\nworking directory contains all the current, development versions of app related files (eg app.R).\nmodules contains all the shiny modules for the application. All work is partitioned into shiny modules for reusability and debugging. I find that, when working with a tabbed application, placing the ui and server logic for each tab in a module makes for easy development (tabs can be easily added, removed or changed).\nrelease is a subfolder containing the latest stable release (see below).\narchive is a subfolder containing the historical release versions (see below).\nreports contains any rmarkdown reports.\nservice is a folder containing an app which displays a service message. This is used in cases when the app is not functioning or an upgrade is in progress (see below).\n\nActive Development\nAll work is performed in the active folder, using git to track changes. Once a version has been completed and tested it is copied to the release folder replacing the current contents. An additional copy is placed in a version subfolder under archive.\n\n\n\nRelease folder contents\n\n\n\n\n\nArchive folder - each subfolder contains an all app-related files\n\n\n\n\n\nExample archive folder contents\n\n\nIn this case, the active folder contains a dev version, release contains the current prod version and archive contains all historical prod versions.\n\n\nLinking\nI run a shiny server pro instance with other users and store apps in a ~/ShinyApps subfolder under home. Each app has its own subfolder and, rather than copy a working version of the app into the subfolder I use a symbolic link to point to the app instance under my codes folder. The prod version points to the release folder, containing the latest release of the app and the dev version points to the app’s active folder. This allows code development and testing on the dev version as other users access the prod version.\n\n\nUpdates and Downtime\nWhen an update needs to be made, or if there’s an issue with the app and a hotfix needs to be applied it can be useful to have a service page informing users of the app’s status. I use a service subfolder containing a shiny app that generates a static webpage to let users know of potential issues. In addition to informing, it can also point to another subfolder under ~/ShinyApps containing a symbolic link to an archived version. This allows users to continue to use the previous version of the app as changes are made. In order to use a service page, the link in the ShinyApps prod subfolder is simply changed from pointing to the release folder to point to the service folder (both contain an app.R file). An example of a service app is shown below.\n\n## \n## Users directed here when PDS_Request or a database are under service\n##\n\nlibrary(shiny)\nlibrary(shinyWidgets)\n\nserver &lt;- function(input, output, session) {\n  \n}\n\nui &lt;- fluidPage(\n  navbarPage('PDS',\n             tabPanel('Under Service',\n                      br(),\n                      fluidRow(\n                        column(6, offset = 3,\n                               panel(status = 'danger', heading = 'UPGRADE',\n                                     h3('PDS_Request application is being upgraded (4/15/2019)', style = 'text-align: center;'),\n                                     h3('Upgrade Should be completed by 14:45 pm', style = 'text-align: center;'),\n                                     br(),\n                                     h4('To continue to use through upgrade please connect through:', style = 'text-align: center;'),\n                                     div(h3(tags$a(href = '&lt;link to previous version&gt;', 'this link'), style = 'text-align: center;'))\n                               )\n                        )\n                      )\n             )\n  )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-05-10-email_R/index.html",
    "href": "posts/2021/2021-05-10-email_R/index.html",
    "title": "Emailing under Windows using R",
    "section": "",
    "text": "Programatically sending an email under Linux is relatively simple. There are several command line clients such as sendmail and mail which are very easy to use. There are also several R packages to help send emails such as {mailr} and {blastula}.\nGenerally you need access to an SMTP to send messages programatically and this may not be possible in a work setting.\nHere’s a simple R function to send an email under Windows. It uses vbs scripting to send an email via the Outlook client itself, without needing server parameters.\n\n#' Send an email with attachments\n#'\n#' Sends an email to a recipient using vbs scripting.\n#' `body` contains the body of the email and `files` contains a list of files\n#' to attach.\n#'\n#' @param to Recipient email address\n#' @param subject Subject line\n#' @param body Body text\n#' @param files List of files to attach\n#'\n#' @export\nlc_send_email &lt;- function(to = NULL, subject = \"\", body = \"\", files = list()) {\n\n  if (is.null(to)) return(NULL)\n\n  if (length(files) &gt; 0) {\n    v.files &lt;- unlist(sapply(files, function(f) {\n      paste0('myAttachments.Add \"', normalizePath(f), '\", olByValue')\n    }))\n  } else {\n    v.files &lt;- ''\n  }\n\n  ## build a vbs script to send an email to user\n  v.outlook_commands &lt;- c(\n    'Dim olApp',\n    'Dim objMailItem',\n    'Dim myAttachments',\n    'Set olApp = CreateObject(\"Outlook.Application\")',\n    'Set objMailItem = olApp.CreateItem(0)',\n    'Set myAttachments = objMailItem.Attachments',\n    paste0('objMailItem.Subject = \"', subject, '\"'),\n    paste0('objMailItem.To = \"', to, '\"'),\n    paste0('objMailItem.Body = \"', body, '\"'),\n    v.files,\n    'objMailItem.Send',\n    'Set olApp = Nothing',\n    'Set objMailItem = Nothing'\n  )\n\n  ## write script to temporary location\n  script_file &lt;- tempfile(fileext = '.vbs')\n  sink(script_file, append = FALSE)\n  cat(v.outlook_commands, sep='\\n')\n  sink()\n\n  ## execute script\n  system_script &lt;- paste0('WScript ', normalizePath(script_file))\n  system(system_script)\n\n}"
  },
  {
    "objectID": "posts/2021/2021-06-02-reactivity/index.html",
    "href": "posts/2021/2021-06-02-reactivity/index.html",
    "title": "Shiny Reactivity",
    "section": "",
    "text": "Examples of passing a list of reactives, reactiveValues list and reactiveValues to a shiny module. This helps explain reactivity when passing values to a shiny module. In each case we pass a value A which triggers mod A and value B which triggers mod B. The code below and output demonstrates which outputs in the shiny module are updated upon changing a value in the main app."
  },
  {
    "objectID": "posts/2021/2021-06-02-reactivity/index.html#example-1---list-of-reactives",
    "href": "posts/2021/2021-06-02-reactivity/index.html#example-1---list-of-reactives",
    "title": "Shiny Reactivity",
    "section": "Example 1 - List of Reactives",
    "text": "Example 1 - List of Reactives\nPass two reactives (react_A and react_B) to a shiny module. react_A is attached to a reactiveVal and initially set to A. react_B is a reactive set to B. react_A is then changed to C by changing the reactiveVal.\nIn this setup react_A and react_B are sent to the shiny module when it is called. react_A is updated which triggers an update of the module.\nOutput to the console is:\n[1] \"response from module A: A\"\n[1] \"response from module B: B\"\n[1] \"response from module A: C\"\n\n## checking reactivity - reactive list vs list of reactives\n## list of reactives\nlibrary(shiny)\n\n## module UI\nmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    uiOutput(ns(\"modA\")),\n    uiOutput(ns(\"modB\"))\n  )\n}\n\n## module server\nmod &lt;- function(id, inputvar) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      output$modA &lt;- renderUI({\n        req(inputvar$A())\n        print(paste0(\"response from module A: \", inputvar$A()))\n        h3(paste0(\"response from module A: \", inputvar$A()))\n      })\n      \n      output$modB &lt;- renderUI({\n        req(inputvar$B())\n        print(paste0(\"response from module B: \", inputvar$B()))\n        h3(paste0(\"response from module B: \", inputvar$B()))\n      })\n    }\n  )\n}\n\nui &lt;- fluidPage(\n\n  mod_UI(\"shinymod\")\n\n)\n\nserver &lt;- function(input, output, session) {\n\n  rv &lt;- reactiveVal(\"A\")\n\n  react_A &lt;- reactive({\n    rv()\n  })\n\n  react_B &lt;- reactive({\n    \"B\"\n  })\n\n  mod(\"shinymod\", inputvar = list(A = reactive(react_A()), B = reactive(react_B())))\n\n  ## Update rv$A triggers refresh of modA in shiny module but not modB\n  observe({\n    rv(\"C\")\n  })\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-02-reactivity/index.html#example-2---reactivevalues-list",
    "href": "posts/2021/2021-06-02-reactivity/index.html#example-2---reactivevalues-list",
    "title": "Shiny Reactivity",
    "section": "Example 2 - ReactiveValues List",
    "text": "Example 2 - ReactiveValues List\nPass a reactiveValue, rv$AB containing a list of two members (A = A and B = B) to a shiny module. One member of rv$AB is then changed so that rv$AB contains A = C and B = B.\nIn this setup rv$AB is sent to the shiny module when it is called. rv$AB is updated which triggers an update of the module.\nOutput to the console is:\n[1] \"response from module A: A\"\n[1] \"response from module B: B\"\n[1] \"response from module A: C\"\n[1] \"response from module B: B\"\nHere it is clear that updating the reactiveValue triggers two updates - one for the first list member (which changed) and one for the second (which did not). This is a highly inefficient way of passing data to a module.\n\n## checking reactivity - reactive list vs list of reactives\n## reactiveValue\nlibrary(shiny)\n\n## module UI\nmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    uiOutput(ns(\"modA\")),\n    uiOutput(ns(\"modB\"))\n  )\n}\n\n## module server\nmod &lt;- function(id, inputvar) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      \n      output$modA &lt;- renderUI({\n        req(inputvar()$A)\n        print(paste0(\"response from module A: \", inputvar()$A))\n        h3(paste0(\"response from module A: \", inputvar()$A))\n      })\n      \n      output$modB &lt;- renderUI({\n        req(inputvar()$B)\n        print(paste0(\"response from module B: \", inputvar()$B))\n        h3(paste0(\"response from module B: \", inputvar()$B))\n      })\n  \n    }\n  )\n}\n\n\nui &lt;- fluidPage(\n\n  mod_UI(\"shinymod\")\n\n)\n\nserver &lt;- function(input, output, session) {\n\n  rv &lt;- reactiveValues(\n    AB = list()\n  )\n\n  observe({\n    rv$AB &lt;- list(A = \"A\", B = \"B\")\n  })\n\n  mod(\"shinymod\", inputvar = reactive(rv$AB))\n\n  ## Update rv$AB triggers refresh of modA and modB in shiny module\n  observe({\n    rv$AB &lt;- list(A = \"C\", B = \"B\")\n  })\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-02-reactivity/index.html#example-3---reactivevalues",
    "href": "posts/2021/2021-06-02-reactivity/index.html#example-3---reactivevalues",
    "title": "Shiny Reactivity",
    "section": "Example 3 - ReactiveValues",
    "text": "Example 3 - ReactiveValues\nPass a set of reactiveValues, rv containing two elements (A = A and B = B) to a shiny module. Change one element (A = C). In this setup rv is sent to the shiny module when it is called. rv is updated which triggers an update of the module.\nOutput to the console is:\n[1] \"response from module A: A\"\n[1] \"response from module B: B\"\n[1] \"response from module A: C\"\n\n## checking reactivity - reactive list vs list of reactives\n## reactiveValues\nlibrary(shiny)\n\nmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    uiOutput(ns(\"modA\")),\n    uiOutput(ns(\"modB\"))\n  )\n}\n\n## module server\nmod &lt;- function(id, inputvar) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      \n      output$modA &lt;- renderUI({\n        req(inputvar()$A)\n        print(paste0(\"response from module A: \", inputvar()$A))\n        h3(paste0(\"response from module A: \", inputvar()$A))\n      })\n      \n      output$modB &lt;- renderUI({\n        req(inputvar()$B)\n        print(paste0(\"response from module B: \", inputvar()$B))\n        h3(paste0(\"response from module B: \", inputvar()$B))\n      })\n  \n    }\n  )\n}\n\nui &lt;- fluidPage(\n\n  mod_UI(\"shinymod\")\n\n)\n\nserver &lt;- function(input, output, session) {\n\n  rv &lt;- reactiveValues(\n    A = \"A\",\n    B = \"B\"\n  )\n\n  mod(\"shinymod\", inputvar = reactive(rv))\n\n  ## Update rv$A triggers refresh of modA in shiny module\n  observe({\n    rv$A &lt;- \"C\"\n  })\n\n  ## Update rv$B does not trigger refresh of modB in shiny module (no change to rv$B)\n  observe({\n    rv$B &lt;- \"B\"\n  })\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html",
    "title": "{distill} Contact Form",
    "section": "",
    "text": "Can we use use RStudio Connect to build an internal contact form on a {distill} website?\n{distill} is a great R library for building static websites and blogs but has the same limitations of other static websites, namely no server-side programming. This means that implementing a contact form requires using a third party service. This can, however, be accomplished when hosting via RStudio Connect using a plumber API."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#purpose",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#purpose",
    "title": "{distill} Contact Form",
    "section": "",
    "text": "Can we use use RStudio Connect to build an internal contact form on a {distill} website?\n{distill} is a great R library for building static websites and blogs but has the same limitations of other static websites, namely no server-side programming. This means that implementing a contact form requires using a third party service. This can, however, be accomplished when hosting via RStudio Connect using a plumber API."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#attempt-1",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#attempt-1",
    "title": "{distill} Contact Form",
    "section": "Attempt 1",
    "text": "Attempt 1\nThis first attempt works but since we are using a POST request a response is always returned. This means that the webpage is updated with either a null or whatever has been returned by the API function. The output consists of three files with a {distill} R website:\n\nindex.Rmd - a markdown file to hold the contact form\ncontact_form.html - an html contact form that can be inserted into a markdown page\nstyle.css - some css styling (pulled from w3schools)\n\nand a plumber API:\n\nplumber.R - a plumber API\n\nBoth the {distill} static site and plumber API are published to the same RStudio Connect instance.\n\nplumber.R\nThe plumber API takes parameters from a contact form and constructs a linux mail command line, sending a message to a mailbox. The API contains a single POST request to /email.\n\nlibrary(plumber)\n\n#* @apiTitle Email\n\n#* Send out an email message\n#* @param email return email address\n#* @param name sender name\n#* @param subject email subject\n#* @param message email message\n#* @param to recipient email address\n#* @post /email\nfunction(email = NULL, name = NULL, subject = NULL, message = NULL, to = NULL) {\n  \n  ## need a recipient to send an email\n  if (!is.null(to)) {\n    \n    if (is.null(message)) {\n      message &lt;- \"\"\n    } else {\n      message &lt;- gsub(\"\\\\r\", \"\", message)\n    }\n    \n    ## add sender's name\n    if (!is.null(name)) {\n      message &lt;- paste0(message, \"\\n\\nFrom: \", name)\n    }\n    \n    ## build up email string\n    email_string &lt;- \"echo -e \"\n    email_string &lt;- paste0(email_string, \"\\\"\", message, \"\\\" | mail \")\n    \n    if (!is.null(subject)) {\n      email_string &lt;- paste0(email_string, \"-s \\\"\", subject, \"\\\" \")\n    } else {\n      email_string &lt;- paste0(email_string, \"-s \\\"no subject\\\" \")\n    }\n    \n    if (!is.null(email)) {\n      email_string &lt;- paste0(email_string, \"-S from=\", email, \" \")\n    }\n    \n    email_string &lt;- paste0(email_string, to)\n    \n    system(email_string)\n    return(email_string)\n  }\n}\n\n\n\nindex.Rmd\n\n---\ntitle: \"Test Contact 1\"\n---\n\n```{r, echo=FALSE}\nhtmltools::includeCSS(\"style.css\")\n\nhtmltools::includeHTML(\"contact_form.html\")\n```\n\n\n\ncontact_form.html\n&lt;div class=\"form-container\"&gt;\n  &lt;form action=\"*url pointing to API*\" id=\"my-form\" method=\"POST\"&gt;\n    \n    &lt;label for=\"name\"&gt;Name&lt;/label&gt;\n    &lt;input type=\"text\" id=\"name\" name=\"name\" placeholder=\"Your name..\"&gt;\n    \n    &lt;label for=\"email\"&gt;Email&lt;/label&gt;\n    &lt;input type=\"text\" id=\"email\" name=\"email\" placeholder=\"Your email address..\"&gt;\n      \n    &lt;label for=\"subject\"&gt;Subject&lt;/label&gt;\n    &lt;input type=\"text\" id=\"subject\" name=\"subject\" placeholder=\"Subject\"&gt;\n                \n    &lt;label for=\"message\"&gt;Message&lt;/label&gt;\n    &lt;textarea id=\"message\" name=\"message\" placeholder=\"Your message..\" style=\"height:200px\"&gt;&lt;/textarea&gt;\n  \n    &lt;input type=\"hidden\" name=\"to\" value=\"*mailbox*\" /&gt;\n                    \n    &lt;input type=\"submit\" value=\"Submit\"&gt;\n  \n  &lt;/form&gt;\n&lt;/div&gt;\nIn the contact_form.html file, url pointing to API (line 2) refers to the url of the plumber API, hosted on the same RStudio Connect server as the distill site. mailbox (line 16) refers to the receiving mailbox. It is included as a hidden element in the form so that it may be passed to the API."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#style.css",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#style.css",
    "title": "{distill} Contact Form",
    "section": "style.css",
    "text": "style.css\ninput[type=text], select, textarea {\n  width: 100%; /* Full width */\n  padding: 12px; /* Some padding */ \n  border: 1px solid #ccc; /* Gray border */\n  border-radius: 4px; /* Rounded borders */\n  box-sizing: border-box; /* Make sure that padding and width stays in place */\n  margin-top: 6px; /* Add a top margin */\n  margin-bottom: 16px; /* Bottom margin */\n  resize: vertical /* Allow the user to vertically resize the textarea (not horizontally) */\n}\n\n/* Style the submit button with a specific background color etc */\ninput[type=submit] {\n  background-color: #04AA6D;\n  color: white;\n  padding: 12px 20px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n/* When moving the mouse over the submit button, add a darker green color */\ninput[type=submit]:hover {\n  background-color: #45a049;\n}\n\n/* Add a background color and some padding around the form */\n.form-container {\n  border-radius: 5px;\n  background-color: #f2f2f2;\n  padding: 20px;\n}"
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#attempt-2",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#attempt-2",
    "title": "{distill} Contact Form",
    "section": "Attempt 2",
    "text": "Attempt 2\nThe second attempt builds on the first. Here the submit button is intercepted by a little javascript function which executes the POST request and captures the output. Running this way means that the webpage does not update once the request is run. In addition, we can trigger notification that the form was sent (in this case a simple alert).\nHere we have four files with a {distill} R website:\n\nindex.Rmd - a markdown file to hold the contact form\ncontact_form.html - an html contact form that can be inserted into a markdown page\nstyle.css - some css styling (pulled from w3schools)\nscript.js - javascript function to intercept the submit button press\n\nand a plumber API:\n\nplumber.R - a plumber API\n\nBoth the {distill} static site and plumber API are published to the same RStudio Connect instance.\n\nplumber.R\nThe plumber API differs from the one in Attempt 1 by reading a json encoded version of the body. The API contains a single POST request to /email.\n\nlibrary(plumber)\nlibrary(jsonlite)\n\n#* @apiTitle Email\n\n#* Send out an email message\n#* @param req request body\n#* @post /email\nfunction(req) {\n  \n  ## get the message body\n  body &lt;- jsonlite::fromJSON(req$postBody)\n  \n  email &lt;- body$email\n  name &lt;- body$name\n  subject &lt;- body$subject\n  to &lt;- body$to\n  message &lt;- body$message\n  \n  ## need a recipient to send an email\n  if (!is.null(to)) {\n    \n    if (is.null(message)) {\n      message &lt;- \"\"\n    } else {\n      message &lt;- gsub(\"\\\\r\", \"\", message)\n    }\n    \n    ## add sender's name\n    if (!is.null(name)) {\n      message &lt;- paste0(message, \"\\n\\nFrom: \", name)\n    }\n    \n    ## build up email string\n    email_string &lt;- \"echo -e \"\n    email_string &lt;- paste0(email_string, \"\\\"\", message, \"\\\" | mail \")\n    \n    if (!is.null(subject)) {\n      email_string &lt;- paste0(email_string, \"-s \\\"\", subject, \"\\\" \")\n    } else {\n      email_string &lt;- paste0(email_string, \"-s \\\"no subject\\\" \")\n    }\n    \n    if (!is.null(email)) {\n      email_string &lt;- paste0(email_string, \"-S from=\", email, \" \")\n    }\n    \n    email_string &lt;- paste0(email_string, to)\n    \n    system(email_string)\n    return(email_string)\n  }\n}\n\n\n\nindex.Rmd\nThe markdown file is very similar to the original, with an additional line to include the javascript file.\n\n---\ntitle: \"Test Contact 1\"\n---\n\n```{r, echo=FALSE}\nhtmltools::includeCSS(\"style.css\")\nhtmltools::includeScript(\"script.js\")\n\nhtmltools::includeHTML(\"contact_form.html\")\n```\n\n\n\ncontact_form.html\nThe contact form does not change significantly from the original, the only difference being the removal of method=“POST” in the form element.\n&lt;div class=\"form-container\"&gt;\n  &lt;form action=\"*url pointing to API*\" id=\"my-form\"&gt;\n    \n    &lt;label for=\"name\"&gt;Name&lt;/label&gt;\n    &lt;input type=\"text\" id=\"name\" name=\"name\" placeholder=\"Your name..\"&gt;\n    \n    &lt;label for=\"email\"&gt;Email&lt;/label&gt;\n    &lt;input type=\"text\" id=\"email\" name=\"email\" placeholder=\"Your email address..\"&gt;\n      \n    &lt;label for=\"subject\"&gt;Subject&lt;/label&gt;\n    &lt;input type=\"text\" id=\"subject\" name=\"subject\" placeholder=\"Subject\"&gt;\n                \n    &lt;label for=\"message\"&gt;Message&lt;/label&gt;\n    &lt;textarea id=\"message\" name=\"message\" placeholder=\"Your message..\" style=\"height:200px\"&gt;&lt;/textarea&gt;\n  \n    &lt;input type=\"hidden\" name=\"to\" value=\"*mailbox*\" /&gt;\n                    \n    &lt;input type=\"submit\" value=\"Submit\"&gt;\n  \n  &lt;/form&gt;\n&lt;/div&gt;\nIn the contact_form.html file, url pointing to API (line 2) refers to the url of the plumber API, hosted on the same RStudio Connect server as the distill site. mailbox (line 16) refers to the receiving mailbox. It is included as a hidden element in the form so that it may be passed to the API."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#style.css-1",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#style.css-1",
    "title": "{distill} Contact Form",
    "section": "style.css",
    "text": "style.css\nNo change to the style.css file."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#script.js",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#script.js",
    "title": "{distill} Contact Form",
    "section": "script.js",
    "text": "script.js\n\nwindow.addEventListener(\"load\", function() {\n\n  document.getElementById(\"my-form-2\").addEventListener(\"submit\", formsubmit);\n\n  async function formsubmit(e) {\n    \n    e.preventDefault();\n    \n    // get event-handler element\n    const form = e.currentTarget;\n    \n    // get form url\n    const url = form.action;\n    \n    // get form data as json string\n    formdata = new FormData(form);\n    const plainFormData = Object.fromEntries(formdata.entries());\n    const jsonFormData = JSON.stringify(plainFormData);\n    \n    // send request and capture output\n    out = await fetch(form.action, {\n      method: 'POST',\n      body: jsonFormData,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n      }\n    });\n    \n    // notification of sent message\n    alert(\"message sent to \" + plainFormData.to);\n\n  }\n\n});\n\nin this case we have a contact form which sends a message to an email inbox. A simple alert confirms that the form has been intercepted and an email sent. The contact form looks as follows:"
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "",
    "text": "An earlier post described a multiwindow shiny app that demonstrated how three shiny apps could be handled by a fourth with data passing between them. This extends the concept, running all apps on RStudio Connect and manages the communication using the {pins} library. Data is passed between the apps using a json file attached to a pin on an RStudio Connect board. When the app is exited, the pin is deleted."
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html#launcherapp.r",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html#launcherapp.r",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "launcher/app.R",
    "text": "launcher/app.R\n\n## App lauuncher\n## This app manages all others\n\n\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(stringi)\nlibrary(pins)\n\nserver &lt;- function(input, output, session) {\n  \n  ## register board\n  pins::board_register_rsconnect(\"HL_board\", account = \"liebeha1\")\n\n  ## create a pin name\n  pin_name &lt;- stringi::stri_rand_strings(1, length = 8)\n  \n  url_base &lt;- ** RSTUDIO CONNECT URL **\n  \n  ## define app windows\n  app_windows &lt;- data.frame(\n    name = c(\"app_options\", \"app_graphics\", \"app_details\"),\n    app = c(\"447\", \"448\", \"449\"),\n    launch_delay = c(0, 2000, 0),\n    height = c(0.25, 0.4, 0.25),\n    width = c(0.095, 0.2, 0.095),\n    left = c(0.02, 0.02, 0.125),\n    top = c(0.02, 0.33, 0.02),\n    closable = c(TRUE, TRUE, TRUE),\n    stringsAsFactors = FALSE\n  )\n  app_windows$url &lt;- paste0(url_base, app_windows$app, \"/?pin=\", pin_name)\n  \n  ## launch all apps\n  for (i in 1:nrow(app_windows)) {\n    Sys.sleep(app_windows[i, ]$launch_delay / 1000)\n    session$sendCustomMessage(\"launch_app\", app_windows[i, ])\n  }\n  \n  observe({\n    req(!is.null(input$txt_com_file))\n    session$sendCustomMessage(\"disable\", \"txt_com_file\")\n  })\n  \n  output$ui_communications &lt;- renderUI({\n    column(10, offset = 1, textInput(\"txt_com_file\", label = \"Pin ID\", width = \"100%\", value = pin_name))\n  })\n  \n  \n  \n  # app_options ------------------------------------------------------------------\n  \n  \n  ## options UI\n  output$ui_app_options &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_options\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: setting options\")),\n      column(2, offset = 1, actionBttn(\"but_close_all\", label = \"Close All\", style = \"simple\", color = \"warning\", size = \"sm\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_options))\n    if (!app_windows[1, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_options\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_options, {\n    if (input$swt_app_options == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[1, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[1, ])\n    }\n  })\n  \n  # app_graphics ------------------------------------------------------------------\n  \n  \n  ## graphics UI\n  output$ui_app_graphics &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_graphics\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: plotting graphics\")),\n      column(2, offset = 1, actionBttn(\"but_exit\", label = \"EXIT\", style = \"simple\", color = \"danger\", size = \"sm\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_graphics))\n    if (!app_windows[2, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_graphics\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_graphics, {\n    if (input$swt_app_graphics == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[2, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[2, ])\n    }\n  })\n  \n  # app_details ------------------------------------------------------------------\n  \n  \n  ## details UI\n  output$ui_app_details &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_details\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: setting details\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_details))\n    if (!app_windows[3, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_details\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_details, {\n    if (input$swt_app_details == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[3, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[3, ])\n    }\n  })\n  \n  ## close all apps\n  observeEvent(input$but_close_all, {\n    for (i in 1:nrow(app_windows)) {\n      session$sendCustomMessage(\"close_app\", app_windows[i, ])\n    }\n  })\n  \n  \n  ## exit application\n  observeEvent(input$but_exit, {\n    \n    ## remove pin\n    pins::pin_remove(name = pin_name, board = \"HL_board\")\n\n    ## close all windows\n    for (i in 1:nrow(app_windows)) {\n      session$sendCustomMessage(\"close_app\", app_windows[i, ])\n    }\n    \n    ## close window and finish\n    shiny::stopApp()\n    \n  })\n  \n  \n}\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(type = \"text/javascript\", src = \"script.js\")\n  ),\n  br(),\n  br(),\n  fluidRow(column(10, offset = 1, \n                  panel(status = \"primary\", heading = \"App Launcher\",\n                        panel(status = \"danger\", heading = \"Communications\",\n                              uiOutput(\"ui_communications\")\n                        ),\n                        br(),\n                        panel(status = \"danger\", heading = \"App Windows\",\n                              fluidRow(uiOutput(\"ui_app_options\")),\n                              fluidRow(uiOutput(\"ui_app_graphics\")),\n                              fluidRow(uiOutput(\"ui_app_details\"))\n                        )\n                  )\n  ))\n)\n\nshinyApp(ui = ui, server = server)\n\nIn this code, app_windows holds parameters for the three app windows. Two new parameters are included compared to the original version. app now holds the RStudio Connect app refernce number which is used to execute the app and launch_delay is a delay in milliseconds to wait before starting an app - it’s used to ensure that the pin exists before starting the second app."
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html#launcherwwwscript.js",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html#launcherwwwscript.js",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "launcher/www/script.js",
    "text": "launcher/www/script.js\n\nvar shiny_app_options = \"\";\nvar shiny_app_graphics = \"\";\nvar shiny_app_details = \"\";\n\n// launch a shiny app\nShiny.addCustomMessageHandler('launch_app', function(x) {\n  scr_height = window.screen.height;\n  scr_width = window.screen.width;\n  window_height = scr_height * x.height;\n  window_width = scr_width * x.width;\n  window_left = scr_width * x.left;\n  window_top = scr_height * x.top;\n  window_options = \"height=\" + window_height + \", width=\" + window_width + \", left=\" + window_left + \", top=\" + window_top;\n  \n  if (x.name == \"app_options\") {\n    shiny_app_options = window.open(x.url, x.name, window_options);\n  } else if (x.name == \"app_graphics\") {\n    shiny_app_graphics = window.open(x.url, x.name, window_options);\n  } else if (x.name == \"app_details\") {\n    shiny_app_details = window.open(x.url, x.name, window_options);\n  }\n});\n\n// close a shiny app\nShiny.addCustomMessageHandler('close_app', function(x) {\n  // can't pass window name as variable to close so have to hardcode :(\n  if (x.name == \"app_options\") {\n    shiny_app_options.close();\n  } else if (x.name == \"app_graphics\") {\n    shiny_app_graphics.close();\n  } else if (x.name == \"app_details\") {\n    shiny_app_details.close();\n  }\n});\n\n// disable a shiny input\nShiny.addCustomMessageHandler('disable', function(id) {\n  var input_type = $(\"#\" + id).prop(\"type\");\n  if (input_type.startsWith(\"select\")) {\n    $(\"#\" + id)[0].selectize.disable();\n  } else {\n    $(\"#\" + id).prop(\"disabled\", true);\n  }\n});"
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html#app_optionsapp.r",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html#app_optionsapp.r",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "app_options/app.R",
    "text": "app_options/app.R\n\n## app_options\n## A simple app that offers a series of options\n\nlibrary(pins)\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  ## register board\n  pins::board_register_rsconnect(\"HL_board\", account = \"liebeha1\")\n\n  ## extract pin id from url\n  pin_id &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$pin)) {\n      query$pin\n    } else {\n      \"\"\n    }\n  })\n  \n  output$ui_axes &lt;- renderUI({\n    req(input$sel_data)\n    ## select x and y parameters from numeric columns\n    df &lt;- get(input$sel_data)\n    columns &lt;- names(df)[sapply(df, class) == \"numeric\"]\n    tagList(\n      selectizeInput(\"sel_x\", \"X parameter\", choices = columns),\n      selectizeInput(\"sel_y\", \"Y parameter\", choices = columns)\n    )\n  })\n  \n  ## write file when updating parameter\n  observeEvent(input$sel_data, {\n    write_file()\n  })\n  \n  observeEvent(input$sel_x, {\n    write_file()\n  })\n  \n  observeEvent(input$sel_y, {\n    write_file()\n  })\n  \n  ## write a file\n  write_file &lt;- function() {\n    if (pin_id() != \"\") {\n      output &lt;- list(\n        data = input$sel_data,\n        x = input$sel_x,\n        y = input$sel_y\n      )\n      json_out &lt;- toJSON(output, auto_unbox = TRUE, null = \"null\")\n      \n      ## pin data\n      pin(json_out, name = pin_id(), board = \"HL_board\")\n\n    }\n  }\n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Options\", status = \"primary\",\n        selectizeInput(\"sel_data\", \"dataset\", choices = c(\"iris\", \"mtcars\")),\n        uiOutput(\"ui_axes\")\n        )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html#app_graphicsapp.r",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html#app_graphicsapp.r",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "app_graphics/app.R",
    "text": "app_graphics/app.R\n\n## app_graphics\n## A simple app that draws a ggplot\n\nlibrary(pins)\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(ggplot2)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  ## register board\n  pins::board_register_rsconnect(\"HL_board\", account = \"liebeha1\")\n\n  ## extract pin id from url\n  pin_id &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$pin)) {\n      query$pin\n    } else {\n      \"\"\n    }\n  })\n  \n  ## retrieve pin data\n  json_data &lt;- pin_reactive(name = pin_id(), board = \"HL_board\", interval = 2000)\n  \n  output$plt &lt;- renderPlot({\n\n    data &lt;- fromJSON(json_data())\n    params &lt;- c(\"data\", \"x\", \"y\")\n    \n    ## check all plotting parameters are present\n    if (all(sapply(params, function(x) !is.null(data[[x]])))) {\n      ggplot(get(data[[\"data\"]]), aes(x = .data[[data[[\"x\"]]]], y = .data[[data[[\"y\"]]]])) +\n        geom_point() +\n        labs(title = paste0(\"Plot data = \", data[[\"data\"]]),\n             x = data[[\"x\"]], \n             y = data[[\"y\"]])\n    }\n  })\n  \n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Graphics\", status = \"primary\",\n        plotOutput(\"plt\")\n  )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html#app_detailsapp.r",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html#app_detailsapp.r",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "app_details/app.R",
    "text": "app_details/app.R\n\n## app_details\n## A simple app that lists some details\n\nlibrary(pins)\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  ## register board\n  pins::board_register_rsconnect(\"HL_board\", account = \"liebeha1\")\n\n  ## extract pin id from url\n  pin_id &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$pin)) {\n      query$pin\n    } else {\n      \"\"\n    }\n  })\n  \n  ## retrieve pin data\n  json_data &lt;- pin_reactive(name = pin_id(), board = \"HL_board\", interval = 2000)\n\n  output$txt_details &lt;- renderPrint({\n    req(json_data())\n    prettify(json_data())\n  })\n  \n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Output\", status = \"primary\",\n        verbatimTextOutput(\"txt_details\")\n  )\n)\n\nshinyApp(ui, server)\n\nOutput is very similar to the shiny server version. The launcher app now contains an additional button (EXIT) which performs a closedown procedure of closing all the other app windows and removing the pin."
  },
  {
    "objectID": "posts/2021/2021-05-19-beer_trip/index.html",
    "href": "posts/2021/2021-05-19-beer_trip/index.html",
    "title": "Beer Trip Around the World",
    "section": "",
    "text": "The traveling salesperson problem (TSP) is an NP-complete problem that asks given a list of cities, what’s the shortest path that can be taken so that each city is visited once and you end up back where you started. Exact solutions to the problem exist but they become impractical as soon as the number of cities increases above 20 therefore approximations are generally performed that yield a suitable, if not best, solution.\nHere we take a fun approach from a thought experiment. What if I could idenfity the best beers in the World and drink them in the breweries in which they are brewed. With a limited time and budget, wouldn’t this be a traveling salesperson problem? With this is mind I quickly drew up the following solution using the {TSP} R package."
  },
  {
    "objectID": "posts/2021/2021-05-19-beer_trip/index.html#step-1---gather-and-wrangle-the-data",
    "href": "posts/2021/2021-05-19-beer_trip/index.html#step-1---gather-and-wrangle-the-data",
    "title": "Beer Trip Around the World",
    "section": "Step 1 - Gather and wrangle the data",
    "text": "Step 1 - Gather and wrangle the data\nData were retrieved from Kaggle. Kaggle contains a few beer datasets but the one chosen (https://www.kaggle.com/ehallmar/beers-breweries-and-beer-reviews) contains beers, reviews and breweries, making our life much easier. Once data were downloaded we could identify top-rated beers and join brewery details to produce a single, neat data frame.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(here)\n\n## read in beer data\ndf_beers &lt;- read_csv(here(\"data/beers.csv\"))\n\n## read in beer ratings\ndf_ratings &lt;- read_csv(here(\"data/reviews.csv\"))\n\n## read in breweries\ndf_breweries &lt;- read_csv(here(\"data/breweries.csv\"))\n\n## summarize ratings by beer and sort\ndf_rating_summary &lt;- df_ratings %&gt;%\n  group_by(beer_id) %&gt;%\n  summarise(rating = mean(score, na.rm = TRUE)) %&gt;%\n  arrange(desc(rating)) %&gt;%\n  filter(rating &gt;= 4.75)\n\n## add ratings summary to beer data frame\ndf_beer_ratings &lt;- df_beers %&gt;%\n  right_join(df_rating_summary, by = c(\"id\" = \"beer_id\")) %&gt;%\n  filter(retired == FALSE)\n\n## add brewery details\ndf_beer_ratings &lt;- df_beer_ratings %&gt;% \n  select(id, beer=name, brewery_id, rating, abv) %&gt;%\n  left_join(df_breweries %&gt;% select(id, brewery=name, city, state, country), by = c(\"brewery_id\" = \"id\")) %&gt;% \n  arrange(desc(rating))\n\n## limit to single occurrence of each brewery\ndf_beer_ratings &lt;- df_beer_ratings %&gt;%\n  group_by(brewery_id) %&gt;%\n  arrange(desc(rating), desc(abv)) %&gt;%\n  slice(1) %&gt;%\n  ungroup()"
=======
    "objectID": "posts/2023/2023-10-25-serverless_shiny/index.html#quarto.yml-file",
    "href": "posts/2023/2023-10-25-serverless_shiny/index.html#quarto.yml-file",
    "title": "Serverless shiny app embedded in a Quarto Website",
    "section": "",
    "text": "The _quarto.yml file is a project with some basic parameters to define the website. The only additional parameter of note is to include shinylive as a filter.\nproject:\n  type: website\n  output-dir: docs\n  \nformat: \n  html\n  \nwebsite:\n  title: \"shinylive elements quiz\"\n  navbar:\n    left:\n      - index.qmd\n\nfilters:\n  - shinylive"
  },
  {
    "objectID": "posts/2023/2023-10-25-serverless_shiny/index.html#index.qmd",
    "href": "posts/2023/2023-10-25-serverless_shiny/index.html#index.qmd",
    "title": "Serverless shiny app embedded in a Quarto Website",
    "section": "",
    "text": "The shiny app is in a single chunk of the index.qmd file with a code chunk type of shinylive-r and the standalone option set.\n\n---\ntitle: \"Chem symbol test\"\n---\n\nThis is a simple chemical symbol test.  You'll be tested on chemical elements and their names.\n\n```{r}\n#| include: false\nlibrary(shinylive)\n```\n\n```{shinylive-r}\n#| viewerHeight: 300\n#| standalone: true\n\nchem &lt;- data.frame(\n  symbol = c(\"Al\", \"Sb\", \"Ar\", \"As\", \"Ba\", \"Be\", \"Bi\", \n             \"B\", \"Br\", \"Cd\", \"Ca\", \"C\", \"Cs\", \"Cl\", \"Cr\",\n             \"Co\", \"Cu\", \"F\", \"Au\", \"He\", \"H\", \"I\", \"Fe\",\n             \"Kr\", \"Pb\", \"Li\", \"Mg\", \"Mn\", \"Hg\", \"Ne\", \"Ni\",\n             \"N\", \"O\", \"P\", \"Pt\", \"K\", \"Rn\", \"Se\", \"Si\", \"Ag\",\n             \"Na\", \"Sr\", \"S\", \"Te\", \"Sn\", \"Ti\", \"W\",\n             \"U\", \"V\", \"Xe\", \"Zn\", \"Zr\"),\n  name = c(\"aluminum\", \"antimony\", \"argon\", \"arsenic\", \"barium\", \"beryllium\", \"bismuth\", \n           \"boron\", \"bromine\",\"cadmium\", \"calcium\", \"carbon\", \"cesium\", \"chlorine\", \"chromium\",\n           \"cobalt\", \"copper\", \"fluorine\", \"gold\", \"helium\", \"hydrogen\", \"iodine\", \"iron\",\n           \"krypton\", \"lead\", \"lithium\", \"magnesium\", \"mangenese\", \"mercury\", \"neon\", \"nickel\",\n           \"nitrogen\", \"oxygen\", \"phosphorus\", \"platinum\", \"potassium\", \"radon\", \"selenium\", \"silicon\", \"silver\",\n           \"sodium\", \"strontium\", \"sulfur\", \"tellurium\", \"tin\", \"titanium\", \"tungsten\",\n           \"uranium\", \"vanadium\", \"xenon\", \"zinc\", \"zirconium\")\n)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(5, offset = 1, checkboxGroupInput(\"chk_options\", \"Test me on\", choices = names(chem), selected = \"symbol\", inline = TRUE))\n  ),\n  fluidRow(\n    column(5, offset = 1, uiOutput(\"ui_question\")),\n    column(5, \n           fluidRow(uiOutput(\"ui_score\")),\n           fluidRow(uiOutput(\"ui_streak\"))\n           )\n  )\n  \n)\n\nserver &lt;- function(input, output, session) {\n\n  last_num &lt;- 0\n  rv &lt;- reactiveValues(\n    question_count = 0,\n    score = 0,\n    question_type = NULL,\n    question = NULL,\n    answer = NULL,\n    streak = 0\n  )\n  \n  question_index &lt;- reactive({\n    rv$question_count\n    num &lt;- last_num\n    while (num == last_num) {\n      num &lt;- sample(nrow(chem), size = 1)\n    }\n    last_num &lt;- num\n  })\n  \n  output$ui_question &lt;- renderUI({\n    if (length(input$chk_options) &gt; 0) {\n      rv$question_type &lt;- sample(input$chk_options, size = 1)\n      answer_type &lt;- names(chem)[!names(chem) == rv$question_type]\n      rv$question &lt;- chem[[rv$question_type]][question_index()]\n      rv$answer &lt;- chem[[answer_type]][question_index()]\n      tagList(\n        h3(paste(answer_type, \"for:\", rv$question)),\n        textInput(\"txt_answer\", label = NULL),\n        actionButton(\"but_answer\", \"Submit\")\n      )\n    }\n  })\n  \n  observeEvent(input$but_answer, {\n    if (rv$question_type == \"symbol\") {\n      answer &lt;- tolower(input$txt_answer)\n    } else {\n      answer &lt;- input$txt_answer\n    }\n    if (answer == rv$answer) {\n      rv$score &lt;- rv$score + 1\n      rv$streak &lt;- rv$streak + 1\n      showNotification(ui = \"CORRECT!\", type = \"message\")\n    } else {\n      rv$streak &lt;- 0\n      showNotification(ui = paste0(\"WRONG.  Correct answer is \", rv$answer), type = \"error\")\n    }\n    rv$question_count &lt;- rv$question_count + 1\n  })\n  \n  output$ui_score &lt;- renderUI({\n    h3(paste0(\"Score: \", rv$score, \"/\", rv$question_count), style = \"color: #388E3C\")\n  })\n  \n  output$ui_streak &lt;- renderUI({\n    if (rv$streak &gt; 29) {\n      col &lt;- \"#2E7D32\"\n    } else if (rv$streak &gt; 19) {\n      col &lt;- \"#00838F\"\n    } else if (rv$streak &gt; 9) {\n      col &lt;- \"#1E88E5\"\n    } else if (rv$streak &gt; 0) {\n      col &lt;- \"#8E24AA\"\n    } else {\n      col &lt;- \"#E53935\"\n    }\n    h3(paste0(\"Streak: \", rv$streak), style = paste0(\"color: \", col))\n  })\n\n}\n\napp &lt;- shinyApp(ui = ui, server = server)\n\n```\n\nThe app itself contains the typical ui and server along with the shinyapp() function to execute. It is basic and unoptimized (but it demonstrates the purpose). It takes very little effort to change a standalone app to an embedded one.\nThe quarto website with embedded app is available at https://harveyl888.github.io/shinylive-test/."
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover some concepts of importing data."
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html#introduction",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html#introduction",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover some concepts of importing data."
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html#import-data-once-or-many",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html#import-data-once-or-many",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "Import data once or many?",
    "text": "Import data once or many?\nData may be imported when an app starts up or imported as needed. Depending on the type and size of data, data import may be a slow step and it is prudent to consider the type and size of data required by a shiny framework at the design stage. Let’s consider the two options of importing all data at the start or only importing when data are required.\n\nImport data once at the start\nIt makes sense to import data just once, when the app starts up, if the framework relies on only a few data sources. This occurs when the framework defines a single instruction set or if we have a collection of instructions but these instructions only access a limited number of datasets.\n\n\nImport data as needed\nImporting data as needed makes sense when you have a collection of instructions that access a large number of datasets - for example if each instruction set accesses a different dataset. This is particularly true if instruction sets are selected by a user. For example, consider an app with 200 instructions and outputs where the user may choose which one to process and display. In such a case we should not import all 200 datasets upfront as only one is required by the app. The dataset should be imported once the user has selected the instruction set."
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html#data-import-packages",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html#data-import-packages",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "Data import packages",
    "text": "Data import packages\nData may come in many formats. For now, let’s consider CSV since it is a popular format to store rectangular data. The base R CSV reader function read.csv() is relatively slow. There are faster CSV file readers that may be used in its place such as read_csv() from {readr} and fread from {data.table}.\nTo test speed we’ll create two CSV files. f1.csv contains 10000 rows of 10 columns of data (first three columns are character and rest are numeric). f2.csv contains 10 rows of 10000 columns of data (first three columns are character and rest are numeric). f1.csv simulates long data whereas f2.csv simulates wide.\n\n## create two CSV files\n## f1.CSV - 10000 rows, 10 cols, long format\n## f2.CSV - 10 rows, 10000 cols, wide format\nd &lt;- list(c(10000, 10), c(10, 10000))\nfor (i in seq_along(d)) {\n  f &lt;- sprintf(\"f_%02i.csv\", i)\n  data &lt;- matrix(runif(d[[i]][1] * d[[i]][2]), ncol = d[[i]][2]) |&gt;\n    data.frame() |&gt;\n    dplyr::mutate(dplyr::across(c(\"X1\", \"X2\", \"X3\"), as.character))\n  write.csv(data, f, row.names = FALSE)\n}\n\nWe can test the speed of base::read.csv, readr::read_csv and data.table::fread using {microbenchmark} and visualize the output with ggplot::autoplot as follows\n\nout &lt;- lapply(seq_along(d), function(i) {\n  f &lt;- sprintf(\"f_%02i.csv\", i)\n  microbenchmark::microbenchmark(\n    `read.csv` = read.csv(f),\n    read_csv = readr::read_csv(f, show_col_types = FALSE),\n    fread = data.table::fread(f), times = 10\n  )\n})\n\nggplot2::autoplot(out[[1]])\nggplot2::autoplot(out[[2]])\n\n\nBenchmark reading long-format CSV\n\n\n\nBenchmark reading wide-format CSV\n\n\n\n\n\n\n\nNote\n\n\n\nLong format relative timing: fread: 1, read_csv: 5.3, read.csv: 13.2\nWide format relative timing: fread: 1, read_csv: 197, read.csv: 626\n\ndata.table::fread is the most efficient at reading both long and wide formatted CSV data.\nreading wide-formatted files is much slower than long-formatted files"
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html#importing-what-is-required",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html#importing-what-is-required",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "Importing what is required",
    "text": "Importing what is required\nBoth readr::read_csv and data.table::fread include a parameter to limit the columns imported. If you know that not all columns are required, limiting the imported columns can speed up the time. In the example below we read in just 6 columns.\n\nout_select &lt;- lapply(seq_along(d), function(i) {\n  f &lt;- sprintf(\"f_%02i.csv\", i)\n  chosen_cols &lt;- c(\"X1\", paste0(\"X\", sample(x = seq(d[[i]][2])[-1], size = 5)))\n  microbenchmark::microbenchmark(\n    `read.csv` = read.csv(f),\n    read_csv = readr::read_csv(f, show_col_types = FALSE, col_select = all_of(chosen_cols)),\n    fread = data.table::fread(f, select = chosen_cols), times = 10\n  )\n})\n\nggplot2::autoplot(out_select[[1]])\nggplot2::autoplot(out_select[[2]])\n\n\nBenchmark reading long-format CSV (selected columns)\n\n\n\nBenchmark reading wide-format CSV (selected columns)\n\n\n\n\n\n\n\nNote\n\n\n\nLong format relative timing: fread: 1, read_csv: 4.8, read.csv: 13.6\nWide format relative timing: fread: 1, read_csv: 3.1, read.csv: 653\n\ndata.table::fread is the most efficient at reading both long and wide formatted CSV data.\nThere is little advantage when selecting columns for data.table::fread but when selected with readr::read_csv there is a significant increase in speed (1.2x for long data and 65x for wide data)"
  },
  {
    "objectID": "posts/2023/2023-03-15-shiny_framework_04/index.html#importing-data",
    "href": "posts/2023/2023-03-15-shiny_framework_04/index.html#importing-data",
    "title": "Shiny Frameworks 04 - Importing Data",
    "section": "Importing data",
    "text": "Importing data\nWorking with data import instructions is relatively simple. Consider the instructional json file (instructions.json):\n{\n  \"instruction\": \"import\",\n  \"file_name\": \"my_file.csv\"\n}\nThe interpreter can be a few lines of code as simple as:\n\n## import json to R list\ninstr &lt;- jsonlite::fromJSON(\"instructions.json\", simplifyVector = FALSE)\n\n## parse json\nif (instr$instruction == \"import\") {\n    my_file &lt;- instr$file_name\n    out &lt;- readr::read_csv(my_file, col_types = readr::cols())\n}\n\nThis is perhaps the simplest example. The interpreter can, however, be more complex depending on needs. The example below includes an optional file path, identifies the file type (either CSV or SAS) by its extension and allows the import to be limited to a subset of columns.\n\n## import json to R list\ninstr &lt;- jsonlite::fromJSON(\"instructions.json\", simplifyVector = FALSE)\n\n## parse json\nif (instr$instruction == \"import\") {\n  if (!is.null(instr$file_path)) {\n    my_file &lt;- file.path(instr$file_path, instr$file_name)\n  } else {\n    my_file &lt;- instr$file_name\n  }\n  only_cols &lt;- unlist(instr$cols)\n\n  if(tools::file_ext(my_file) == \"csv\") {\n    out &lt;- readr::read_csv(my_file, col_types = readr::cols(), col_select = only_cols)\n  } else if (tools::file_ext(my_file) == \"sas7bdat\") {\n    out &lt;- haven::read_sas(my_file, col_select = only_cols)\n  } else {\n    out &lt;- data.frame()\n  }\n}\n\nA list of columns is passed as a json list:\n{\n  \"instruction\": \"import\",\n  \"file_name\": \"my_file.csv\",\n  \"cols\": [\"mpg\", \"wt\"]\n}\nand is converted to a vector (unlist) in the code. If cols does not exist in the json file then instr$cols evaluates to NULL, as does unlist(instr$cols) and the parameter col_select = NULL is carried through to readr::read_csv or haven::read_sas."
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover the concept of framework instructions, how and where to store them and introduce the concept of interpreters."
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#introduction",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#introduction",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover the concept of framework instructions, how and where to store them and introduce the concept of interpreters."
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#shiny-framework-instructions",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#shiny-framework-instructions",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "Shiny Framework Instructions",
    "text": "Shiny Framework Instructions\nAs mentioned in part 1, the concept of a shiny framework is to build an app or its content using instructions. The instructions are parsed through an interpreter which converts the instructions into code. Instructions are the soul of the framework. They can be considered a recipe or lists of steps that are read and executed by an interpreter. Instructions may be a single sequence of steps which might be used to set up parts of an app, such as defining a consistent UI. More likely, the instructions are a collection where performs a specific task. The latter is where the strengths of a framework are realized as this approach is highly flexible and scales quickly compared to a traditional shiny app."
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#instruction-format",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#instruction-format",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "Instruction Format",
    "text": "Instruction Format\nTwo common formats to store instructional information are JSON and YAML. When imported into R using the {jsonlite} or {yaml} packages these instructional data are converted into a named list, which works very well when parsing instructions.\nSome key differences between the two formats: - JSON uses brackets to represent objects whereas YAML uses indentation. - JSON requires all strings to be in double quotes whereas single/double quotes are optional when using YAML. - Comments can be included in YAML but not in JSON. - JSON typically parses faster than YAML.\n\nJSON Format\nA simple JSON example is shown below:\n{\n  \"param_01\": \"value_01\",\n  \"param_02\": \"value_02\",\n  \"param_03\": \"value_03\",\n}\nFor a list of instructions we can use a JSON array. An advantage of this format, when working with a collection of instructions, is that each instruction set can contain different parameters:\n[\n  {\n    \"ref\": 1,\n    \"param_01\": \"value_01A\",\n    \"param_02\": \"value_02A\",\n  },\n  {\n    \"ref\": 2,\n    \"param_01\": \"value_01B\",\n    \"param_02\": \"value_02B\",\n    \"param_03\": \"value_03B\",\n  }\n]\nwhich is interpreted by R as follows (simplifyVector = FALSE ensures that the input is not converted to a data frame):\n\njsonlite::fromJSON(\"json_file.json\", simplifyVector = FALSE)\n\n\n\n[[1]]\n[[1]]$ref\n[1] 1\n\n[[1]]$param_01\n[1] \"value_01A\"\n\n[[1]]$param_02\n[1] \"value_02A\"\n\n\n[[2]]\n[[2]]$ref\n[1] 2\n\n[[2]]$param_01\n[1] \"value_01B\"\n\n[[2]]$param_02\n[1] \"value_02B\"\n\n[[2]]$param_03\n[1] \"value_03B\""
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#yaml-format",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#yaml-format",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "YAML Format",
    "text": "YAML Format\nA simple YAML example is shown below:\nparam_01: value_01\nparam_02: value_02\nparam_03: value_03\nFor a list of instructions we can use a YAML array. An advantage of this format, when working with a collection of instructions, is that each instruction set can contain different parameters:\n-  ref: 1\n   param_01: value_01A\n   param_02: value_02A\n-  ref: 2\n   param_01: value_01A\n   param_02: value_02A\n   param_03: value_03A\nwhich is interpreted by R as follows:\n\nyaml::read_yaml(\"yaml_file.json\")\n\n\n\n[[1]]\n[[1]]$ref\n[1] 1\n\n[[1]]$param_01\n[1] \"value_01A\"\n\n[[1]]$param_02\n[1] \"value_02A\"\n\n\n[[2]]\n[[2]]$ref\n[1] 2\n\n[[2]]$param_01\n[1] \"value_01B\"\n\n[[2]]$param_02\n[1] \"value_02B\"\n\n[[2]]$param_03\n[1] \"value_03B\""
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#how-and-where-to-store-instructions",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#how-and-where-to-store-instructions",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "How and Where to Store Instructions",
    "text": "How and Where to Store Instructions\n\nFlat File\nJson and yaml are language-agnostic formats designed to be stored in a simple flat file. For smaller frameworks, this is an ideal way to store instructions. When working with a flat file, the entire contents are read into memory and converted to a list in R before processing.\n\n\nNoSQL Database\nWhen working with a collection of instructions, a NoSQL database works better than a flat file. Each instruction set is separated from the others and can be imported indepedently. NoSQL databases based on JSON such as MongoDB and CouchDB are ideally suited for a framework approach as this format can store complex data in a convenient format and work with hierarchical data. Moreover, there are simple R libraries that can interact with these databases, returning data as a named list.\n\n\nDatabase vs File\nThere are some advantages in considering a database over a flat file format. Firstly, individual records can be accessed far more readily from a database as compared to a file. Secondly, databases scale better than files, which tend to require reading the entire structure into memory before processing. An advantage of the file format is that there is a greater flexibility on where it can be located. A database generally requires a server, whereas a JSON file can be stored on a shared drive or pinned on a board using the {pins} library."
  },
  {
    "objectID": "posts/2023/2023-03-05-shiny_framework_02/index.html#parsing",
    "href": "posts/2023/2023-03-05-shiny_framework_02/index.html#parsing",
    "title": "Shiny Frameworks 02 - Instructions and Parsing",
    "section": "Parsing",
    "text": "Parsing\nWhether instructions are stored in a flat file or database, it makes sense to define a single set of functions to access the details. The parser or interpreter takes an instruction set and converts it from a series of parameters to a series of functional steps."
  },
  {
    "objectID": "posts/2023/2023-01-27-selectizeinput_order/index.html",
    "href": "posts/2023/2023-01-27-selectizeinput_order/index.html",
    "title": "Ordering Pre-selected Items in selectizeInput",
    "section": "",
    "text": "SelectizeInput\nSelectizeInput is a powerful shiny widget built on the selectize.js library. The behavior of selectize.js can be extended using plugins, which are available in the shiny::selectizeInput() functon. One particularly useful plugin is “drag_drop” which allows a user to re-order the items selected in a selectizeInput. When paired with the “remove_button” plugin this makes a powerful UI in which a user may select, reorder and remove items from a list.\nWhen building a selectizeInput widget, we can list items that have been pre-selected, which allows us to start in a specific state. With drag-drop and remove_button added, these pre-selected items will appear in the selectizeInput box, already selected.\nFor example, the code below produces the following output:\n\n\nshiny::selectizeInput(inputId = \"sel\", \n                      label = \"Selection\", \n                      choices = 1:10, \n                      selected = 1:5, \n                          multiple = TRUE, \n                          options = list(\n                            plugins= list(\"remove_button\", \"drag_drop\")\n                          ))\n\nThere is one caveat in this approach which is that the order of selected items is not honored. For example, the code below produces the following output:\n\n\nshiny::selectizeInput(inputId = \"sel\", \n                      label = \"Selection\", \n                      choices = 1:10, \n                      selected = c(4, 7, 2, 3), \n                          multiple = TRUE, \n                          options = list(\n                            plugins= list(\"remove_button\", \"drag_drop\")\n                          ))\n\nThe correct items are selected but their order has not been preserved. Instead, they are ordered according to the order of the choices parameter. This is normal behavior and is an artefact in the way that selectize.js works.\n\n\nSolution to Order of Pre-selected Items\nA solution to this issue lies in re-ordering the choices parameter. The following shiny app will also fail to maintain the order of the selected items:\n\nlibrary(shiny)\n\nvals &lt;- setNames(1:10, sapply(1:10, function(i) paste(\"Row\", i)))\nvals_start &lt;- c(4, 7, 2, 3)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(6, uiOutput(\"ui_selectize\")),\n    column(6, verbatimTextOutput(\"ui_selected_values\"))\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$ui_selectize &lt;- renderUI({\n    shiny::selectizeInput(inputId = \"sel\", \n                          label = \"Selection\", \n                          choices = vals, \n                          selected = vals_start, \n                          multiple = TRUE, \n                          options = list(\n                            plugins= list(\"remove_button\", \"drag_drop\")\n                          ))\n  })\n  \n  output$ui_selected_values &lt;- renderPrint({\n    input$sel\n  })\n  \n}\n\nshinyApp(ui, server)\n\nBut, with the addition of a line at the start of output$ui_selectize, we maintain the order:\n\nlibrary(shiny)\n\nvals &lt;- setNames(1:10, sapply(1:10, function(i) paste(\"Row\", i)))\nvals_start &lt;- c(4, 7, 2, 3)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(6, uiOutput(\"ui_selectize\")),\n    column(6, verbatimTextOutput(\"ui_selected_values\"))\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$ui_selectize &lt;- renderUI({\n    vals &lt;- c(vals[match(vals_start, vals)], vals[which(!vals %in% vals_start)])\n    shiny::selectizeInput(inputId = \"sel\", \n                          label = \"Selection\", \n                          choices = vals, \n                          selected = vals_start, \n                          multiple = TRUE, \n                          options = list(\n                            plugins= list(\"remove_button\", \"drag_drop\")\n                          ))\n  })\n  \n  output$ui_selected_values &lt;- renderPrint({\n    input$sel\n  })\n  \n}\n\nshinyApp(ui, server)\n\nThe additional line vals &lt;- c(vals[match(vals_start, vals)], vals[which(!vals %in% vals_start)]) simply reorders vals so that our selected items come first in their correct order and the other items follow.\n\nvals &lt;- setNames(1:10, sapply(1:10, function(i) paste(\"Row\", i)))\nprint(vals)\n\n Row 1  Row 2  Row 3  Row 4  Row 5  Row 6  Row 7  Row 8  Row 9 Row 10 \n     1      2      3      4      5      6      7      8      9     10 \n\nvals_start &lt;- c(4, 7, 2, 3)\nvals &lt;- c(vals[match(vals_start, vals)], vals[which(!vals %in% vals_start)])\nprint(vals)\n\n Row 4  Row 7  Row 2  Row 3  Row 1  Row 5  Row 6  Row 8  Row 9 Row 10 \n     4      7      2      3      1      5      6      8      9     10 \n\n\nThe shiny output now looks like this. The order of our pre-selected items is honored."
  },
  {
    "objectID": "posts/2022/2022-07-02_quarto_sas_02/index.html",
    "href": "posts/2022/2022-07-02_quarto_sas_02/index.html",
    "title": "Running SAS in Quarto. Part 2",
    "section": "",
    "text": "An earlier post demonstrated how the jupyter SAS kernel could be used to run SAS from within a Quarto document. This post demonstrates the saspy library and how SAS can be incorporated into Quarto, ultimately passing data to an interactive observable visualization.\n\nSetup and Configure\nsaspy needs to be installed and configured. See the previous post for details on configuring sascfg_personal.py and _authinfo files.\n\n\nQuarto qmd Document\nThe saspy library can be used to communicate between python and sas. It works within Quarto python chunks without requiring the SAS kernel. Below is an example document which demonstrates how to call SAS code directly within a python chunk, how to execute SAS commands from within a python chunk and how to pass data from SAS to python. Once data have been passed from SAS to python we have the opportunity of using observable to render interactive visualizations.\n---\ntitle: \"Quarto Demo with SAS\"\nformat: html\nself-contained: true\n---\n\nA simple demo of using SAS in Quarto.  In this document we demonstrate the following:\n\n-  Running SAS code directly\n-  Importing a SAS dataset\n-  Executing SAS commands using saspy\n-  Converting SAS dataset to a Pandas DataFrame\n-  Interactive visualization using observable \n\n# Setup\n\nsaspy is required to run SAS commands from python/jupyter.\n\n```{python}\nimport saspy\nimport pandas as pd\n\nsas = saspy.SASsession()\n```\n\n# Running SAS code directly from the notebook\n\nThe `sas.submit()` method can be used to submit SAS code directly.  The method returns a dictionary with two keys, _LOG_ and _LST_.  The _LOG_ can simply be printed and the _LST_ rendered as HTML using `sas.HTML()`.\n\n```{python}\n#| echo: true\n#| results: asis\n#| warning: false\n\nll = sas.submit(\"\"\"\nlibname work list;\n\nproc sql;\n   select type, count(*) as 'number of models'n, avg(MPG_city) as 'Avg(MPG_City)'n\n   from sashelp.cars\n   group by type\n   order by 3 desc;\nquit; \n\"\"\")\n\n```\n\n### keys\nlist of dictionary keys returned by SAS\n```{python}\nll.keys()\n```\n\n### LST\nLST output\n```{python}\nsas.HTML(ll['LST'])\n```\n\nAlternatively, the _LST_ can be rendered automatically using the `sas.submitLST()` method\n\n```{python}\n#| echo: true\n#| results: asis\n#| warning: false\n\nll = sas.submitLST(\"\"\"\nlibname work list;\n\nproc sql;\n   select type, count(*) as 'number of models'n, avg(MPG_city) as 'Avg(MPG_City)'n\n   from sashelp.cars\n   group by type\n   order by 3 desc;\nquit; \n\"\"\")\n\n```\n\n# Working with SAS and python together\n\n## Importing data from SAS\n```{python}\ndata_sas = sas.sasdata('cars', 'sashelp')\n```\n\n## Running SAS PROC MEANS from Quarto\n```{python}\ndata_sas.means()\n```\n\n## A simple bar chart (from SAS)\n```{python}\ndata_sas.bar('EngineSize')\n```\n\n## Converting the data to a Pandas DataFrame\n```{python}\ndata_pd = data_sas.to_df()\ndata_pd.describe()\n```\n\n# Interactive visualization with observable\n\nSAS -&gt; python -&gt; observable   \nNow that our data is available in python we can use the `ojs_define` function to make it available to observable.\n\n```{python}\n#| warning: false\n# make data available to observable\nojs_define(ojs_data = data_pd)\n```\n\nThe observabale code to generate the plot below is included as folded code.\n\n```{ojs}\n//| code-fold: true\n// create an interactive input, limiting MPG_City\nviewof MPG_City = Inputs.range(\n  [10, 60], \n  {value: 10, step: 1, label: \"MPG City\"}\n)\n\n// filter data based on the value based on the MPG_City input\nfiltered_data = transpose(ojs_data).filter(function(car) {\n  return MPG_City &lt; car.MPG_City;\n})\n```\n\n\n```{ojs}\n//| code-fold: true\n// build a dotplot from the filtered data\nplt = Plot.plot({\n    marks: [\n        Plot.dot(filtered_data, {x: \"EngineSize\", y: \"Horsepower\"})\n    ]\n})\n```\n\n\nOutput"
  },
  {
    "objectID": "posts/2022/2022-05-31-metadata_markdown/index.html",
    "href": "posts/2022/2022-05-31-metadata_markdown/index.html",
    "title": "Adding and Retrieving metadata in RMarkdown Documents",
    "section": "",
    "text": "Metadata can be included in the yaml header of an RMarkdown document. The yaml can store metadata in the params parameter or as individual yaml parameters. For example, the RMarkdown file below adds some metadata parameters to the header: short_title, reference and meta_list. The rmarkdown function rmarkdown::metadata can be used to access the yaml parameters.\n---\ntitle: \"document title\"\nauthor: \"author name\"\nshort_title: \"short\"\nreference: 1\noutput: \"html_document\"\nparams:\n    name: \"my name\"\nmeta_list:\n    meta: \"meta 1\"\n---\n\ntest doc\n\n`r rmarkdown::metadata$short_title`\n\n`r params$name`\n\n`r rmarkdown::metadata$meta_list$meta`\nIn addition, the parameters can be accessed using the rmarkdown::yaml_front_matter() function.\nrmarkdown::yaml_front_matter(\"document.Rmd\")\n$title\n[1] \"document title\"\n\n$author\n[1] \"author name\"\n\n$short_title\n[1] \"short\"\n\n$reference\n[1] 1\n\n$output\n[1] \"html_document\"\n\n$params\n$params$name\n[1] \"my name\"\n\n\n$meta_list\n$meta_list$meta\n[1] \"meta 1\""
  },
  {
    "objectID": "posts/2022/2022-05-31-metadata_markdown/index.html#searching-metadata",
    "href": "posts/2022/2022-05-31-metadata_markdown/index.html#searching-metadata",
    "title": "Adding and Retrieving metadata in RMarkdown Documents",
    "section": "Searching metadata",
    "text": "Searching metadata\nOnce metadata are added to a series of documents, the metadata become searchable using the yaml_front_matter function. By way of example, the functions below build and then search 1000 documents containing dummy data. The time taken to search through 1000 documents on a 4-core laptop was 920 ms.\n\n## create Rmd with yaml\ncreate_rmd &lt;- function(ref, name, folder) {\n\n  x &lt;- glue::glue(\"\n---\ntitle: {name}\nauthor: Harvey\nshort_title: {stringi::stri_rand_strings(1, 20)}\nreference: {ref}\noutput: html_document\nparams:\n    name: {name}\nmeta_list:\n    meta: {ref}\n    text: {stringi::stri_rand_strings(1, 20)}\n---\n\n### {name}\n\nreference: `r rmarkdown::metadata$reference`\n\n{paste0(stringi::stri_rand_lipsum(5), collapse = '\\n\\n')}\n\n\"\n  )\n\n  ## write Rmd file\n  con &lt;- file(file.path(\"./docs\", paste0(\"file_\", name, \".Rmd\")))\n  writeLines(x, con)\n  close(con)\n}\n\n## build a random set of documents\nbuild_docs &lt;- function(n=10, folder) {\n  for (i in seq(n)) {\n    create_rmd(ref=i, name=paste(\"Document\", i), folder=folder)\n  }\n}\n\n## search documents and return matches\nsearch_docs &lt;- function(parameter, search_string, folder) {\n  files &lt;- list.files(folder, pattern = \"*.Rmd\", full.names = TRUE, recursive = TRUE)\n  found &lt;- c()\n  for (f in files) {\n    front_matter &lt;- rmarkdown::yaml_front_matter(f)\n    if (grepl(search_string, front_matter[[parameter]])) found &lt;- append(found, f)\n  }\n  return(found)\n}\n\n\n## create files\nbuild_docs(n=1000, folder=\"./docs\")\n\n## search files\nmicrobenchmark::microbenchmark(\n  match_docs &lt;- search_docs(parameter = \"short_title\",\n                            search_string = \"ae\",\n                            folder = \"./docs/\"),\n  times = 5)\n\nWhen run, the search identified 5 documents that matched."
  },
  {
    "objectID": "posts/2022/2022-05-12-knit_child_quarto/index.html",
    "href": "posts/2022/2022-05-12-knit_child_quarto/index.html",
    "title": "knitr::knit_child with Quarto",
    "section": "",
    "text": "Quarto is the new publishing system from RStudio based on Pandoc. It’s a powerful tool for publising from R, Python and Julia, working in a very similar fashion to RMarkdown.\nThere are several great blog posts already highlighting features of Quarto and thoughts on changing from RMarkdown to Quarto.\nRecently, I’ve been building up dynamic documents using child documents. The aim is to identify the parts of a document (report) required and compile them into a main report as child documents. I’ve also started to use Quarto, but can Quarto build a document from a selection of child docs? The answer is ‘yes’."
  },
  {
    "objectID": "posts/2022/2022-05-12-knit_child_quarto/index.html#rmarkdown-version",
    "href": "posts/2022/2022-05-12-knit_child_quarto/index.html#rmarkdown-version",
    "title": "knitr::knit_child with Quarto",
    "section": "RMarkdown Version",
    "text": "RMarkdown Version\nknitr Child documents are a great way to manage long reports. They provide a method to break a document into sections and knit the sections together upon rendering. Below we have a main Rmd document and a child Rmd document. When rendered, the child document is incorporated into the main document.\n\nMain Document\n\n---\ntitle: \"Child docs (RMarkdown)\"\noutput: html_document\n---\n\nTest quarto document using child docs - RMarkdown verion\n\n```{r, include=FALSE}\nlibrary(knitr)\n```\n\n```{r, results='asis', echo=FALSE}\na &lt;- knitr::knit_child('child_doc_01.Rmd', quiet=T)\ncat(a, sep='\\n')\n```\n\n\n\nChild Document 1 (child_doc_01.Rmd)\n\n---\ntag: \"my child 01\"\ntitle: \"child doc 01\"\n---\n\n## Child Doc 1\n\nChild document #1 - this is an RMarkdown child document\n\n\n\nOutput"
  },
  {
    "objectID": "posts/2022/2022-05-12-knit_child_quarto/index.html#quarto-version",
    "href": "posts/2022/2022-05-12-knit_child_quarto/index.html#quarto-version",
    "title": "knitr::knit_child with Quarto",
    "section": "Quarto Version",
    "text": "Quarto Version\nQuarto child documents can be knitted in the same way as RMarkdown documents, using knitr::knit_child. In fact Quarto and RMarkdown child documents can be mixed as shown below.\n\nMain Document\n\n---\ntitle: \"Child docs\"\nformat: html\nexecute: \n  echo: false\nself-contained: true\n---\n\nQuarto child documents are compatible with knitr::knit_child\n\n```{r}\n#| include: false\nlibrary(knitr)\n```\n\n```{r, results='asis'}\na &lt;- knitr::knit_child('child_doc_01.Rmd', quiet=T)\ncat(a, sep=\"\\n\")\n```\n\n```{r, results='asis'}\na &lt;- knitr::knit_child('child_doc_02.qmd', quiet=T)\ncat(a, sep=\"\\n\")\n```\n\n\n\nChild Document 2 (child_doc_02.qmd)\n\n---\ntitle: \"Untitled\"\nformat: html\n---\n\n## Child Doc 2\n\nChild document #2 - this is a quarto child document running {ojs} cell\n\n```{r}\nojs_define(data = mtcars)\n```\n\n```{ojs}\nPlot.plot({\n  marks: [\n    Plot.dot(transpose(data), \n      {x: \"mpg\", y: \"hp\", stroke: \"cyl\"}\n    )\n  ]}\n)\n```\n\n\n\nOutput"
>>>>>>> origin/HEAD
  },
  {
    "objectID": "posts/2021/2021-05-19-beer_trip/index.html#step-2---convert-locations-to-longitudelatitude",
    "href": "posts/2021/2021-05-19-beer_trip/index.html#step-2---convert-locations-to-longitudelatitude",
    "title": "Beer Trip Around the World",
    "section": "Step 2 - Convert locations to longitude/latitude",
    "text": "Step 2 - Convert locations to longitude/latitude\nNow we have a table with locations we can easily convert the locations to longitude/latitude values which will be used to calculate distances. First we need to convert the county code from a two-character abbreviation and then we can use {tidygeocoder} to convert to longitude and latitude.\n\nlibrary(countrycode)\nlibrary(tidygeocoder)\n\n## build city addresses\ndf_beer_ratings &lt;- df_beer_ratings %&gt;%\n  mutate(country_name = countrycode(country, origin = \"iso2c\", destination = \"country.name\")) %&gt;%\n  mutate(address = if_else(country == \"US\", paste(city, state, \"USA\", sep = \", \"), paste(city, country_name, sep = \", \")))\n\n## take the first 300 locations\ndf_use_locations &lt;- df_beer_ratings %&gt;%\n  slice(1:300)\n\n## determine longitude and latitude\ndf_address &lt;- geo(df_use_locations$address, method = \"cascade\")\n\n## bind locations to data frame\ndf_use_locations &lt;- bind_cols(df_use_locations, df_address %&gt;% select(lat, long)) %&gt;%\n  filter(!is.na(lat), !is.na(long))"
  },
  {
    "objectID": "posts/2021/2021-05-19-beer_trip/index.html#step-3---build-a-distance-matrix-and-run-tsp",
    "href": "posts/2021/2021-05-19-beer_trip/index.html#step-3---build-a-distance-matrix-and-run-tsp",
    "title": "Beer Trip Around the World",
    "section": "Step 3 - Build a distance matrix and run TSP",
    "text": "Step 3 - Build a distance matrix and run TSP\nOnce we have a list of longitude/latitude pairs we can build a distance matrix of the distances between each location (default measurement = meters). From this we can solve the traveling salesperson problem. In this example TSP is solved 1000 times and the distance (in miles) plotted. Finally, the shortest tour is plotted using leaflet.\n\nlibrary(geodist)\nlibrary(TSP)\nlibrary(leaflet)\n\n## build a distance matrix\ndist_m &lt;- geodist(df_use_locations %&gt;% select(lat, long), measure = \"geodesic\")\n\n## build TSP and solve 1000 times\nset.seed(1234)\ntsp &lt;- TSP(dist_m, labels = df_use_locations$address)\nbeer_trip &lt;- lapply(seq(1000), function(x) solve_TSP(tsp))\n\n## plot results and identify the shortest tour\ntours &lt;- sapply(beer_trip, tour_length) / 1609.34\nplot(tours, type = \"l\", ylab = \"tour length (miles)\")\nshortest_tour &lt;- which.min(tours)\n\n\n## reorder locations according to shortest tour\nref_order &lt;- unlist(lapply(beer_trip[[shortest_tour]], function(x) x), use.names = FALSE)\ndf_solution &lt;- df_use_locations[ref_order, ]\ndf_solution[nrow(df_solution) + 1, ] &lt;- df_solution[1, ]\n\n## plot tour on leaflet map\nleaflet(data = df_solution) %&gt;% \n  addTiles() %&gt;% \n  addCircleMarkers(~long, ~lat, popup = ~brewery, radius = 2, color = \"red\") %&gt;% \n  addPolylines(~long, ~lat, weight = 4)\n\n\n\n&lt;/section&gt;\n&lt;section id=\"conclusion\" class=\"level2\"&gt;\n&lt;h2&gt;Conclusion&lt;/h2&gt;\n&lt;p&gt;The data may or may not be the best quality but the concept holds true. Total length of trip (between 297 locations) = 50718 miles.&lt;/p&gt;\n&lt;div id=\"quarto-navigation-envelope\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1zaWRlYmFyLXRpdGxl\"&gt;Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXItdGl0bGU=\"&gt;Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6QWJvdXQ=\"&gt;About&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2Fib3V0Lmh0bWw=\"&gt;/about.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6QmxvZw==\"&gt;Blog&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L3Bvc3Rz\"&gt;/posts&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6e3s8IGxpIHl2amltcGp1IHRyaWdnZXI9aG92ZXIgY29sb3JzPXByaW1hcnk6I2ZmZmZmZixzZWNvbmRhcnk6I2M3ZTBlYiA+fX0=\"&gt;&lt;lord-icon src=\"https://cdn.lordicon.com/yvjimpju.json\" colors=\"primary:#ffffff,secondary:#c7e0eb\" trigger=\"hover\" &gt;&lt;/lord-icon&gt;&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6aHR0cHM6Ly9naXRodWIuY29tL2hhcnZleWw4ODg=\"&gt;https://github.com/harveyl888&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6e3s8IGxpIHdsYnltaG9vIHRyaWdnZXI9aG92ZXIgY29sb3JzPXByaW1hcnk6I2ZmZmZmZixzZWNvbmRhcnk6I2M3ZTBlYiA+fX0=\"&gt;&lt;lord-icon src=\"https://cdn.lordicon.com/wlbymhoo.json\" colors=\"primary:#ffffff,secondary:#c7e0eb\" trigger=\"hover\" &gt;&lt;/lord-icon&gt;&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6aHR0cHM6Ly90d2l0dGVyLmNvbS9oYXJ2ZXlsODg4\"&gt;https://twitter.com/harveyl888&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6e3s8IGxpIHFnZWJ3dXRlIHRyaWdnZXI9aG92ZXIgY29sb3JzPXByaW1hcnk6I2ZmZmZmZixzZWNvbmRhcnk6I2M3ZTBlYiA+fX0=\"&gt;&lt;lord-icon src=\"https://cdn.lordicon.com/qgebwute.json\" colors=\"primary:#ffffff,secondary:#c7e0eb\" trigger=\"hover\" &gt;&lt;/lord-icon&gt;&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6aHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2hhcnZleS1saWViZXJtYW4=\"&gt;https://www.linkedin.com/in/harvey-lieberman&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;div id=\"quarto-meta-markdown\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW1ldGF0aXRsZQ==\"&gt;Beer Trip Around the World – Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkdGl0bGU=\"&gt;Beer Trip Around the World – Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW9nY2FyZHRpdGxl\"&gt;Beer Trip Around the World – Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW1ldGFzaXRlbmFtZQ==\"&gt;Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkZGVzYw==\"&gt;Traveling Salesman Problem between breweries&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW9nY2FyZGRkZXNj\"&gt;Traveling Salesman Problem between breweries&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;/section&gt;\n\n&lt;/main&gt; &lt;!-- /main --&gt;\n&lt;script id = \"quarto-html-after-body\" type=\"application/javascript\"&gt;\n  window.document.addEventListener(\"DOMContentLoaded\", function (event) {\n    // Ensure there is a toggle, if there isn't float one in the top right\n    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {\n      const a = window.document.createElement('a');\n      a.classList.add('top-right');\n      a.classList.add('quarto-color-scheme-toggle');\n      a.href = \"\";\n      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };\n      const i = window.document.createElement(\"i\");\n      i.classList.add('bi');\n      a.appendChild(i);\n      window.document.body.appendChild(a);\n    }\n    setColorSchemeToggle(hasAlternateSentinel())\n    const icon = \"\";\n    const anchorJS = new window.AnchorJS();\n    anchorJS.options = {\n      placement: 'right',\n      icon: icon\n    };\n    anchorJS.add('.anchored');\n    const isCodeAnnotation = (el) =&gt; {\n      for (const clz of el.classList) {\n        if (clz.startsWith('code-annotation-')) {                     \n          return true;\n        }\n      }\n      return false;\n    }\n    const onCopySuccess = function(e) {\n      // button target\n      const button = e.trigger;\n      // don't keep focus\n      button.blur();\n      // flash \"checked\"\n      button.classList.add('code-copy-button-checked');\n      var currentTitle = button.getAttribute(\"title\");\n      button.setAttribute(\"title\", \"Copied!\");\n      let tooltip;\n      if (window.bootstrap) {\n        button.setAttribute(\"data-bs-toggle\", \"tooltip\");\n        button.setAttribute(\"data-bs-placement\", \"left\");\n        button.setAttribute(\"data-bs-title\", \"Copied!\");\n        tooltip = new bootstrap.Tooltip(button, \n          { trigger: \"manual\", \n            customClass: \"code-copy-button-tooltip\",\n            offset: [0, -8]});\n        tooltip.show();    \n      }\n      setTimeout(function() {\n        if (tooltip) {\n          tooltip.hide();\n          button.removeAttribute(\"data-bs-title\");\n          button.removeAttribute(\"data-bs-toggle\");\n          button.removeAttribute(\"data-bs-placement\");\n        }\n        button.setAttribute(\"title\", currentTitle);\n        button.classList.remove('code-copy-button-checked');\n      }, 1000);\n      // clear code selection\n      e.clearSelection();\n    }\n    const getTextToCopy = function(trigger) {\n        const codeEl = trigger.previousElementSibling.cloneNode(true);\n        for (const childEl of codeEl.children) {\n          if (isCodeAnnotation(childEl)) {\n            childEl.remove();\n          }\n        }\n        return codeEl.innerText;\n    }\n    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {\n      text: getTextToCopy\n    });\n    clipboard.on('success', onCopySuccess);\n    if (window.document.getElementById('quarto-embedded-source-code-modal')) {\n      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {\n        text: getTextToCopy,\n        container: window.document.getElementById('quarto-embedded-source-code-modal')\n      });\n      clipboardModal.on('success', onCopySuccess);\n    }\n      var localhostRegex = new RegExp(/^(?:http|https):\\/\\/localhost\\:?[0-9]*\\//);\n      var mailtoRegex = new RegExp(/^mailto:/);\n        var filterRegex = new RegExp('/' + window.location.host + '/');\n      var isInternal = (href) =&gt; {\n          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);\n      }\n      // Inspect non-navigation links and adorn them if external\n     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');\n      for (var i=0; i&lt;links.length; i++) {\n        const link = links[i];\n        if (!isInternal(link.href)) {\n          // undo the damage that might have been done by quarto-nav.js in the case of\n          // links that we want to consider external\n          if (link.dataset.originalHref !== undefined) {\n            link.href = link.dataset.originalHref;\n          }\n        }\n      }\n    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {\n      const config = {\n        allowHTML: true,\n        maxWidth: 500,\n        delay: 100,\n        arrow: false,\n        appendTo: function(el) {\n            return el.parentElement;\n        },\n        interactive: true,\n        interactiveBorder: 10,\n        theme: 'quarto',\n        placement: 'bottom-start',\n      };\n      if (contentFn) {\n        config.content = contentFn;\n      }\n      if (onTriggerFn) {\n        config.onTrigger = onTriggerFn;\n      }\n      if (onUntriggerFn) {\n        config.onUntrigger = onUntriggerFn;\n      }\n      window.tippy(el, config); \n    }\n    const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n    for (var i=0; i&lt;noterefs.length; i++) {\n      const ref = noterefs[i];\n      tippyHover(ref, function() {\n        // use id or data attribute instead here\n        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');\n        try { href = new URL(href).hash; } catch {}\n        const id = href.replace(/^#\\/?/, \"\");\n        const note = window.document.getElementById(id);\n        if (note) {\n          return note.innerHTML;\n        } else {\n          return \"\";\n        }\n      });\n    }\n    const xrefs = window.document.querySelectorAll('a.quarto-xref');\n    const processXRef = (id, note) =&gt; {\n      // Strip column container classes\n      const stripColumnClz = (el) =&gt; {\n        el.classList.remove(\"page-full\", \"page-columns\");\n        if (el.children) {\n          for (const child of el.children) {\n            stripColumnClz(child);\n          }\n        }\n      }\n      stripColumnClz(note)\n      if (id === null || id.startsWith('sec-')) {\n        // Special case sections, only their first couple elements\n        const container = document.createElement(\"div\");\n        if (note.children && note.children.length &gt; 2) {\n          container.appendChild(note.children[0].cloneNode(true));\n          for (let i = 1; i &lt; note.children.length; i++) {\n            const child = note.children[i];\n            if (child.tagName === \"P\" && child.innerText === \"\") {\n              continue;\n            } else {\n              container.appendChild(child.cloneNode(true));\n              break;\n            }\n          }\n          if (window.Quarto?.typesetMath) {\n            window.Quarto.typesetMath(container);\n          }\n          return container.innerHTML\n        } else {\n          if (window.Quarto?.typesetMath) {\n            window.Quarto.typesetMath(note);\n          }\n          return note.innerHTML;\n        }\n      } else {\n        // Remove any anchor links if they are present\n        const anchorLink = note.querySelector('a.anchorjs-link');\n        if (anchorLink) {\n          anchorLink.remove();\n        }\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(note);\n        }\n        if (note.classList.contains(\"callout\")) {\n          return note.outerHTML;\n        } else {\n          return note.innerHTML;\n        }\n      }\n    }\n    for (var i=0; i&lt;xrefs.length; i++) {\n      const xref = xrefs[i];\n      tippyHover(xref, undefined, function(instance) {\n        instance.disable();\n        let url = xref.getAttribute('href');\n        let hash = undefined; \n        if (url.startsWith('#')) {\n          hash = url;\n        } else {\n          try { hash = new URL(url).hash; } catch {}\n        }\n        if (hash) {\n          const id = hash.replace(/^#\\/?/, \"\");\n          const note = window.document.getElementById(id);\n          if (note !== null) {\n            try {\n              const html = processXRef(id, note.cloneNode(true));\n              instance.setContent(html);\n            } finally {\n              instance.enable();\n              instance.show();\n            }\n          } else {\n            // See if we can fetch this\n            fetch(url.split('#')[0])\n            .then(res =&gt; res.text())\n            .then(html =&gt; {\n              const parser = new DOMParser();\n              const htmlDoc = parser.parseFromString(html, \"text/html\");\n              const note = htmlDoc.getElementById(id);\n              if (note !== null) {\n                const html = processXRef(id, note);\n                instance.setContent(html);\n              } \n            }).finally(() =&gt; {\n              instance.enable();\n              instance.show();\n            });\n          }\n        } else {\n          // See if we can fetch a full url (with no hash to target)\n          // This is a special case and we should probably do some content thinning / targeting\n          fetch(url)\n          .then(res =&gt; res.text())\n          .then(html =&gt; {\n            const parser = new DOMParser();\n            const htmlDoc = parser.parseFromString(html, \"text/html\");\n            const note = htmlDoc.querySelector('main.content');\n            if (note !== null) {\n              // This should only happen for chapter cross references\n              // (since there is no id in the URL)\n              // remove the first header\n              if (note.children.length &gt; 0 && note.children[0].tagName === \"HEADER\") {\n                note.children[0].remove();\n              }\n              const html = processXRef(null, note);\n              instance.setContent(html);\n            } \n          }).finally(() =&gt; {\n            instance.enable();\n            instance.show();\n          });\n        }\n      }, function(instance) {\n      });\n    }\n        let selectedAnnoteEl;\n        const selectorForAnnotation = ( cell, annotation) =&gt; {\n          let cellAttr = 'data-code-cell=\"' + cell + '\"';\n          let lineAttr = 'data-code-annotation=\"' +  annotation + '\"';\n          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';\n          return selector;\n        }\n        const selectCodeLines = (annoteEl) =&gt; {\n          const doc = window.document;\n          const targetCell = annoteEl.getAttribute(\"data-target-cell\");\n          const targetAnnotation = annoteEl.getAttribute(\"data-target-annotation\");\n          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));\n          const lines = annoteSpan.getAttribute(\"data-code-lines\").split(\",\");\n          const lineIds = lines.map((line) =&gt; {\n            return targetCell + \"-\" + line;\n          })\n          let top = null;\n          let height = null;\n          let parent = null;\n          if (lineIds.length &gt; 0) {\n              //compute the position of the single el (top and bottom and make a div)\n              const el = window.document.getElementById(lineIds[0]);\n              top = el.offsetTop;\n              height = el.offsetHeight;\n              parent = el.parentElement.parentElement;\n            if (lineIds.length &gt; 1) {\n              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);\n              const bottom = lastEl.offsetTop + lastEl.offsetHeight;\n              height = bottom - top;\n            }\n            if (top !== null && height !== null && parent !== null) {\n              // cook up a div (if necessary) and position it \n              let div = window.document.getElementById(\"code-annotation-line-highlight\");\n              if (div === null) {\n                div = window.document.createElement(\"div\");\n                div.setAttribute(\"id\", \"code-annotation-line-highlight\");\n                div.style.position = 'absolute';\n                parent.appendChild(div);\n              }\n              div.style.top = top - 2 + \"px\";\n              div.style.height = height + 4 + \"px\";\n              div.style.left = 0;\n              let gutterDiv = window.document.getElementById(\"code-annotation-line-highlight-gutter\");\n              if (gutterDiv === null) {\n                gutterDiv = window.document.createElement(\"div\");\n                gutterDiv.setAttribute(\"id\", \"code-annotation-line-highlight-gutter\");\n                gutterDiv.style.position = 'absolute';\n                const codeCell = window.document.getElementById(targetCell);\n                const gutter = codeCell.querySelector('.code-annotation-gutter');\n                gutter.appendChild(gutterDiv);\n              }\n              gutterDiv.style.top = top - 2 + \"px\";\n              gutterDiv.style.height = height + 4 + \"px\";\n            }\n            selectedAnnoteEl = annoteEl;\n          }\n        };\n        const unselectCodeLines = () =&gt; {\n          const elementsIds = [\"code-annotation-line-highlight\", \"code-annotation-line-highlight-gutter\"];\n          elementsIds.forEach((elId) =&gt; {\n            const div = window.document.getElementById(elId);\n            if (div) {\n              div.remove();\n            }\n          });\n          selectedAnnoteEl = undefined;\n        };\n          // Handle positioning of the toggle\n      window.addEventListener(\n        \"resize\",\n        throttle(() =&gt; {\n          elRect = undefined;\n          if (selectedAnnoteEl) {\n            selectCodeLines(selectedAnnoteEl);\n          }\n        }, 10)\n      );\n      function throttle(fn, ms) {\n      let throttle = false;\n      let timer;\n        return (...args) =&gt; {\n          if(!throttle) { // first call gets through\n              fn.apply(this, args);\n              throttle = true;\n          } else { // all the others get throttled\n              if(timer) clearTimeout(timer); // cancel #2\n              timer = setTimeout(() =&gt; {\n                fn.apply(this, args);\n                timer = throttle = false;\n              }, ms);\n          }\n        };\n      }\n        // Attach click handler to the DT\n        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');\n        for (const annoteDlNode of annoteDls) {\n          annoteDlNode.addEventListener('click', (event) =&gt; {\n            const clickedEl = event.target;\n            if (clickedEl !== selectedAnnoteEl) {\n              unselectCodeLines();\n              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');\n              if (activeEl) {\n                activeEl.classList.remove('code-annotation-active');\n              }\n              selectCodeLines(clickedEl);\n              clickedEl.classList.add('code-annotation-active');\n            } else {\n              // Unselect the line\n              unselectCodeLines();\n              clickedEl.classList.remove('code-annotation-active');\n            }\n          });\n        }\n    const findCites = (el) =&gt; {\n      const parentEl = el.parentElement;\n      if (parentEl) {\n        const cites = parentEl.dataset.cites;\n        if (cites) {\n          return {\n            el,\n            cites: cites.split(' ')\n          };\n        } else {\n          return findCites(el.parentElement)\n        }\n      } else {\n        return undefined;\n      }\n    };\n    var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n    for (var i=0; i&lt;bibliorefs.length; i++) {\n      const ref = bibliorefs[i];\n      const citeInfo = findCites(ref);\n      if (citeInfo) {\n        tippyHover(citeInfo.el, function() {\n          var popup = window.document.createElement('div');\n          citeInfo.cites.forEach(function(cite) {\n            var citeDiv = window.document.createElement('div');\n            citeDiv.classList.add('hanging-indent');\n            citeDiv.classList.add('csl-entry');\n            var biblioDiv = window.document.getElementById('ref-' + cite);\n            if (biblioDiv) {\n              citeDiv.innerHTML = biblioDiv.innerHTML;\n            }\n            popup.appendChild(citeDiv);\n          });\n          return popup.innerHTML;\n        });\n      }\n    }\n  });\n  &lt;/script&gt;\n&lt;/div&gt; &lt;!-- /content --&gt;\n&lt;script type=\"text/javascript\" src=\"/_resources/js/scripts.js\"&gt;&lt;/script&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;"
  },
  {
    "objectID": "posts/2021/2021-07-22-tidyselect/index.html",
    "href": "posts/2021/2021-07-22-tidyselect/index.html",
    "title": "Using tidyselect in your own package",
    "section": "",
    "text": "The {tidyselect} package powers column selection for {dplyr}, {tidyr} and {recipes} functions but it’s also quite straight-forward to include its functonality in other user-built functions. Here’s an example which replaces a percentage of a data frame by NA. It works by using the tidyselect::eval_select function to select columns and then replaces a portion of the data with NA values.\nColumn selections are passed to the function through dot-dot-dot, allowing an arbitrary number of columns to be selected. The first line of the function:\nexpr &lt;- rlang::expr(c(...))\nreturns a defused expression, and the second:\npos &lt;- tidyselect::eval_select(expr, data = data)\nresumes execution, returning a vector of positions that match the selection. More details on how to implement tidyselect interfaces is available at the tidyselect pkgdown page.\n#' populate data frame with missing data\n#'\n#' Replace a proportion of data in a data frame with missing values\n#'\n#' @param data A data frame\n#' @param p proporion (between 0 and 100) of data in column to be flagged as missing\n#' @param ... `&lt;tidy-select&gt;` One or more unquoted expressions separated by commas\n#'\n#' @return data frame\n#'\n#' @importFrom rlang expr\n#' @importFrom tidyselect vars_select\n#' @export\nadd_missing_df &lt;- function(data, ..., p = 10) {\n  expr &lt;- rlang::expr(c(...))\n  pos &lt;- tidyselect::eval_select(expr, data = data)\n  if (length(pos) &gt; 0) {\n    for (posn in pos) {\n      missing_rows &lt;- sample(nrow(data), size = as.integer(nrow(data) * p / 100))\n      if (length(missing_rows) &gt; 0) {\n        data[missing_rows, posn] &lt;- NA\n      }\n    }\n  }\n  return(data)\n}"
  },
  {
    "objectID": "posts/2021/2021-07-22-tidyselect/index.html#examples",
    "href": "posts/2021/2021-07-22-tidyselect/index.html#examples",
    "title": "Using tidyselect in your own package",
    "section": "Examples",
    "text": "Examples\nAll of the {tidyselect} selectors may be used, along with the {magrittr} pipe if loaded. Some examples of use are:\n\n# remove 40% of data in columns mpg to hp\nadd_missing_df(mtcars, p=40, mpg:hp)\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4             NA   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag         NA   6    NA 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  NA 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6    NA 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7  NA 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360            NA   8 360.0  NA 3.21 3.570 15.84  0  0    3    4\nMerc 240D             NA   4 146.7  NA 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8  NA 140.8  NA 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2  NA 167.6  NA 3.92 3.440 18.30  1  0    4    4\nMerc 280C             NA  NA 167.6  NA 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC           NA   8    NA  NA 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood    NA  NA 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8    NA 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4    NA  NA 4.08 2.200 19.47  1  1    4    1\nHonda Civic           NA  NA    NA  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9  NA  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5  NA 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin           NA   8 304.0  NA 3.15 3.435 17.30  0  0    3    2\nCamaro Z28            NA  NA    NA  NA 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8    NA  NA 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0  NA 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa          NA  NA    NA 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L        NA  NA 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6    NA 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8    NA 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4    NA  NA 4.11 2.780 18.60  1  1    4    2\n\n\n\n# remove 10% of data in columns that start with \"d\" (dist and drat)\nmtcars %&gt;% add_missing_df(tidyselect::starts_with(\"d\"))\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175   NA 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8    NA 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8    NA 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180   NA 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8    NA 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245   NA 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2"
  },
  {
<<<<<<< HEAD
    "objectID": "posts/2018/2018-01-07-code_instead_of_excel/index.html",
    "href": "posts/2018/2018-01-07-code_instead_of_excel/index.html",
    "title": "Code instead of Spreadsheet",
    "section": "",
    "text": "There are many reasons why data analysis should be performed using a language such as R or python over Excel but I’m constantly fighting with colleagues who refuse to adapt.\nHere are five reasons to stop using Excel:\n\nReproducibility\nIt’s very challenging to use what’s been done before with a spreadsheet. You can make additional copies of a workbook but sooner or later the file naming convention is forgotten and you have no idea what you were working on a year ago.\n\n\nVersion Control\nI’ve started applying git to all kids of work, not just programming. From a coding perspective if I can’t keep a detailed log of what I’ve done and branch to try new things I’m lost. Excel 2016 does seem to have some version control through the History pane but since I use Office 2010 at work it’s a moot point. Version control is essential when you’re working with anything that might break.\n\n\nTesting\nWithout built-in tests how can you be sure youre analyses are correct? All too often we find systematic mistakes in spreadsheets. This generally arises from a cut-and-paste operation to an incorrect cell, mixing relative and absolute cell references or not updating a formula from a older spreadsheet version. Breaking a problem into chunks, programming the chunks as functions and running unit tests on those functions will help eradicate any bugs. A few favorite examples - Panko’s analysis of 13 field audits suggested that 94% of spreadsheets contained errors and 5.2% of cells were questionable. (Stephen G. Powell, Kenneth R. Baker and Barry Lawson, 12/01/2007. “A Critical Review of the Literature on Spreadsheet Errors”. Tuck School of Business at Darthmouth College) - The report on J.P. Morgan Chase $6 billion derivatives trading loss points to an unnamed overworked staffer in London who copied and pasted the wrong figures into an Excel spreadsheet, throwing the firm’s risk models out of whack. - One in five papers published genetics papers from 2005-2015 (3600 papers, 18 journals) contain errors due to Excel autoformatting Genome Biology, 2016, 17, 177\n\n\nMaintainability\nI work in Analytical Chemistry and often deal with assay data - essentially a block of data which could be summarized as s samples each run r times against f features. Changing r from two repeat samples to three in Excel is challenging and generally requires adding additional columns and reapplying formulae. This is much more amenable in a programming paradigm where formulae can be much more flexible and account for future changes.\nIn addition, it’s far easier to write and maintain functions under R or python that Excel. The last significant change in VBA was around 2000.\n\n\nNumerical Accuracy\nNumerical accuracy can be an issue for any computing system. The way floating point values are stored has always meant that we have to be careful with rounding and comparing to zero. One particular anomoly has been identified with Excel, however. An old thread at https://office-watch.com/2008/excel-sum-anomaly/ highlights a typical floating point issue. Adding a list of numbers does not exactly equal zero. This is expected since numbers are stored using a limited number of binary digits. What’s interesting is if you take the same column of numbers and order them numerically (high to low or low to high) they do equate to exactly zero. It appears that the result is dependent on the order of the numbers and refutes the commutativity of addition!\n\n\n\n\n-127551.73\n-127551.73\n103130.41\n\n\n\n103130.41\n1568.90\n9028.59\n\n\n\n1807.75\n1794.71\n7390.11\n\n\n\n7390.11\n1807.75\n2831.26\n\n\n\n9028.59\n2831.26\n1807.75\n\n\n\n2831.26\n7390.11\n1794.71\n\n\n\n1568.90\n9028.59\n1568.90\n\n\n\n1794.71\n103130.41\n-127551.73\n\n\nSUM\n0.0000000000086402\n0.0000000000000000\n0.0000000000000000"
  },
  {
    "objectID": "posts/2018/2018-06-13-asynchronous/index.html",
    "href": "posts/2018/2018-06-13-asynchronous/index.html",
    "title": "Interrupting a background process: asynchronous shiny",
    "section": "",
    "text": "I had been running a shiny app in which I could halt a long-running process. The process would update the shiny app and constantly looked for an updated shiny variable to inform if a cancel button had been pressed. The code had been adapted from a SO post at https://stackoverflow.com/questions/30587883/is-it-possible-to-stop-executing-of-r-code-inside-shiny-without-stopping-the-sh/34517844#34517844. Unfortunately this utilized the httpuv::service function in a manner for which it was not designed. At some point, when shiny and httpuv were updated, this functionality ceased to work. Thanks to some help from Joe Cheng a similar functionality can be derived using an asynchronous function. A working example is shown below.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  actionButton(\"start_list\", \"Start 'list' iterator\"),\n  actionButton(\"start_list2\", \"Start reactive 'list' iterator\"),\n  actionButton(\"start_while\", \"Start 'while' iterator\"),\n  actionButton(\"cancel\", \"Stop\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  val &lt;- reactiveValues(b = 100)\n  \n  \n  base_task_iterator &lt;- function(should_continue, iter_body) {\n    if (should_continue()) {\n      iter_body()\n      later::later(~base_task_iterator(should_continue, iter_body))\n    }\n    invisible()\n  }\n  \n  while_task_iterator &lt;- function(cancelExpr, whileExpr, func) {\n      cancelFunc &lt;- rlang::as_function(rlang::enquo(cancelExpr))\n      whileFunc &lt;- rlang::as_function(rlang::enquo(whileExpr))\n      \n      origCancelVal &lt;- isolate(try(silent = TRUE, cancelFunc()))\n      cancelled &lt;- function() {\n        !identical(origCancelVal, isolate(try(silent = TRUE, cancelFunc())))\n      }\n      \n        base_task_iterator(\n        function() {\n          !cancelled() && whileFunc()\n        },\n        func\n      )\n  }\n  \n  list_task_iterator &lt;- function(cancelExpr, x, func) {\n      cancelExpr &lt;- rlang::enquo(cancelExpr)\n      \n      origCancelVal &lt;- isolate(try(silent = TRUE, cancelFunc()))\n      pos &lt;- 1\n      \n        while_task_iterator(!!cancelExpr, pos &lt;= length(x), function() {\n        i &lt;- pos\n        pos &lt;&lt;- pos + 1L\n        isolate({\n          func(x[[i]])\n      })\n    })\n  }\n  \n  observeEvent(input$start_list, {\n    list_task_iterator(input$cancel, 1:10, function(x) {\n      message(x)\n      Sys.sleep(1)\n    })\n  })\n  \n  observeEvent(input$start_list2, {\n    list_task_iterator(input$cancel, 1:10, function(x) {\n      val$b &lt;- val$b + 1\n      message(val$b)\n      Sys.sleep(1)\n    })\n  })\n  \n  observeEvent(input$start_while, {\n    # Something's wrong with rlang::as_function, I can't use TRUE, only !FALSE\n    while_task_iterator(input$cancel, !FALSE, function() {\n      message(format(Sys.time()))\n      Sys.sleep(1)\n    })\n  })\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2018/2018-11-09-mimic_button_press/index.html",
    "href": "posts/2018/2018-11-09-mimic_button_press/index.html",
    "title": "Mimic Button Press with Enter Key",
    "section": "",
    "text": "Sometimes it’s useful to mimic a button press in a shiny app when the Enter key is pressed, for example when entering a password. This has been documented before and works well for most situations but fails when the button widget is housed within renderUI. Here’s an alternative that works wherever the password input and button are located.\n\nlibrary(shiny)\nlibrary(shinyjs)\nlibrary(shinyWidgets)\n\njscode &lt;- '\n  shinyjs.setbutton = function(params) {\n    var defaultParams = {\n      id: null,\n      button: null\n    };\n    params = shinyjs.getParams(params, defaultParams);\n    var el = $(\"#\" + params.id);\n    var button = $(\"#\" + params.button);\n    el.keyup(function(event) {\n      if (event.keyCode === 13) {\n        button.click();\n      }\n    })\n  };'\n\nui &lt;- fluidPage(\n  useShinyjs(),\n  extendShinyjs(text = jscode, functions = c('setbutton')),\n  tags$head(tags$script(HTML(jscode))),\n  fluidRow(\n    br(),\n    column(4, offset = 4, uiOutput('loginpanel')),\n    br(),\n    verbatimTextOutput('txtout')\n  )\n)\n\n\nserver &lt;- function(input, output, session) {\n  \n  ## reactiveValue to hold username and password\n  out &lt;- reactiveValues(user = NULL, pw = NULL)\n  \n  output$loginpanel &lt;- renderUI({\n    panel(heading = 'login', status = 'danger',\n          selectInput('user', label = NULL, choices = c('bob', 'ben', 'bill')),\n          textInput('txt1', label = 'textbox', value =''),  ## textbox to show that hitting Enter here has no effect\n          uiOutput('pw'),\n          actionBttn('butLogin', label = 'login', style = 'simple', color = 'success'))\n  })\n  \n  output$pw &lt;- renderUI({\n    passwordInput('pwinp', label = NULL)\n  }) \n  \n  ## attach an event to the passwordInput after a delay to ensure that the widget has been rendered\n  delay(100, \n        js$setbutton('pw', 'butLogin')\n  )\n\n  ## triggered when button pressed or Enter key when focussed on passwordInput widget\n  observeEvent(input$butLogin, {\n    out$user &lt;- input$user\n    out$pw &lt;- input$pwinp\n  })\n  \n  output$txtout &lt;- renderPrint({\n    paste(out$user, out$pw)\n  })\n}\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2018/2018-11-07-shiny_restart_txt/index.html",
    "href": "posts/2018/2018-11-07-shiny_restart_txt/index.html",
    "title": "Restarting a Shiny App",
    "section": "",
    "text": "I have to post this for my own sanity. I tend to create shiny apps in a specific folder and link to them using symbolic links from the ShinyApp folder. This allows multiple versions (prod and dev) and keeps code clean. I don’t know how many times I’ve wrestled with an app pointing to an earlier version when updates have been made and it’s always driven me crazy. I also don’t know how many times I’ve read through the shiny-server documentation but never discovered section 3.1.1 - Restarting an Application. Now I’m happy I’ve discovered touch restart.txt as a way to force an app to restart. All my versioning issues have gone away."
  },
  {
    "objectID": "posts/2018/2018-02-21-rstudio_and_redmine/index.html",
    "href": "posts/2018/2018-02-21-rstudio_and_redmine/index.html",
    "title": "Using Redmine with RStudio",
    "section": "",
    "text": "Redmine is a great tool for tracking project progress and bugs. With a little configuration it can integrate git repositories and integrate with R program / package development. The following assumes that Redmine, R and RStudio server are all configured and working.\n\nLinking a repository to Redmine\nWithout changing file permissions, Redmine cannot interact directly with git repositories created in RStudio server. A simple workaround is to clone the repository. In this example we’ll create a clone for a repository under ~/codes/redmine_demo\n# ~/git_redmine_clones is a directory to hold the clones\ncd ~/git_redmine_clones\n\n# clone the repository\ngit clone --mirror ~/codes/redmine_demo\n\n# set folder content permissions\nchmod a+r -R redmine_demo.git\nThis repository can now be added to a Redmine project through Settings-&gt;Repository. The path to the repository needs to be filled out in full.\n\n\nUpdating clone via cron job\nOne caveat to this approach is that as changes are made to the repository they are not reflected in Redmine. This can be overcome by adding a cron job that automatically fetches any new commits and updates the clone. Changes are visible in Redmine when the clone is updated.\n# use nano as the cron editor\nexport EDITOR=nano\n\n# edit crontab file\ncrontab -e\nThe following line should be aded to the crontab file:\n*/5 * * * * cd ~/git_redmine_clones/redmine_demo.git && git fetch -q --all –p\nThis states that the active directory should be changed to ~/git_redmine_clones/redmine_demo.git and then a git fetch command is run. The timing in the crontab file dictates that this will be run every 5 minutes."
  },
  {
    "objectID": "posts/2016/2016-11-24-black_friday/index.html",
    "href": "posts/2016/2016-11-24-black_friday/index.html",
    "title": "Scraping for Dishwashers",
    "section": "",
    "text": "Our dishwasher broke and was beyond repair. Time for a new one. Fortunately Black Friday was approaching so there were plenty of deals to be found. It seems it’s now easier than ever to pull information off the web and much of it is in a usable format so, if you ask me to identify a replacement dishwasher, web-scraping is where I’m going to start. I’m a big fan of the R library rvest and it took little time to pull back some useful information off the Home Depot website.\n\nlibrary(rvest)\nlibrary(xml2)\n\n## Choose a starting point\nbaseurl &lt;- 'http://www.homedepot.com/b/Appliances-Dishwashers-Built-In-Dishwashers/N-5yc1vZc3nj'\n\n## Data frame to hold results\ndf &lt;- data.frame(model = character(0), rating = numeric(0), link = character(0))\nurl &lt;- baseurl\nloadNextPage &lt;- TRUE\nwhile(loadNextPage) {  ## Loop through pages\n  print('Reading Page')\n  Sys.sleep(0.1)  ## Let's be nice\n  html &lt;- url %&gt;%\n    read_html()  ## pull back the page\n  dw &lt;- html %&gt;%\n    html_nodes('.plp-pod') ## focus in on the dishwashers\n  model &lt;- dw %&gt;%\n    html_node('.pod-plp__model') %&gt;%\n    html_text() ## get model ID\n  model &lt;- gsub('[^[:alnum:] ]', '', model)\n  model &lt;- trimws(sub(\"Model\\\\s([^ ]*).*$\", \"\\\\1\", model)) ## remove the unwanted\n  rating &lt;- dw %&gt;%\n    html_nodes('.pod-plp__ratings') %&gt;%\n    html_node('a') %&gt;%\n    html_node('span') %&gt;%\n    html_attr('rel') %&gt;%\n    as.numeric() ## rating can be found in a link\n  link &lt;- dw %&gt;%\n    html_nodes('.plp-pod__image') %&gt;%\n    html_nodes('a') %&gt;%\n    html_attr('href') ## link to more information\n  df &lt;- rbind(df, data.frame(model = model, rating = rating, link = paste0('http://www.homedepot.com', link)))\n  gotoNext &lt;- html %&gt;%\n    html_nodes('.hd-pagination__link') %&gt;%\n    html_nodes(xpath = '//a[contains(@title,\"Next\")]') ## Link to the next page\n  if (length(gotoNext) &gt; 0) {\n    url &lt;- gotoNext %&gt;% html_attr('href')\n    url &lt;- paste0('http://www.homedepot.com', url)\n    loadNextPage &lt;- TRUE  ## Next page exists\n  } else {\n    loadNextPage &lt;- FALSE ## We've reached the last page\n  }\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Harvey Lieberman",
    "section": "",
    "text": "My name is Harvey and I’m a\n          \n        \n\n        \n      \n\nAbout Blog"
=======
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#existing-comments",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#existing-comments",
    "title": "{distill} Comments",
    "section": "Existing Comments",
    "text": "Existing Comments\nTo retrieve existing comments we use a javascript function to build an HTML output. The function takes site_id and page_id arguments and calls a plumber API which returns comments belonging to the page in json form.\nHere, /page_comments refers to the plumber API endpoint for retrieving comments. The search parameters site_id and page_id are appended to the url so that we can limit the returning data to a specific page on a specific site. Since we are using fetch, the webpage and API must live on the same RStudio Connect instance.\nOnce the json-formatted response is returned, the function loops through the comments building an HTML response and updates #rtncomments. If a comment does not have an author it defaults to anonymous user.\n\nfunction update_comments(page_id, site_id) {\n\n  const url = \"&lt;rsconnect URL&gt;/page_comments?\"\n\n  fetch(url + new URLSearchParams({\n    site: site_id, \n    page: page_id,\n  }))\n  .then(response =&gt; response.json())  \n  .then(data =&gt; {\n    \n    // outer_div - placeholder for comments\n    div_outer = $('&lt;div/&gt;').attr('id', 'div_outer');\n    \n    // add comments count\n    div_outer.append('&lt;h3&gt;' + data.length + ' Comments&lt;/h3&gt;');\n\n    // loop through returned comments, adding each one to an unordered list\n    ul_list_comments = $('&lt;ul/&gt;', {id: 'list_comments', class: 'comment-list'});\n\n    $.each(data, function(i, obj) {\n      \n      user_name = obj.user_name == \"null\" ? \"anonymous user\" : obj.user_name\n\n      ul_list_comments.append(\n        $('&lt;li/&gt;', {class: 'comment-item'}).append([\n          $('&lt;div/&gt;', {class: 'comment-top'}).append([\n            $('&lt;h3/&gt;', {class: 'comment-name', text: user_name}),\n            $('&lt;span/&gt;', {class: 'date-holder'}).append([\n              $('&lt;i/&gt;', {class: 'far fa-clock'}),\n              $('&lt;h3/&gt;', {class: 'comment-date', text: obj.date})\n            ])\n          ]),\n          $('&lt;p/&gt;', {class: 'comment-text', text: obj.comment})\n        ])\n      );\n    });\n\n    div_outer.append(ul_list_comments);\n\n    $(\"#rtncomments\").html(div_outer);\n\n  })\n  .catch((err) =&gt; console.log(\"Can’t access \" + url + \" response. Blocked by browser?\" + err));\n  \n};"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#plumber-api",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#plumber-api",
    "title": "{distill} Comments",
    "section": "plumber API",
    "text": "plumber API\nThe {distill} blog pages are connected to the comments via a plumber API. The API contains two endpoints, a POST endpoint, addcomment which is used to add a new comment and a GET endpoint, page_comments which is used to retrieve comments for a specific page. The comments themselves are stored in a data frame which is accessible via the {pins} package. This allows mutiple sites to use the same data frame.\nIn the code below, board_register(\"rsconnect\", server = \"&lt;rsconnect URL&gt;, account = \"&lt;account id&gt;\", key = connectAPIKey) registers a pin board which holds a pin called blog_comment_table. Once again,  refers to the RStudio Connect URL and,  is the account associated with the pin. An RStudio Connect API key must be defined and exposed as an environment variable (see below).\n\nblog_comment_table is a data frame with columns for site_id, page_id, user_id, date and comment. The date is a timestamp set when the comment is added.\n\nlibrary(plumber)\nlibrary(jsonlite)\nlibrary(pins)\nlibrary(tibble)\nlibrary(lubridate)\nlibrary(dplyr)\n\n#* @apiTitle Comments\n\n#* Add a comment to the table\n#* @param req request body\n#* @post /addcomment\nfunction(req) {\n  \n  ## get the message body\n body &lt;- jsonlite::fromJSON(req$postBody)\n\n  ## RSConnect API Key\n  connectAPIKey &lt;- Sys.getenv(\"CONNECT_API_KEY\")\n\n  ## register rsconnect pin board\n  board_register(\"rsconnect\",\n                 server = \"&lt;rsconnect URL&gt;,\n                 account = \"&lt;account id&gt;\",\n                 key = connectAPIKey)\n\n  ## check for comments table and create if not present\n  if (nrow(pins::pin_find(\"blog_comment_table\", board = \"rsconnect\")) == 0) {\n    comments &lt;- tibble(\n      site_id = body$site_id,\n      page_id = body$page_id,\n      user_id = body$user_id,\n      date = lubridate::now(),\n      comment = body$comment\n    )\n  } else {\n    comments &lt;- pins::pin_get(name = \"blog_comment_table\", board = \"rsconnect\") %&gt;%\n      add_row(\n        site_id = body$site_id,\n        page_id = body$page_id,\n        user_id = body$user_id,\n        date = lubridate::now(),\n        comment = body$comment\n      )\n  }\n  pins::pin(comments, name = \"blog_comment_table\", board = \"rsconnect\")\n  \n}\n\n#* Retrieve all comments for a page\n#* @param site site id\n#* @param page page id\n#* @serializer unboxedJSON\n#* @get /page_comments\nfunction(site = 0, page = 0) {\n  \n  ## RSConnect API Key\n  connectAPIKey &lt;- Sys.getenv(\"CONNECT_API_KEY\")\n  \n  ## register rsconnect pin board\n  board_register(\"rsconnect\", \n                 server = \"&lt;rsconnect URL&gt;,\n                 account = \"&lt;account id&gt;\",\n                 key = connectAPIKey)\n  \n  ## get table and filter\n  pins::pin_get(name = \"blog_comment_table\", board = \"rsconnect\") %&gt;%\n    dplyr::filter(site_id == site & page_id == page) %&gt;%\n    dplyr::arrange(desc(date))\n  \n}"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#webpage-blog-post-with-comments",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#webpage-blog-post-with-comments",
    "title": "{distill} Comments",
    "section": "Webpage / Blog Post with Comments",
    "text": "Webpage / Blog Post with Comments\nAny page with comments follows the same approach. The page includes the javascript functions listed above (comments.js), some css styling (style.css, see below) and the comment_form function (sourced from comment.R).\nThere are a few things to note in the code below.\n\nThe two variables, site_id and page_id, are needed to identify comments for the webpage. Ideally, we’d define them in the yaml header and use them as parameters in the markdown text. Unfortunately, when using render_site, markdown parameters are not rendered (see open GitHub issue). site_id and page_id are therefore defined within a chunk.\nThe javascript function update_comments does not sit in a javascript chunk (you can include javascript in rmarkdown by including a chunk with js instead of r in the chunk header). Instead, the code is placed directly within a &lt;script&gt; tag. When processed this way, we can access variables (site_id and page_id) stored in r language chunks earlier in the document.\n\n\n    ---\n    title: \"test article number 1\"\n    description: |\n      A first test article with comments.\n    author:\n      - name: Harvey Lieberman\n    date: 01-10-2022\n    output:\n      distill::distill_article:\n        self_contained: false\n    ---\n\n    ```{r setup, include=FALSE}\n    knitr::opts_chunk$set(echo = FALSE)\n    ```\n\n    ```{r}\n    page_id &lt;- 1\n    site_id &lt;- 101\n    source(here::here(\"comment.R\"))\n    htmltools::includeCSS(here::here(\"style.css\"))\n    htmltools::includeScript(here::here(\"comments.js\"))\n    ```\n\n    This is a first blog post with comments.\n\n\n    ```{r}\n    comment_form(page_id = page_id, site_id = site_id)\n    ```\n\n\n    &lt;script&gt;\n    update_comments(page_id = `r page_id`, site_id = `r site_id`)\n    &lt;/script&gt;"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#css",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#css",
    "title": "{distill} Comments",
    "section": "css",
    "text": "css\nThe style.css file takes care of styling comments. The file is included below.\n.comments {\n  padding: 20px 10px;\n  margin: 0;\n}\n\n.form-contents {\n    padding: 10px;\n    margin: 10px;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\n.form-details {\n    display: flex;\n    flex-direction: column;\n    flex: 2 1 auto;\n}\n\n.form-details input[type=text] {\n    border-top: 0px;\n    border-bottom: 1px solid #ccc;\n    border-left: 0px;\n    border-right: 0px;\n    outline: 0px;\n    padding: 0;\n    margin-top: 20px;\n    margin-left: 20px;\n    font-weight: normal;\n}\n\n.form-details input[type=text]:focus {\n    border-color: #04AA6D;\n    border-width: 2px;\n}\n\n.form-contents .comment-pic {\n    display: flex;\n    font-size: 3em;\n    align-self: flex-end;\n}\n\n.button-container {\n    display: flex;\n    align-self: flex-end;\n}\n\n.comment-comments input[type=text]{\n    width: 90%;\n}\n\n.comment-short {\n    width: 50%;\n}\n\n.comment-short input[type=text]{\n    width: 80%;\n}\n\n.comment-user {\n    display: flex;\n    flex-direction: row;\n}\n\n.form-container input[type=submit] {\n  background-color: #04AA6D;\n  color: white;\n  padding: 12px 20px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n.button-container input[type=submit] {\n  margin: 2px 5px;\n  float: right;\n}\n\n.form-container input[type=submit]:hover {\n  background-color: #45a049;\n}\n\n.comment-header {\n  font-size: 1.5em;\n  line-height: 1.5em;\n  font-weight: 400;\n}\n\n.comment-holder {\n  margin-top: 50px;\n}\n\nul.comment-list {\n  list-style: none;\n  position: relative;\n  padding: 0;\n}\n\nli.comment-item {\n  padding: 20px 10px;\n  margin: 20px 0;\n  position: relative;\n  width: 100%;\n  background-color: #efefef;\n}\n\n.comment-top {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n}\n\n.comment-name {\n  font-size: 1.5em;\n  font-weight: 400;\n  margin: 5px 0;\n  color: #5d5d5d;\n  align-self: flex-start;\n}\n\n.date-holder {\n  color: #5d5d5d;\n  align-self: flex-end;\n  display: inline-flex;\n  align-items: baseline;\n}\n\n.comment-date {\n  font-size: 1em;\n  font-weight: 400;\n  margin: 5px 0 5px 10px;\n}\n\n.comment-text {\n  display: block;\n  margin: 0 0 10px 0;\n}"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#output",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#output",
    "title": "{distill} Comments",
    "section": "Output",
    "text": "Output\nAfter adding a couple of sample blog posts and a few comments the output is shown below. Here, I’ve added two comments to the first blog post and one to the second. The data frame retrieved from {pins} appears as follows:\n\n\n\n\n\n\n\n\n\n\nsite_id\npage_id\nuser_name\ndate\ncomment\n\n\n\n\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;dttm&gt;\n&lt;chr&gt;\n\n\n101\n1\nHarvey\n2022-01-10 22:24:00\nThis is my first blog comment!\n\n\n101\n1\nHarvey\n2022-01-10 22:24:34\nBlog comments can take a little time to appear once entered - possibly an artefact of RStudio Connect or {pins}\n\n\n101\n2\nHarvey\n2022-01-10 22:25:17\nHere’s a comment for blog entry #2"
  },
  {
    "objectID": "posts/2022/2022-01-11-distill_comments/index.html#issues-to-resolve",
    "href": "posts/2022/2022-01-11-distill_comments/index.html#issues-to-resolve",
    "title": "{distill} Comments",
    "section": "Issues to Resolve",
    "text": "Issues to Resolve\nThe refresh process is a little slow, sometimes taking a several seconds to load comments. At this point I’m not sure if it is related to the use of fetch or plumber.\nThis is a first proof-of-concept and certainly requires some more work but the principle works well."
  },
  {
    "objectID": "posts/2022/2022-01-01-dynamic_tabs/index.html",
    "href": "posts/2022/2022-01-01-dynamic_tabs/index.html",
    "title": "Shiny dynamic tabs",
    "section": "",
    "text": "This is a simple shiny app that demonstrates dynamic shiny tabs. Each tab contains a shiny module which returns a series of data parameters and tabs can be added and removed. In one use-case this construct was used in three higher level tabs, returning a complex, nested structure.\nCode is available at: https://github.com/harveyl888/shiny_dynamic_tabs\nThe concept is fairly simple - upon start up a tabsetPanel is built with a button prepended before the first tab. When clicked, this button adds a new tab containing a shiny module (the tab also contains a close button). The shiny module returns a series of data and these data, from all tabs, are stored in a reaciveValues list (rv$return_data). As tabs are added, deleted or their content changed, the contents of rv$return_data updates."
  },
  {
    "objectID": "posts/2022/2022-01-01-dynamic_tabs/index.html#screen-captures",
    "href": "posts/2022/2022-01-01-dynamic_tabs/index.html#screen-captures",
    "title": "Shiny dynamic tabs",
    "section": "Screen Captures",
    "text": "Screen Captures\nUpon start up, the tabPanel is built with a button and a single tab. Data returned is printed to the right of the tabPanel.\n\nAdding additional tabs and changing their content updates the returned data.\n\nRemoving tab #2 updates the returned data."
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "",
    "text": "An earlier post described a multiwindow shiny app that demonstrated how three shiny apps could be handled by a fourth with data passing between them. This extends the concept, running all apps on RStudio Connect and manages the communication using the {pins} library. Data is passed between the apps using a json file attached to a pin on an RStudio Connect board. When the app is exited, the pin is deleted."
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html#launcherapp.r",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html#launcherapp.r",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "launcher/app.R",
    "text": "launcher/app.R\n\n## App lauuncher\n## This app manages all others\n\n\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(stringi)\nlibrary(pins)\n\nserver &lt;- function(input, output, session) {\n  \n  ## register board\n  pins::board_register_rsconnect(\"HL_board\", account = \"liebeha1\")\n\n  ## create a pin name\n  pin_name &lt;- stringi::stri_rand_strings(1, length = 8)\n  \n  url_base &lt;- ** RSTUDIO CONNECT URL **\n  \n  ## define app windows\n  app_windows &lt;- data.frame(\n    name = c(\"app_options\", \"app_graphics\", \"app_details\"),\n    app = c(\"447\", \"448\", \"449\"),\n    launch_delay = c(0, 2000, 0),\n    height = c(0.25, 0.4, 0.25),\n    width = c(0.095, 0.2, 0.095),\n    left = c(0.02, 0.02, 0.125),\n    top = c(0.02, 0.33, 0.02),\n    closable = c(TRUE, TRUE, TRUE),\n    stringsAsFactors = FALSE\n  )\n  app_windows$url &lt;- paste0(url_base, app_windows$app, \"/?pin=\", pin_name)\n  \n  ## launch all apps\n  for (i in 1:nrow(app_windows)) {\n    Sys.sleep(app_windows[i, ]$launch_delay / 1000)\n    session$sendCustomMessage(\"launch_app\", app_windows[i, ])\n  }\n  \n  observe({\n    req(!is.null(input$txt_com_file))\n    session$sendCustomMessage(\"disable\", \"txt_com_file\")\n  })\n  \n  output$ui_communications &lt;- renderUI({\n    column(10, offset = 1, textInput(\"txt_com_file\", label = \"Pin ID\", width = \"100%\", value = pin_name))\n  })\n  \n  \n  \n  # app_options ------------------------------------------------------------------\n  \n  \n  ## options UI\n  output$ui_app_options &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_options\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: setting options\")),\n      column(2, offset = 1, actionBttn(\"but_close_all\", label = \"Close All\", style = \"simple\", color = \"warning\", size = \"sm\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_options))\n    if (!app_windows[1, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_options\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_options, {\n    if (input$swt_app_options == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[1, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[1, ])\n    }\n  })\n  \n  # app_graphics ------------------------------------------------------------------\n  \n  \n  ## graphics UI\n  output$ui_app_graphics &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_graphics\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: plotting graphics\")),\n      column(2, offset = 1, actionBttn(\"but_exit\", label = \"EXIT\", style = \"simple\", color = \"danger\", size = \"sm\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_graphics))\n    if (!app_windows[2, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_graphics\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_graphics, {\n    if (input$swt_app_graphics == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[2, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[2, ])\n    }\n  })\n  \n  # app_details ------------------------------------------------------------------\n  \n  \n  ## details UI\n  output$ui_app_details &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_details\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: setting details\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_details))\n    if (!app_windows[3, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_details\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_details, {\n    if (input$swt_app_details == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[3, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[3, ])\n    }\n  })\n  \n  ## close all apps\n  observeEvent(input$but_close_all, {\n    for (i in 1:nrow(app_windows)) {\n      session$sendCustomMessage(\"close_app\", app_windows[i, ])\n    }\n  })\n  \n  \n  ## exit application\n  observeEvent(input$but_exit, {\n    \n    ## remove pin\n    pins::pin_remove(name = pin_name, board = \"HL_board\")\n\n    ## close all windows\n    for (i in 1:nrow(app_windows)) {\n      session$sendCustomMessage(\"close_app\", app_windows[i, ])\n    }\n    \n    ## close window and finish\n    shiny::stopApp()\n    \n  })\n  \n  \n}\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(type = \"text/javascript\", src = \"script.js\")\n  ),\n  br(),\n  br(),\n  fluidRow(column(10, offset = 1, \n                  panel(status = \"primary\", heading = \"App Launcher\",\n                        panel(status = \"danger\", heading = \"Communications\",\n                              uiOutput(\"ui_communications\")\n                        ),\n                        br(),\n                        panel(status = \"danger\", heading = \"App Windows\",\n                              fluidRow(uiOutput(\"ui_app_options\")),\n                              fluidRow(uiOutput(\"ui_app_graphics\")),\n                              fluidRow(uiOutput(\"ui_app_details\"))\n                        )\n                  )\n  ))\n)\n\nshinyApp(ui = ui, server = server)\n\nIn this code, app_windows holds parameters for the three app windows. Two new parameters are included compared to the original version. app now holds the RStudio Connect app refernce number which is used to execute the app and launch_delay is a delay in milliseconds to wait before starting an app - it’s used to ensure that the pin exists before starting the second app."
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html#launcherwwwscript.js",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html#launcherwwwscript.js",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "launcher/www/script.js",
    "text": "launcher/www/script.js\n\nvar shiny_app_options = \"\";\nvar shiny_app_graphics = \"\";\nvar shiny_app_details = \"\";\n\n// launch a shiny app\nShiny.addCustomMessageHandler('launch_app', function(x) {\n  scr_height = window.screen.height;\n  scr_width = window.screen.width;\n  window_height = scr_height * x.height;\n  window_width = scr_width * x.width;\n  window_left = scr_width * x.left;\n  window_top = scr_height * x.top;\n  window_options = \"height=\" + window_height + \", width=\" + window_width + \", left=\" + window_left + \", top=\" + window_top;\n  \n  if (x.name == \"app_options\") {\n    shiny_app_options = window.open(x.url, x.name, window_options);\n  } else if (x.name == \"app_graphics\") {\n    shiny_app_graphics = window.open(x.url, x.name, window_options);\n  } else if (x.name == \"app_details\") {\n    shiny_app_details = window.open(x.url, x.name, window_options);\n  }\n});\n\n// close a shiny app\nShiny.addCustomMessageHandler('close_app', function(x) {\n  // can't pass window name as variable to close so have to hardcode :(\n  if (x.name == \"app_options\") {\n    shiny_app_options.close();\n  } else if (x.name == \"app_graphics\") {\n    shiny_app_graphics.close();\n  } else if (x.name == \"app_details\") {\n    shiny_app_details.close();\n  }\n});\n\n// disable a shiny input\nShiny.addCustomMessageHandler('disable', function(id) {\n  var input_type = $(\"#\" + id).prop(\"type\");\n  if (input_type.startsWith(\"select\")) {\n    $(\"#\" + id)[0].selectize.disable();\n  } else {\n    $(\"#\" + id).prop(\"disabled\", true);\n  }\n});"
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html#app_optionsapp.r",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html#app_optionsapp.r",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "app_options/app.R",
    "text": "app_options/app.R\n\n## app_options\n## A simple app that offers a series of options\n\nlibrary(pins)\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  ## register board\n  pins::board_register_rsconnect(\"HL_board\", account = \"liebeha1\")\n\n  ## extract pin id from url\n  pin_id &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$pin)) {\n      query$pin\n    } else {\n      \"\"\n    }\n  })\n  \n  output$ui_axes &lt;- renderUI({\n    req(input$sel_data)\n    ## select x and y parameters from numeric columns\n    df &lt;- get(input$sel_data)\n    columns &lt;- names(df)[sapply(df, class) == \"numeric\"]\n    tagList(\n      selectizeInput(\"sel_x\", \"X parameter\", choices = columns),\n      selectizeInput(\"sel_y\", \"Y parameter\", choices = columns)\n    )\n  })\n  \n  ## write file when updating parameter\n  observeEvent(input$sel_data, {\n    write_file()\n  })\n  \n  observeEvent(input$sel_x, {\n    write_file()\n  })\n  \n  observeEvent(input$sel_y, {\n    write_file()\n  })\n  \n  ## write a file\n  write_file &lt;- function() {\n    if (pin_id() != \"\") {\n      output &lt;- list(\n        data = input$sel_data,\n        x = input$sel_x,\n        y = input$sel_y\n      )\n      json_out &lt;- toJSON(output, auto_unbox = TRUE, null = \"null\")\n      \n      ## pin data\n      pin(json_out, name = pin_id(), board = \"HL_board\")\n\n    }\n  }\n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Options\", status = \"primary\",\n        selectizeInput(\"sel_data\", \"dataset\", choices = c(\"iris\", \"mtcars\")),\n        uiOutput(\"ui_axes\")\n        )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html#app_graphicsapp.r",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html#app_graphicsapp.r",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "app_graphics/app.R",
    "text": "app_graphics/app.R\n\n## app_graphics\n## A simple app that draws a ggplot\n\nlibrary(pins)\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(ggplot2)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  ## register board\n  pins::board_register_rsconnect(\"HL_board\", account = \"liebeha1\")\n\n  ## extract pin id from url\n  pin_id &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$pin)) {\n      query$pin\n    } else {\n      \"\"\n    }\n  })\n  \n  ## retrieve pin data\n  json_data &lt;- pin_reactive(name = pin_id(), board = \"HL_board\", interval = 2000)\n  \n  output$plt &lt;- renderPlot({\n\n    data &lt;- fromJSON(json_data())\n    params &lt;- c(\"data\", \"x\", \"y\")\n    \n    ## check all plotting parameters are present\n    if (all(sapply(params, function(x) !is.null(data[[x]])))) {\n      ggplot(get(data[[\"data\"]]), aes(x = .data[[data[[\"x\"]]]], y = .data[[data[[\"y\"]]]])) +\n        geom_point() +\n        labs(title = paste0(\"Plot data = \", data[[\"data\"]]),\n             x = data[[\"x\"]], \n             y = data[[\"y\"]])\n    }\n  })\n  \n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Graphics\", status = \"primary\",\n        plotOutput(\"plt\")\n  )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-11-16-multiwindow_all/index.html#app_detailsapp.r",
    "href": "posts/2021/2021-11-16-multiwindow_all/index.html#app_detailsapp.r",
    "title": "Multiwindow App - RStudio Connect and pins",
    "section": "app_details/app.R",
    "text": "app_details/app.R\n\n## app_details\n## A simple app that lists some details\n\nlibrary(pins)\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  ## register board\n  pins::board_register_rsconnect(\"HL_board\", account = \"liebeha1\")\n\n  ## extract pin id from url\n  pin_id &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$pin)) {\n      query$pin\n    } else {\n      \"\"\n    }\n  })\n  \n  ## retrieve pin data\n  json_data &lt;- pin_reactive(name = pin_id(), board = \"HL_board\", interval = 2000)\n\n  output$txt_details &lt;- renderPrint({\n    req(json_data())\n    prettify(json_data())\n  })\n  \n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Output\", status = \"primary\",\n        verbatimTextOutput(\"txt_details\")\n  )\n)\n\nshinyApp(ui, server)\n\nOutput is very similar to the shiny server version. The launcher app now contains an additional button (EXIT) which performs a closedown procedure of closing all the other app windows and removing the pin."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html",
    "title": "{distill} Contact Form",
    "section": "",
    "text": "Can we use use RStudio Connect to build an internal contact form on a {distill} website?\n{distill} is a great R library for building static websites and blogs but has the same limitations of other static websites, namely no server-side programming. This means that implementing a contact form requires using a third party service. This can, however, be accomplished when hosting via RStudio Connect using a plumber API."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#purpose",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#purpose",
    "title": "{distill} Contact Form",
    "section": "",
    "text": "Can we use use RStudio Connect to build an internal contact form on a {distill} website?\n{distill} is a great R library for building static websites and blogs but has the same limitations of other static websites, namely no server-side programming. This means that implementing a contact form requires using a third party service. This can, however, be accomplished when hosting via RStudio Connect using a plumber API."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#attempt-1",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#attempt-1",
    "title": "{distill} Contact Form",
    "section": "Attempt 1",
    "text": "Attempt 1\nThis first attempt works but since we are using a POST request a response is always returned. This means that the webpage is updated with either a null or whatever has been returned by the API function. The output consists of three files with a {distill} R website:\n\nindex.Rmd - a markdown file to hold the contact form\ncontact_form.html - an html contact form that can be inserted into a markdown page\nstyle.css - some css styling (pulled from w3schools)\n\nand a plumber API:\n\nplumber.R - a plumber API\n\nBoth the {distill} static site and plumber API are published to the same RStudio Connect instance.\n\nplumber.R\nThe plumber API takes parameters from a contact form and constructs a linux mail command line, sending a message to a mailbox. The API contains a single POST request to /email.\n\nlibrary(plumber)\n\n#* @apiTitle Email\n\n#* Send out an email message\n#* @param email return email address\n#* @param name sender name\n#* @param subject email subject\n#* @param message email message\n#* @param to recipient email address\n#* @post /email\nfunction(email = NULL, name = NULL, subject = NULL, message = NULL, to = NULL) {\n  \n  ## need a recipient to send an email\n  if (!is.null(to)) {\n    \n    if (is.null(message)) {\n      message &lt;- \"\"\n    } else {\n      message &lt;- gsub(\"\\\\r\", \"\", message)\n    }\n    \n    ## add sender's name\n    if (!is.null(name)) {\n      message &lt;- paste0(message, \"\\n\\nFrom: \", name)\n    }\n    \n    ## build up email string\n    email_string &lt;- \"echo -e \"\n    email_string &lt;- paste0(email_string, \"\\\"\", message, \"\\\" | mail \")\n    \n    if (!is.null(subject)) {\n      email_string &lt;- paste0(email_string, \"-s \\\"\", subject, \"\\\" \")\n    } else {\n      email_string &lt;- paste0(email_string, \"-s \\\"no subject\\\" \")\n    }\n    \n    if (!is.null(email)) {\n      email_string &lt;- paste0(email_string, \"-S from=\", email, \" \")\n    }\n    \n    email_string &lt;- paste0(email_string, to)\n    \n    system(email_string)\n    return(email_string)\n  }\n}\n\n\n\nindex.Rmd\n\n---\ntitle: \"Test Contact 1\"\n---\n\n```{r, echo=FALSE}\nhtmltools::includeCSS(\"style.css\")\n\nhtmltools::includeHTML(\"contact_form.html\")\n```\n\n\n\ncontact_form.html\n&lt;div class=\"form-container\"&gt;\n  &lt;form action=\"*url pointing to API*\" id=\"my-form\" method=\"POST\"&gt;\n    \n    &lt;label for=\"name\"&gt;Name&lt;/label&gt;\n    &lt;input type=\"text\" id=\"name\" name=\"name\" placeholder=\"Your name..\"&gt;\n    \n    &lt;label for=\"email\"&gt;Email&lt;/label&gt;\n    &lt;input type=\"text\" id=\"email\" name=\"email\" placeholder=\"Your email address..\"&gt;\n      \n    &lt;label for=\"subject\"&gt;Subject&lt;/label&gt;\n    &lt;input type=\"text\" id=\"subject\" name=\"subject\" placeholder=\"Subject\"&gt;\n                \n    &lt;label for=\"message\"&gt;Message&lt;/label&gt;\n    &lt;textarea id=\"message\" name=\"message\" placeholder=\"Your message..\" style=\"height:200px\"&gt;&lt;/textarea&gt;\n  \n    &lt;input type=\"hidden\" name=\"to\" value=\"*mailbox*\" /&gt;\n                    \n    &lt;input type=\"submit\" value=\"Submit\"&gt;\n  \n  &lt;/form&gt;\n&lt;/div&gt;\nIn the contact_form.html file, url pointing to API (line 2) refers to the url of the plumber API, hosted on the same RStudio Connect server as the distill site. mailbox (line 16) refers to the receiving mailbox. It is included as a hidden element in the form so that it may be passed to the API."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#style.css",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#style.css",
    "title": "{distill} Contact Form",
    "section": "style.css",
    "text": "style.css\ninput[type=text], select, textarea {\n  width: 100%; /* Full width */\n  padding: 12px; /* Some padding */ \n  border: 1px solid #ccc; /* Gray border */\n  border-radius: 4px; /* Rounded borders */\n  box-sizing: border-box; /* Make sure that padding and width stays in place */\n  margin-top: 6px; /* Add a top margin */\n  margin-bottom: 16px; /* Bottom margin */\n  resize: vertical /* Allow the user to vertically resize the textarea (not horizontally) */\n}\n\n/* Style the submit button with a specific background color etc */\ninput[type=submit] {\n  background-color: #04AA6D;\n  color: white;\n  padding: 12px 20px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n/* When moving the mouse over the submit button, add a darker green color */\ninput[type=submit]:hover {\n  background-color: #45a049;\n}\n\n/* Add a background color and some padding around the form */\n.form-container {\n  border-radius: 5px;\n  background-color: #f2f2f2;\n  padding: 20px;\n}"
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#attempt-2",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#attempt-2",
    "title": "{distill} Contact Form",
    "section": "Attempt 2",
    "text": "Attempt 2\nThe second attempt builds on the first. Here the submit button is intercepted by a little javascript function which executes the POST request and captures the output. Running this way means that the webpage does not update once the request is run. In addition, we can trigger notification that the form was sent (in this case a simple alert).\nHere we have four files with a {distill} R website:\n\nindex.Rmd - a markdown file to hold the contact form\ncontact_form.html - an html contact form that can be inserted into a markdown page\nstyle.css - some css styling (pulled from w3schools)\nscript.js - javascript function to intercept the submit button press\n\nand a plumber API:\n\nplumber.R - a plumber API\n\nBoth the {distill} static site and plumber API are published to the same RStudio Connect instance.\n\nplumber.R\nThe plumber API differs from the one in Attempt 1 by reading a json encoded version of the body. The API contains a single POST request to /email.\n\nlibrary(plumber)\nlibrary(jsonlite)\n\n#* @apiTitle Email\n\n#* Send out an email message\n#* @param req request body\n#* @post /email\nfunction(req) {\n  \n  ## get the message body\n  body &lt;- jsonlite::fromJSON(req$postBody)\n  \n  email &lt;- body$email\n  name &lt;- body$name\n  subject &lt;- body$subject\n  to &lt;- body$to\n  message &lt;- body$message\n  \n  ## need a recipient to send an email\n  if (!is.null(to)) {\n    \n    if (is.null(message)) {\n      message &lt;- \"\"\n    } else {\n      message &lt;- gsub(\"\\\\r\", \"\", message)\n    }\n    \n    ## add sender's name\n    if (!is.null(name)) {\n      message &lt;- paste0(message, \"\\n\\nFrom: \", name)\n    }\n    \n    ## build up email string\n    email_string &lt;- \"echo -e \"\n    email_string &lt;- paste0(email_string, \"\\\"\", message, \"\\\" | mail \")\n    \n    if (!is.null(subject)) {\n      email_string &lt;- paste0(email_string, \"-s \\\"\", subject, \"\\\" \")\n    } else {\n      email_string &lt;- paste0(email_string, \"-s \\\"no subject\\\" \")\n    }\n    \n    if (!is.null(email)) {\n      email_string &lt;- paste0(email_string, \"-S from=\", email, \" \")\n    }\n    \n    email_string &lt;- paste0(email_string, to)\n    \n    system(email_string)\n    return(email_string)\n  }\n}\n\n\n\nindex.Rmd\nThe markdown file is very similar to the original, with an additional line to include the javascript file.\n\n---\ntitle: \"Test Contact 1\"\n---\n\n```{r, echo=FALSE}\nhtmltools::includeCSS(\"style.css\")\nhtmltools::includeScript(\"script.js\")\n\nhtmltools::includeHTML(\"contact_form.html\")\n```\n\n\n\ncontact_form.html\nThe contact form does not change significantly from the original, the only difference being the removal of method=“POST” in the form element.\n&lt;div class=\"form-container\"&gt;\n  &lt;form action=\"*url pointing to API*\" id=\"my-form\"&gt;\n    \n    &lt;label for=\"name\"&gt;Name&lt;/label&gt;\n    &lt;input type=\"text\" id=\"name\" name=\"name\" placeholder=\"Your name..\"&gt;\n    \n    &lt;label for=\"email\"&gt;Email&lt;/label&gt;\n    &lt;input type=\"text\" id=\"email\" name=\"email\" placeholder=\"Your email address..\"&gt;\n      \n    &lt;label for=\"subject\"&gt;Subject&lt;/label&gt;\n    &lt;input type=\"text\" id=\"subject\" name=\"subject\" placeholder=\"Subject\"&gt;\n                \n    &lt;label for=\"message\"&gt;Message&lt;/label&gt;\n    &lt;textarea id=\"message\" name=\"message\" placeholder=\"Your message..\" style=\"height:200px\"&gt;&lt;/textarea&gt;\n  \n    &lt;input type=\"hidden\" name=\"to\" value=\"*mailbox*\" /&gt;\n                    \n    &lt;input type=\"submit\" value=\"Submit\"&gt;\n  \n  &lt;/form&gt;\n&lt;/div&gt;\nIn the contact_form.html file, url pointing to API (line 2) refers to the url of the plumber API, hosted on the same RStudio Connect server as the distill site. mailbox (line 16) refers to the receiving mailbox. It is included as a hidden element in the form so that it may be passed to the API."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#style.css-1",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#style.css-1",
    "title": "{distill} Contact Form",
    "section": "style.css",
    "text": "style.css\nNo change to the style.css file."
  },
  {
    "objectID": "posts/2021/2021-09-08-distill_contact_form/index.html#script.js",
    "href": "posts/2021/2021-09-08-distill_contact_form/index.html#script.js",
    "title": "{distill} Contact Form",
    "section": "script.js",
    "text": "script.js\n\nwindow.addEventListener(\"load\", function() {\n\n  document.getElementById(\"my-form-2\").addEventListener(\"submit\", formsubmit);\n\n  async function formsubmit(e) {\n    \n    e.preventDefault();\n    \n    // get event-handler element\n    const form = e.currentTarget;\n    \n    // get form url\n    const url = form.action;\n    \n    // get form data as json string\n    formdata = new FormData(form);\n    const plainFormData = Object.fromEntries(formdata.entries());\n    const jsonFormData = JSON.stringify(plainFormData);\n    \n    // send request and capture output\n    out = await fetch(form.action, {\n      method: 'POST',\n      body: jsonFormData,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n      }\n    });\n    \n    // notification of sent message\n    alert(\"message sent to \" + plainFormData.to);\n\n  }\n\n});\n\nin this case we have a contact form which sends a message to an email inbox. A simple alert confirms that the form has been intercepted and an email sent. The contact form looks as follows:"
  },
  {
    "objectID": "posts/2021/2021-07-22-tidyselect/index.html",
    "href": "posts/2021/2021-07-22-tidyselect/index.html",
    "title": "Using tidyselect in your own package",
    "section": "",
    "text": "The {tidyselect} package powers column selection for {dplyr}, {tidyr} and {recipes} functions but it’s also quite straight-forward to include its functonality in other user-built functions. Here’s an example which replaces a percentage of a data frame by NA. It works by using the tidyselect::eval_select function to select columns and then replaces a portion of the data with NA values.\nColumn selections are passed to the function through dot-dot-dot, allowing an arbitrary number of columns to be selected. The first line of the function:\nexpr &lt;- rlang::expr(c(...))\nreturns a defused expression, and the second:\npos &lt;- tidyselect::eval_select(expr, data = data)\nresumes execution, returning a vector of positions that match the selection. More details on how to implement tidyselect interfaces is available at the tidyselect pkgdown page.\n#' populate data frame with missing data\n#'\n#' Replace a proportion of data in a data frame with missing values\n#'\n#' @param data A data frame\n#' @param p proporion (between 0 and 100) of data in column to be flagged as missing\n#' @param ... `&lt;tidy-select&gt;` One or more unquoted expressions separated by commas\n#'\n#' @return data frame\n#'\n#' @importFrom rlang expr\n#' @importFrom tidyselect vars_select\n#' @export\nadd_missing_df &lt;- function(data, ..., p = 10) {\n  expr &lt;- rlang::expr(c(...))\n  pos &lt;- tidyselect::eval_select(expr, data = data)\n  if (length(pos) &gt; 0) {\n    for (posn in pos) {\n      missing_rows &lt;- sample(nrow(data), size = as.integer(nrow(data) * p / 100))\n      if (length(missing_rows) &gt; 0) {\n        data[missing_rows, posn] &lt;- NA\n      }\n    }\n  }\n  return(data)\n}"
  },
  {
    "objectID": "posts/2021/2021-07-22-tidyselect/index.html#examples",
    "href": "posts/2021/2021-07-22-tidyselect/index.html#examples",
    "title": "Using tidyselect in your own package",
    "section": "Examples",
    "text": "Examples\nAll of the {tidyselect} selectors may be used, along with the {magrittr} pipe if loaded. Some examples of use are:\n\n# remove 40% of data in columns mpg to hp\nadd_missing_df(mtcars, p=40, mpg:hp)\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4             NA   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6    NA  NA 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8  NA 108.0  NA 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive        NA   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360            NA   8 360.0  NA 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4  NA 146.7  NA 3.69 3.190 20.00  1  0    4    2\nMerc 230              NA   4 140.8  NA 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2  NA    NA 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6    NA 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE            NA   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3  NA 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC           NA   8 275.8  NA 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8    NA 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial     NA   8    NA 230 3.23 5.345 17.42  0  0    3    4\nFiat 128              NA   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4    NA  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9  NA    NA  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5  NA 120.1  NA 3.70 2.465 20.01  1  0    3    1\nDodge Challenger      NA  NA    NA  NA 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8    NA 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28            NA  NA 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0  NA 3.08 3.845 17.05  0  0    3    2\nFiat X1-9             NA  NA  79.0  NA 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0  NA    NA  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1  NA 3.77 1.513 16.90  1  1    5    2\nFord Pantera L        NA   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7  NA 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8    NA  NA 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4  NA    NA 109 4.11 2.780 18.60  1  1    4    2\n\n\n\n# remove 10% of data in columns that start with \"d\" (dist and drat)\nmtcars %&gt;% add_missing_df(tidyselect::starts_with(\"d\"))\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6    NA 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8    NA 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150   NA 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245   NA 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4    NA 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264   NA 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2"
  },
  {
    "objectID": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html",
    "href": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html",
    "title": "Passing a Mixture of Reactive and Non-Reactives to a Shiny Module",
    "section": "",
    "text": "Generally there is no issue in sending a list of parameters (reactive and non-reactive) to a shiny module. Here’s an example where a shiny module would be called multiple times, programatically, where the reactive nature of the parameters may be variable (reactive in one instance but not in another). One way to deal with this is to read in the list of parameters and convert the non-reactive ones to reactive. Those originally reactive, remain so and therefore update on a change. In the examples below a single reactive or non-reactive list is passed from the parent shiny app to a shiny module. The concept works for a single or multiple inputs."
  },
  {
    "objectID": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-1---this-shiny-module-will-fail",
    "href": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-1---this-shiny-module-will-fail",
    "title": "Passing a Mixture of Reactive and Non-Reactives to a Shiny Module",
    "section": "Example 1 - this shiny module will fail",
    "text": "Example 1 - this shiny module will fail\nThis version of the shiny module fill fail - it expects a reactive but is passed a non-reactive.\n\nlibrary(shiny)\n\nappmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  verbatimTextOutput(ns(\"txt\"))\n}\n\nappmod &lt;- function(input, output, session, inputlist) {\n\n  output$txt &lt;- renderPrint({\n    message(\"Updating renderPrint\")\n    print(inputlist()[[\"val1\"]])\n    print(inputlist()[[\"val2\"]])\n  })\n\n}\n\nui &lt;- fluidPage(\n  appmod_UI(\"mod1\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  callModule(appmod, \"mod1\", inputlist = list(val1 = \"value 1\", val2 = \"value 2\"))\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-2---reacive-expected-and-reactive-passed",
    "href": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-2---reacive-expected-and-reactive-passed",
    "title": "Passing a Mixture of Reactive and Non-Reactives to a Shiny Module",
    "section": "Example 2 - reacive expected and reactive passed",
    "text": "Example 2 - reacive expected and reactive passed\nThis is a simple example of a shiny module that will work. It expects a reactive which is exactly what is passed to the module.\n\nlibrary(shiny)\n\nappmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  verbatimTextOutput(ns(\"txt\"))\n}\n\nappmod &lt;- function(input, output, session, inputlist) {\n\n  message(\"Starting shiny module\")\n\n  if (is.reactive(inputlist)) {\n    message(\"Returning inputlist\")\n    inputlist_1 &lt;- inputlist\n  } else {\n    message(\"Returning reactive inputlist\")\n    inputlist_1 &lt;- reactive(inputlist)\n  }\n\n  output$txt &lt;- renderPrint({\n    message(\"Updating renderPrint\")\n    print(inputlist_1()[[\"val1\"]])\n    print(inputlist_1()[[\"val2\"]])\n  })\n\n}\n\nui &lt;- fluidPage(\n  appmod_UI(\"mod1\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  callModule(appmod, \"mod1\", inputlist = reactive(list(val1 = \"value 1\", val2 = \"value 2\")))\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-3---reacive-expected-and-non-reactive-passed",
    "href": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-3---reacive-expected-and-non-reactive-passed",
    "title": "Passing a Mixture of Reactive and Non-Reactives to a Shiny Module",
    "section": "Example 3 - reacive expected and non-reactive passed",
    "text": "Example 3 - reacive expected and non-reactive passed\nAnother example of a shiny module that will work. In this case the non-reactive passed to the shiny module is converted into a reactive.\n\nlibrary(shiny)\n\nappmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  verbatimTextOutput(ns(\"txt\"))\n}\n\nappmod &lt;- function(input, output, session, inputlist) {\n\n  message(\"Starting shiny module\")\n\n  if (is.reactive(inputlist)) {\n    message(\"Returning inputlist\")\n    inputlist_1 &lt;- inputlist\n  } else {\n    message(\"Returning reactive inputlist\")\n    inputlist_1 &lt;- reactive(inputlist)\n  }\n\n  output$txt &lt;- renderPrint({\n    message(\"Updating renderPrint\")\n    print(inputlist_1()[[\"val1\"]])\n    print(inputlist_1()[[\"val2\"]])\n  })\n}\n\nui &lt;- fluidPage(\n  appmod_UI(\"mod1\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  callModule(appmod, \"mod1\", inputlist = list(val1 = \"value 1\", val2 = \"value 2\"))\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-4---reacive-expected-and-non-reactive-passed",
    "href": "posts/2021/2021-06-20-reactive_and_nonreactive/index.html#example-4---reacive-expected-and-non-reactive-passed",
    "title": "Passing a Mixture of Reactive and Non-Reactives to a Shiny Module",
    "section": "Example 4 - reacive expected and non-reactive passed",
    "text": "Example 4 - reacive expected and non-reactive passed\nFinal example of a shiny module that will work. In this case a reactive is passed and then changed (forcing an update in the shiny module).\n\nlibrary(shiny)\n\nappmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  verbatimTextOutput(ns(\"txt\"))\n}\n\nappmod &lt;- function(input, output, session, inputlist) {\n\n  message(\"Starting shiny module\")\n\n  if (is.reactive(inputlist)) {\n    message(\"Returning inputlist\")\n    inputlist_1 &lt;- inputlist\n  } else {\n    message(\"Returning reactive inputlist\")\n    inputlist_1 &lt;- reactive(inputlist)\n  }\n\n  output$txt &lt;- renderPrint({\n    message(\"Updating renderPrint\")\n    print(inputlist_1()[[\"val1\"]])\n    print(inputlist_1()[[\"val2\"]])\n  })\n\n\n}\n\nui &lt;- fluidPage(\n  appmod_UI(\"mod1\"),\n  actionButton(\"but_update\", \"Update Values\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  rv &lt;- reactiveValues(\n    i = list()\n  )\n\n  observe({\n    message(\"Define initial values\")\n    rv$i &lt;- list(val1 = \"value 1\", val2 = \"value 2\")\n  })\n\n  callModule(appmod, \"mod1\", inputlist = reactive(rv$i))\n\n  observeEvent(input$but_update, {\n    message(\"Button press\")\n    rv$i[[\"val1\"]] &lt;- \"value 3\"\n  })\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-05-19-beer_trip/index.html",
    "href": "posts/2021/2021-05-19-beer_trip/index.html",
    "title": "Beer Trip Around the World",
    "section": "",
    "text": "The traveling salesperson problem (TSP) is an NP-complete problem that asks given a list of cities, what’s the shortest path that can be taken so that each city is visited once and you end up back where you started. Exact solutions to the problem exist but they become impractical as soon as the number of cities increases above 20 therefore approximations are generally performed that yield a suitable, if not best, solution.\nHere we take a fun approach from a thought experiment. What if I could idenfity the best beers in the World and drink them in the breweries in which they are brewed. With a limited time and budget, wouldn’t this be a traveling salesperson problem? With this is mind I quickly drew up the following solution using the {TSP} R package."
  },
  {
    "objectID": "posts/2021/2021-05-19-beer_trip/index.html#step-1---gather-and-wrangle-the-data",
    "href": "posts/2021/2021-05-19-beer_trip/index.html#step-1---gather-and-wrangle-the-data",
    "title": "Beer Trip Around the World",
    "section": "Step 1 - Gather and wrangle the data",
    "text": "Step 1 - Gather and wrangle the data\nData were retrieved from Kaggle. Kaggle contains a few beer datasets but the one chosen (https://www.kaggle.com/ehallmar/beers-breweries-and-beer-reviews) contains beers, reviews and breweries, making our life much easier. Once data were downloaded we could identify top-rated beers and join brewery details to produce a single, neat data frame.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(here)\n\n## read in beer data\ndf_beers &lt;- read_csv(here(\"data/beers.csv\"))\n\n## read in beer ratings\ndf_ratings &lt;- read_csv(here(\"data/reviews.csv\"))\n\n## read in breweries\ndf_breweries &lt;- read_csv(here(\"data/breweries.csv\"))\n\n## summarize ratings by beer and sort\ndf_rating_summary &lt;- df_ratings %&gt;%\n  group_by(beer_id) %&gt;%\n  summarise(rating = mean(score, na.rm = TRUE)) %&gt;%\n  arrange(desc(rating)) %&gt;%\n  filter(rating &gt;= 4.75)\n\n## add ratings summary to beer data frame\ndf_beer_ratings &lt;- df_beers %&gt;%\n  right_join(df_rating_summary, by = c(\"id\" = \"beer_id\")) %&gt;%\n  filter(retired == FALSE)\n\n## add brewery details\ndf_beer_ratings &lt;- df_beer_ratings %&gt;% \n  select(id, beer=name, brewery_id, rating, abv) %&gt;%\n  left_join(df_breweries %&gt;% select(id, brewery=name, city, state, country), by = c(\"brewery_id\" = \"id\")) %&gt;% \n  arrange(desc(rating))\n\n## limit to single occurrence of each brewery\ndf_beer_ratings &lt;- df_beer_ratings %&gt;%\n  group_by(brewery_id) %&gt;%\n  arrange(desc(rating), desc(abv)) %&gt;%\n  slice(1) %&gt;%\n  ungroup()"
  },
  {
    "objectID": "posts/2021/2021-05-19-beer_trip/index.html#step-2---convert-locations-to-longitudelatitude",
    "href": "posts/2021/2021-05-19-beer_trip/index.html#step-2---convert-locations-to-longitudelatitude",
    "title": "Beer Trip Around the World",
    "section": "Step 2 - Convert locations to longitude/latitude",
    "text": "Step 2 - Convert locations to longitude/latitude\nNow we have a table with locations we can easily convert the locations to longitude/latitude values which will be used to calculate distances. First we need to convert the county code from a two-character abbreviation and then we can use {tidygeocoder} to convert to longitude and latitude.\n\nlibrary(countrycode)\nlibrary(tidygeocoder)\n\n## build city addresses\ndf_beer_ratings &lt;- df_beer_ratings %&gt;%\n  mutate(country_name = countrycode(country, origin = \"iso2c\", destination = \"country.name\")) %&gt;%\n  mutate(address = if_else(country == \"US\", paste(city, state, \"USA\", sep = \", \"), paste(city, country_name, sep = \", \")))\n\n## take the first 300 locations\ndf_use_locations &lt;- df_beer_ratings %&gt;%\n  slice(1:300)\n\n## determine longitude and latitude\ndf_address &lt;- geo(df_use_locations$address, method = \"cascade\")\n\n## bind locations to data frame\ndf_use_locations &lt;- bind_cols(df_use_locations, df_address %&gt;% select(lat, long)) %&gt;%\n  filter(!is.na(lat), !is.na(long))"
  },
  {
    "objectID": "posts/2021/2021-05-19-beer_trip/index.html#step-3---build-a-distance-matrix-and-run-tsp",
    "href": "posts/2021/2021-05-19-beer_trip/index.html#step-3---build-a-distance-matrix-and-run-tsp",
    "title": "Beer Trip Around the World",
    "section": "Step 3 - Build a distance matrix and run TSP",
    "text": "Step 3 - Build a distance matrix and run TSP\nOnce we have a list of longitude/latitude pairs we can build a distance matrix of the distances between each location (default measurement = meters). From this we can solve the traveling salesperson problem. In this example TSP is solved 1000 times and the distance (in miles) plotted. Finally, the shortest tour is plotted using leaflet.\n\nlibrary(geodist)\nlibrary(TSP)\nlibrary(leaflet)\n\n## build a distance matrix\ndist_m &lt;- geodist(df_use_locations %&gt;% select(lat, long), measure = \"geodesic\")\n\n## build TSP and solve 1000 times\nset.seed(1234)\ntsp &lt;- TSP(dist_m, labels = df_use_locations$address)\nbeer_trip &lt;- lapply(seq(1000), function(x) solve_TSP(tsp))\n\n## plot results and identify the shortest tour\ntours &lt;- sapply(beer_trip, tour_length) / 1609.34\nplot(tours, type = \"l\", ylab = \"tour length (miles)\")\nshortest_tour &lt;- which.min(tours)\n\n\n## reorder locations according to shortest tour\nref_order &lt;- unlist(lapply(beer_trip[[shortest_tour]], function(x) x), use.names = FALSE)\ndf_solution &lt;- df_use_locations[ref_order, ]\ndf_solution[nrow(df_solution) + 1, ] &lt;- df_solution[1, ]\n\n## plot tour on leaflet map\nleaflet(data = df_solution) %&gt;% \n  addTiles() %&gt;% \n  addCircleMarkers(~long, ~lat, popup = ~brewery, radius = 2, color = \"red\") %&gt;% \n  addPolylines(~long, ~lat, weight = 4)\n\n\n\n&lt;/section&gt;\n&lt;section id=\"conclusion\" class=\"level2\"&gt;\n&lt;h2&gt;Conclusion&lt;/h2&gt;\n&lt;p&gt;The data may or may not be the best quality but the concept holds true. Total length of trip (between 297 locations) = 50718 miles.&lt;/p&gt;\n&lt;div id=\"quarto-navigation-envelope\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1zaWRlYmFyLXRpdGxl\"&gt;Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXItdGl0bGU=\"&gt;Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6QWJvdXQ=\"&gt;About&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2Fib3V0Lmh0bWw=\"&gt;/about.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6QmxvZw==\"&gt;Blog&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L3Bvc3Rz\"&gt;/posts&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6e3s8IGxpIHl2amltcGp1IHRyaWdnZXI9aG92ZXIgY29sb3JzPXByaW1hcnk6I2ZmZmZmZixzZWNvbmRhcnk6I2M3ZTBlYiA+fX0=\"&gt;&lt;lord-icon src=\"https://cdn.lordicon.com/yvjimpju.json\" colors=\"primary:#ffffff,secondary:#c7e0eb\" trigger=\"hover\" &gt;&lt;/lord-icon&gt;&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6aHR0cHM6Ly9naXRodWIuY29tL2hhcnZleWw4ODg=\"&gt;https://github.com/harveyl888&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6e3s8IGxpIHdsYnltaG9vIHRyaWdnZXI9aG92ZXIgY29sb3JzPXByaW1hcnk6I2ZmZmZmZixzZWNvbmRhcnk6I2M3ZTBlYiA+fX0=\"&gt;&lt;lord-icon src=\"https://cdn.lordicon.com/wlbymhoo.json\" colors=\"primary:#ffffff,secondary:#c7e0eb\" trigger=\"hover\" &gt;&lt;/lord-icon&gt;&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6aHR0cHM6Ly90d2l0dGVyLmNvbS9oYXJ2ZXlsODg4\"&gt;https://twitter.com/harveyl888&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6e3s8IGxpIHFnZWJ3dXRlIHRyaWdnZXI9aG92ZXIgY29sb3JzPXByaW1hcnk6I2ZmZmZmZixzZWNvbmRhcnk6I2M3ZTBlYiA+fX0=\"&gt;&lt;lord-icon src=\"https://cdn.lordicon.com/qgebwute.json\" colors=\"primary:#ffffff,secondary:#c7e0eb\" trigger=\"hover\" &gt;&lt;/lord-icon&gt;&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6aHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2hhcnZleS1saWViZXJtYW4=\"&gt;https://www.linkedin.com/in/harvey-lieberman&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;div id=\"quarto-meta-markdown\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW1ldGF0aXRsZQ==\"&gt;Beer Trip Around the World – Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkdGl0bGU=\"&gt;Beer Trip Around the World – Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW9nY2FyZHRpdGxl\"&gt;Beer Trip Around the World – Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW1ldGFzaXRlbmFtZQ==\"&gt;Harvey Lieberman&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkZGVzYw==\"&gt;Traveling Salesman Problem between breweries&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW9nY2FyZGRkZXNj\"&gt;Traveling Salesman Problem between breweries&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;/section&gt;\n\n&lt;/main&gt; &lt;!-- /main --&gt;\n&lt;script id = \"quarto-html-after-body\" type=\"application/javascript\"&gt;\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const toggleBodyColorMode = (bsSheetEl) =&gt; {\n    const mode = bsSheetEl.getAttribute(\"data-mode\");\n    const bodyEl = window.document.querySelector(\"body\");\n    if (mode === \"dark\") {\n      bodyEl.classList.add(\"quarto-dark\");\n      bodyEl.classList.remove(\"quarto-light\");\n    } else {\n      bodyEl.classList.add(\"quarto-light\");\n      bodyEl.classList.remove(\"quarto-dark\");\n    }\n  }\n  const toggleBodyColorPrimary = () =&gt; {\n    const bsSheetEl = window.document.querySelector(\"link#quarto-bootstrap\");\n    if (bsSheetEl) {\n      toggleBodyColorMode(bsSheetEl);\n    }\n  }\n  toggleBodyColorPrimary();  \n  const disableStylesheet = (stylesheets) =&gt; {\n    for (let i=0; i &lt; stylesheets.length; i++) {\n      const stylesheet = stylesheets[i];\n      stylesheet.rel = 'prefetch';\n    }\n  }\n  const enableStylesheet = (stylesheets) =&gt; {\n    for (let i=0; i &lt; stylesheets.length; i++) {\n      const stylesheet = stylesheets[i];\n      stylesheet.rel = 'stylesheet';\n    }\n  }\n  const manageTransitions = (selector, allowTransitions) =&gt; {\n    const els = window.document.querySelectorAll(selector);\n    for (let i=0; i &lt; els.length; i++) {\n      const el = els[i];\n      if (allowTransitions) {\n        el.classList.remove('notransition');\n      } else {\n        el.classList.add('notransition');\n      }\n    }\n  }\n  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) =&gt; {\n    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';\n    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';\n    let newTheme = '';\n    if(darkModeDefault) {\n      newTheme = isAlternate ? baseTheme : alternateTheme;\n    } else {\n      newTheme = isAlternate ? alternateTheme : baseTheme;\n    }\n    const changeGiscusTheme = () =&gt; {\n      // From: https://github.com/giscus/giscus/issues/336\n      const sendMessage = (message) =&gt; {\n        const iframe = document.querySelector('iframe.giscus-frame');\n        if (!iframe) return;\n        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');\n      }\n      sendMessage({\n        setConfig: {\n          theme: newTheme\n        }\n      });\n    }\n    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;\n    if (isGiscussLoaded) {\n      changeGiscusTheme();\n    }\n  }\n  const toggleColorMode = (alternate) =&gt; {\n    // Switch the stylesheets\n    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');\n    manageTransitions('#quarto-margin-sidebar .nav-link', false);\n    if (alternate) {\n      enableStylesheet(alternateStylesheets);\n      for (const sheetNode of alternateStylesheets) {\n        if (sheetNode.id === \"quarto-bootstrap\") {\n          toggleBodyColorMode(sheetNode);\n        }\n      }\n    } else {\n      disableStylesheet(alternateStylesheets);\n      toggleBodyColorPrimary();\n    }\n    manageTransitions('#quarto-margin-sidebar .nav-link', true);\n    // Switch the toggles\n    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');\n    for (let i=0; i &lt; toggles.length; i++) {\n      const toggle = toggles[i];\n      if (toggle) {\n        if (alternate) {\n          toggle.classList.add(\"alternate\");     \n        } else {\n          toggle.classList.remove(\"alternate\");\n        }\n      }\n    }\n    // Hack to workaround the fact that safari doesn't\n    // properly recolor the scrollbar when toggling (#1455)\n    if (navigator.userAgent.indexOf('Safari') &gt; 0 && navigator.userAgent.indexOf('Chrome') == -1) {\n      manageTransitions(\"body\", false);\n      window.scrollTo(0, 1);\n      setTimeout(() =&gt; {\n        window.scrollTo(0, 0);\n        manageTransitions(\"body\", true);\n      }, 40);  \n    }\n  }\n  const isFileUrl = () =&gt; { \n    return window.location.protocol === 'file:';\n  }\n  const hasAlternateSentinel = () =&gt; {  \n    let styleSentinel = getColorSchemeSentinel();\n    if (styleSentinel !== null) {\n      return styleSentinel === \"alternate\";\n    } else {\n      return false;\n    }\n  }\n  const setStyleSentinel = (alternate) =&gt; {\n    const value = alternate ? \"alternate\" : \"default\";\n    if (!isFileUrl()) {\n      window.localStorage.setItem(\"quarto-color-scheme\", value);\n    } else {\n      localAlternateSentinel = value;\n    }\n  }\n  const getColorSchemeSentinel = () =&gt; {\n    if (!isFileUrl()) {\n      const storageValue = window.localStorage.getItem(\"quarto-color-scheme\");\n      return storageValue != null ? storageValue : localAlternateSentinel;\n    } else {\n      return localAlternateSentinel;\n    }\n  }\n  const darkModeDefault = false;\n  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';\n  // Dark / light mode switch\n  window.quartoToggleColorScheme = () =&gt; {\n    // Read the current dark / light value \n    let toAlternate = !hasAlternateSentinel();\n    toggleColorMode(toAlternate);\n    setStyleSentinel(toAlternate);\n    toggleGiscusIfUsed(toAlternate, darkModeDefault);\n  };\n  // Ensure there is a toggle, if there isn't float one in the top right\n  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {\n    const a = window.document.createElement('a');\n    a.classList.add('top-right');\n    a.classList.add('quarto-color-scheme-toggle');\n    a.href = \"\";\n    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };\n    const i = window.document.createElement(\"i\");\n    i.classList.add('bi');\n    a.appendChild(i);\n    window.document.body.appendChild(a);\n  }\n  // Switch to dark mode if need be\n  if (hasAlternateSentinel()) {\n    toggleColorMode(true);\n  } else {\n    toggleColorMode(false);\n  }\n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const isCodeAnnotation = (el) =&gt; {\n    for (const clz of el.classList) {\n      if (clz.startsWith('code-annotation-')) {                     \n        return true;\n      }\n    }\n    return false;\n  }\n  const onCopySuccess = function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    var currentTitle = button.getAttribute(\"title\");\n    button.setAttribute(\"title\", \"Copied!\");\n    let tooltip;\n    if (window.bootstrap) {\n      button.setAttribute(\"data-bs-toggle\", \"tooltip\");\n      button.setAttribute(\"data-bs-placement\", \"left\");\n      button.setAttribute(\"data-bs-title\", \"Copied!\");\n      tooltip = new bootstrap.Tooltip(button, \n        { trigger: \"manual\", \n          customClass: \"code-copy-button-tooltip\",\n          offset: [0, -8]});\n      tooltip.show();    \n    }\n    setTimeout(function() {\n      if (tooltip) {\n        tooltip.hide();\n        button.removeAttribute(\"data-bs-title\");\n        button.removeAttribute(\"data-bs-toggle\");\n        button.removeAttribute(\"data-bs-placement\");\n      }\n      button.setAttribute(\"title\", currentTitle);\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  }\n  const getTextToCopy = function(trigger) {\n      const codeEl = trigger.previousElementSibling.cloneNode(true);\n      for (const childEl of codeEl.children) {\n        if (isCodeAnnotation(childEl)) {\n          childEl.remove();\n        }\n      }\n      return codeEl.innerText;\n  }\n  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {\n    text: getTextToCopy\n  });\n  clipboard.on('success', onCopySuccess);\n  if (window.document.getElementById('quarto-embedded-source-code-modal')) {\n    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {\n      text: getTextToCopy,\n      container: window.document.getElementById('quarto-embedded-source-code-modal')\n    });\n    clipboardModal.on('success', onCopySuccess);\n  }\n    var localhostRegex = new RegExp(/^(?:http|https):\\/\\/localhost\\:?[0-9]*\\//);\n    var mailtoRegex = new RegExp(/^mailto:/);\n      var filterRegex = new RegExp('/' + window.location.host + '/');\n    var isInternal = (href) =&gt; {\n        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);\n    }\n    // Inspect non-navigation links and adorn them if external\n \tvar links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');\n    for (var i=0; i&lt;links.length; i++) {\n      const link = links[i];\n      if (!isInternal(link.href)) {\n        // undo the damage that might have been done by quarto-nav.js in the case of\n        // links that we want to consider external\n        if (link.dataset.originalHref !== undefined) {\n          link.href = link.dataset.originalHref;\n        }\n      }\n    }\n  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {\n    const config = {\n      allowHTML: true,\n      maxWidth: 500,\n      delay: 100,\n      arrow: false,\n      appendTo: function(el) {\n          return el.parentElement;\n      },\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start',\n    };\n    if (contentFn) {\n      config.content = contentFn;\n    }\n    if (onTriggerFn) {\n      config.onTrigger = onTriggerFn;\n    }\n    if (onUntriggerFn) {\n      config.onUntrigger = onUntriggerFn;\n    }\n    window.tippy(el, config); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i&lt;noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      // use id or data attribute instead here\n      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');\n      try { href = new URL(href).hash; } catch {}\n      const id = href.replace(/^#\\/?/, \"\");\n      const note = window.document.getElementById(id);\n      if (note) {\n        return note.innerHTML;\n      } else {\n        return \"\";\n      }\n    });\n  }\n  const xrefs = window.document.querySelectorAll('a.quarto-xref');\n  const processXRef = (id, note) =&gt; {\n    // Strip column container classes\n    const stripColumnClz = (el) =&gt; {\n      el.classList.remove(\"page-full\", \"page-columns\");\n      if (el.children) {\n        for (const child of el.children) {\n          stripColumnClz(child);\n        }\n      }\n    }\n    stripColumnClz(note)\n    if (id === null || id.startsWith('sec-')) {\n      // Special case sections, only their first couple elements\n      const container = document.createElement(\"div\");\n      if (note.children && note.children.length &gt; 2) {\n        container.appendChild(note.children[0].cloneNode(true));\n        for (let i = 1; i &lt; note.children.length; i++) {\n          const child = note.children[i];\n          if (child.tagName === \"P\" && child.innerText === \"\") {\n            continue;\n          } else {\n            container.appendChild(child.cloneNode(true));\n            break;\n          }\n        }\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(container);\n        }\n        return container.innerHTML\n      } else {\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(note);\n        }\n        return note.innerHTML;\n      }\n    } else {\n      // Remove any anchor links if they are present\n      const anchorLink = note.querySelector('a.anchorjs-link');\n      if (anchorLink) {\n        anchorLink.remove();\n      }\n      if (window.Quarto?.typesetMath) {\n        window.Quarto.typesetMath(note);\n      }\n      if (note.classList.contains(\"callout\")) {\n        return note.outerHTML;\n      } else {\n        return note.innerHTML;\n      }\n    }\n  }\n  for (var i=0; i&lt;xrefs.length; i++) {\n    const xref = xrefs[i];\n    tippyHover(xref, undefined, function(instance) {\n      instance.disable();\n      let url = xref.getAttribute('href');\n      let hash = undefined; \n      if (url.startsWith('#')) {\n        hash = url;\n      } else {\n        try { hash = new URL(url).hash; } catch {}\n      }\n      if (hash) {\n        const id = hash.replace(/^#\\/?/, \"\");\n        const note = window.document.getElementById(id);\n        if (note !== null) {\n          try {\n            const html = processXRef(id, note.cloneNode(true));\n            instance.setContent(html);\n          } finally {\n            instance.enable();\n            instance.show();\n          }\n        } else {\n          // See if we can fetch this\n          fetch(url.split('#')[0])\n          .then(res =&gt; res.text())\n          .then(html =&gt; {\n            const parser = new DOMParser();\n            const htmlDoc = parser.parseFromString(html, \"text/html\");\n            const note = htmlDoc.getElementById(id);\n            if (note !== null) {\n              const html = processXRef(id, note);\n              instance.setContent(html);\n            } \n          }).finally(() =&gt; {\n            instance.enable();\n            instance.show();\n          });\n        }\n      } else {\n        // See if we can fetch a full url (with no hash to target)\n        // This is a special case and we should probably do some content thinning / targeting\n        fetch(url)\n        .then(res =&gt; res.text())\n        .then(html =&gt; {\n          const parser = new DOMParser();\n          const htmlDoc = parser.parseFromString(html, \"text/html\");\n          const note = htmlDoc.querySelector('main.content');\n          if (note !== null) {\n            // This should only happen for chapter cross references\n            // (since there is no id in the URL)\n            // remove the first header\n            if (note.children.length &gt; 0 && note.children[0].tagName === \"HEADER\") {\n              note.children[0].remove();\n            }\n            const html = processXRef(null, note);\n            instance.setContent(html);\n          } \n        }).finally(() =&gt; {\n          instance.enable();\n          instance.show();\n        });\n      }\n    }, function(instance) {\n    });\n  }\n      let selectedAnnoteEl;\n      const selectorForAnnotation = ( cell, annotation) =&gt; {\n        let cellAttr = 'data-code-cell=\"' + cell + '\"';\n        let lineAttr = 'data-code-annotation=\"' +  annotation + '\"';\n        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';\n        return selector;\n      }\n      const selectCodeLines = (annoteEl) =&gt; {\n        const doc = window.document;\n        const targetCell = annoteEl.getAttribute(\"data-target-cell\");\n        const targetAnnotation = annoteEl.getAttribute(\"data-target-annotation\");\n        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));\n        const lines = annoteSpan.getAttribute(\"data-code-lines\").split(\",\");\n        const lineIds = lines.map((line) =&gt; {\n          return targetCell + \"-\" + line;\n        })\n        let top = null;\n        let height = null;\n        let parent = null;\n        if (lineIds.length &gt; 0) {\n            //compute the position of the single el (top and bottom and make a div)\n            const el = window.document.getElementById(lineIds[0]);\n            top = el.offsetTop;\n            height = el.offsetHeight;\n            parent = el.parentElement.parentElement;\n          if (lineIds.length &gt; 1) {\n            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);\n            const bottom = lastEl.offsetTop + lastEl.offsetHeight;\n            height = bottom - top;\n          }\n          if (top !== null && height !== null && parent !== null) {\n            // cook up a div (if necessary) and position it \n            let div = window.document.getElementById(\"code-annotation-line-highlight\");\n            if (div === null) {\n              div = window.document.createElement(\"div\");\n              div.setAttribute(\"id\", \"code-annotation-line-highlight\");\n              div.style.position = 'absolute';\n              parent.appendChild(div);\n            }\n            div.style.top = top - 2 + \"px\";\n            div.style.height = height + 4 + \"px\";\n            div.style.left = 0;\n            let gutterDiv = window.document.getElementById(\"code-annotation-line-highlight-gutter\");\n            if (gutterDiv === null) {\n              gutterDiv = window.document.createElement(\"div\");\n              gutterDiv.setAttribute(\"id\", \"code-annotation-line-highlight-gutter\");\n              gutterDiv.style.position = 'absolute';\n              const codeCell = window.document.getElementById(targetCell);\n              const gutter = codeCell.querySelector('.code-annotation-gutter');\n              gutter.appendChild(gutterDiv);\n            }\n            gutterDiv.style.top = top - 2 + \"px\";\n            gutterDiv.style.height = height + 4 + \"px\";\n          }\n          selectedAnnoteEl = annoteEl;\n        }\n      };\n      const unselectCodeLines = () =&gt; {\n        const elementsIds = [\"code-annotation-line-highlight\", \"code-annotation-line-highlight-gutter\"];\n        elementsIds.forEach((elId) =&gt; {\n          const div = window.document.getElementById(elId);\n          if (div) {\n            div.remove();\n          }\n        });\n        selectedAnnoteEl = undefined;\n      };\n        // Handle positioning of the toggle\n    window.addEventListener(\n      \"resize\",\n      throttle(() =&gt; {\n        elRect = undefined;\n        if (selectedAnnoteEl) {\n          selectCodeLines(selectedAnnoteEl);\n        }\n      }, 10)\n    );\n    function throttle(fn, ms) {\n    let throttle = false;\n    let timer;\n      return (...args) =&gt; {\n        if(!throttle) { // first call gets through\n            fn.apply(this, args);\n            throttle = true;\n        } else { // all the others get throttled\n            if(timer) clearTimeout(timer); // cancel #2\n            timer = setTimeout(() =&gt; {\n              fn.apply(this, args);\n              timer = throttle = false;\n            }, ms);\n        }\n      };\n    }\n      // Attach click handler to the DT\n      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');\n      for (const annoteDlNode of annoteDls) {\n        annoteDlNode.addEventListener('click', (event) =&gt; {\n          const clickedEl = event.target;\n          if (clickedEl !== selectedAnnoteEl) {\n            unselectCodeLines();\n            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');\n            if (activeEl) {\n              activeEl.classList.remove('code-annotation-active');\n            }\n            selectCodeLines(clickedEl);\n            clickedEl.classList.add('code-annotation-active');\n          } else {\n            // Unselect the line\n            unselectCodeLines();\n            clickedEl.classList.remove('code-annotation-active');\n          }\n        });\n      }\n  const findCites = (el) =&gt; {\n    const parentEl = el.parentElement;\n    if (parentEl) {\n      const cites = parentEl.dataset.cites;\n      if (cites) {\n        return {\n          el,\n          cites: cites.split(' ')\n        };\n      } else {\n        return findCites(el.parentElement)\n      }\n    } else {\n      return undefined;\n    }\n  };\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i&lt;bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const citeInfo = findCites(ref);\n    if (citeInfo) {\n      tippyHover(citeInfo.el, function() {\n        var popup = window.document.createElement('div');\n        citeInfo.cites.forEach(function(cite) {\n          var citeDiv = window.document.createElement('div');\n          citeDiv.classList.add('hanging-indent');\n          citeDiv.classList.add('csl-entry');\n          var biblioDiv = window.document.getElementById('ref-' + cite);\n          if (biblioDiv) {\n            citeDiv.innerHTML = biblioDiv.innerHTML;\n          }\n          popup.appendChild(citeDiv);\n        });\n        return popup.innerHTML;\n      });\n    }\n  }\n});\n&lt;/script&gt;\n&lt;/div&gt; &lt;!-- /content --&gt;\n&lt;script type=\"text/javascript\" src=\"/_resources/js/scripts.js\"&gt;&lt;/script&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;"
  },
  {
    "objectID": "posts/2021/2021-05-03-move_to_hugo/index.html",
    "href": "posts/2021/2021-05-03-move_to_hugo/index.html",
    "title": "A Switch to Hugo",
    "section": "",
    "text": "I don’t know why this took so long but I finally switched this blog from Jekyll to Hugo. Not that there’s anything wrong with Jekyll but I’ve been experimenting with Hugo a lot over the last year and I feel more comfortable with it. This is built on the clarity theme, a beautiful theme for blogging."
  },
  {
    "objectID": "posts/2019/2019-12-14-cas_from_pdf/index.html",
    "href": "posts/2019/2019-12-14-cas_from_pdf/index.html",
    "title": "CAS from pdf",
    "section": "",
    "text": "It’s relatively easy to extract CAS numbers from a PDF. I’ve used this to scrape chemical catalogs, subsequently using the CAS numbers to look up additional information through PubChem. CAS numbers are easier to scrape than most other chemical information, such as name, formula or catalog number, as they follow a specific format.\nIt can be accomplished using a couple of lines of code in R (or collapsed into a single line if you prefer). The code below returns all CAS numbers from a file, f.\n\npdf_to_cas &lt;- function(f) {\n  txt &lt;- pdftools::pdf_text(f)\n  cas_numbers &lt;- trimws(unlist(stringr::str_extract_all(txt, '[0-9]+[\\u2011|-][0-9]{2}[\\u2011|-][0-9](?![0-9])')))\n  return(cas_numbers)\n}\n\nThe regular expression [0-9]+[\\u2011|-][0-9]{2}[\\u2011|-][0-9](?![0-9]) can be broken down as follows:\n\n\n\n\n\n\n\n[0-9]+\none or more digits\n\n\n[\\u2011|-]\na dash or an unbreaking hyphen\n\n\n[0-9]{2}-\nexactly two digits\n\n\n[\\u2011|-]\na dash or an unbreaking hyphen\n\n\n[0-9](?![0-9])\na single digit followed by anything other than a digit using a negative lookahead"
  },
  {
    "objectID": "posts/2019/2019-10-16-towards_lab_iot_02/index.html",
    "href": "posts/2019/2019-10-16-towards_lab_iot_02/index.html",
    "title": "Towards Lab IoT Part Two",
    "section": "",
    "text": "In order to test communication we’ll set up two clients, each representing an instrument, along with a server which acts as the MQTT broker, database and visualization. The three machines are all running ubuntu under VirtualBox.\nIn this case client1 sends measurement1 data which resets to a random value between 20 and 50 when it receives a signal from trigger. client2 sends measurement2 data which resets to 20 when it receives a signal from trigger. The controller monitors measurement1 and signals the trigger when measurement1 is above 50. The controller also updates influxDB with data from measurement1 and measurement2. client1 and client2 represent the two clients, running instruments and the server is controller. Codes for each are below.\n\n\ncontroller (virtual machine 1 - ip address = 10.0.2.15)\n## controller\n## \n## this is the controller code that runs in the background\n## it subscribes to measurement1 and when that value\n## reaches the threshold of 50 it publishes a trigger\n## event that client 1 and client 2 both respond to\n##\n## It also doubles up as the subscriber for the influxDB\n## database which is code that can be run in a separate\n## thread or program\n## \n## publish: trigger1\n## subscribe: measurement1\n## response: if measurement1 &gt; 50 then publish trigger \n \nimport paho.mqtt.client as mqtt\nfrom influxdb import InfluxDBClient\nimport datetime\nimport logging\nimport socket\nimport time\n \nMQTT_BROKER = '10.0.2.15'\nHOSTNAME = socket.gethostname()\nIPADDR = socket.gethostbyname(HOSTNAME)\nINSTRUMENT_ID = 'controller'\nINFLUX_CLIENT = '10.0.2.15'\nINFLUX_DATABASE = 'lab1'\n \n# influxDB\ninflux_client = InfluxDBClient(INFLUX_CLIENT, database = INFLUX_DATABASE)\n \n## define logging file\nFORMAT = '%(asctime)-15s %(clientip)s %(instrumentid)-10s %(message)s'\nlogging.basicConfig(filename = '/home/harvey/controller.log', format = FORMAT, datefmt = '%m/%d/%Y %I:%M:%S %p', level = logging.DEBUG)\nd = {'clientip': IPADDR, 'instrumentid': INSTRUMENT_ID}\n \n# Define the callback to handle CONNACK from the broker, if the connection created normal, the value of rc is 0\ndef on_connect(client, userdata, flags, rc):\n    logging.info(\"Connection returned with result code:\" + str(rc), extra = d)\n \n# Define the callback to hande publish from broker\ndef on_message(client, userdata, msg):\n    # log the response\n    logging.info(\"Received message, topic:\" + msg.topic + \"  payload:\" + str(msg.payload), extra = d)\n    \n    # push to influxDB\n    current_time = datetime.datetime.utcnow().isoformat()\n    topic = msg.topic.split('/')\n    measurement_type = topic[2]\n    json_body = [\n        {\n            \"measurement\": measurement_type,\n            \"tags\": {},\n            \"time\": current_time,\n            \"fields\": {\n                \"value\": int(msg.payload)\n            }\n        }\n    ]\n    influx_client.write_points(json_body)\n \n    # fire the trigger if measurement1 &gt; 50\n    if (msg.topic == 'sensor/expt1/measurement1'):\n        if (int(msg.payload) &gt; 50):\n            client.publish(\"sensor/trigger/client1\", payload = str(msg.payload))\n \n# Callback handles disconnection, log the rc value\ndef on_disconnect(client, userdata, rc):\n    logging.info(\"Disconnection returned with result code:\" + str(rc), extra = d)\n \ndef main():\n \n    # Create an instance of `Client`\n    client = mqtt.Client()\n    client.on_connect = on_connect\n    client.on_disconnect= on_disconnect\n    client.on_message = on_message\n \n    # Connect to broker\n    client.connect(MQTT_BROKER, 1883, 60)\n \n    # Subscribe to all topics and start the loop\n    client.subscribe(\"sensor/+/+\", 0)\n    client.loop_forever()\n \nif __name__ == '__main__':\n    logging.info('Starting Broadcast from ' + INSTRUMENT_ID, extra = d)\n    main()\n\n\nclient1 (virtual machine 2 - ip address = 10.0.2.4)\n## client 1 communications\n## \n## this is an MQTT client code that runs in the background\n## of client 1\n## publish: measurement1\n## subscribe: trigger1\n## response: if trigger1 then reset measurement1 to a \n## random value between 20 and 50\n \nimport paho.mqtt.client as mqtt\nimport logging\nimport socket\nimport random\nimport time\n \nMQTT_BROKER = '10.0.2.15'\nHOSTNAME = socket.gethostname()\nIPADDR = socket.gethostbyname(HOSTNAME)\nINSTRUMENT_ID = 'machine 1'\n \n## define logging file\nFORMAT = '%(asctime)-15s %(clientip)s %(instrumentid)-10s %(message)s'\nlogging.basicConfig(filename = '/home/harvey/client1.log', format = FORMAT, datefmt = '%m/%d/%Y %I:%M:%S %p', level = logging.DEBUG)\nd = {'clientip': IPADDR, 'instrumentid': INSTRUMENT_ID}\n \n# Define the callback to handle CONNACK from the broker, if the connection created normal, the value of rc is 0\ndef on_connect(client, userdata, flags, rc):\n    logging.info(\"Connection returned with result code:\" + str(rc), extra = d)\n \n# Define the callback to hande publish from broker\ndef on_message(client, userdata, msg):\n    global measurement\n    logging.info(\"Received message, topic:\" + msg.topic + \"  payload:\" + str(msg.payload), extra = d)\n    if (msg.topic == 'sensor/trigger/client1'):\n        measurement = random.randrange(20, 50)\n        logging.info(\"Trigger 1: measurement reset to \" + str(measurement), extra = d)\n \n# Callback handles disconnection, log the rc value\ndef on_disconnect(client, userdata, rc):\n    logging.info(\"Disconnection returned with result code:\" + str(rc), extra = d)\n \ndef main():\n \n    # Create an instance of `Client`\n    client = mqtt.Client()\n    client.on_connect = on_connect\n    client.on_disconnect= on_disconnect\n    client.on_message = on_message\n \n    # Connect to broker\n    client.connect(MQTT_BROKER, 1883, 60)\n \n    # initial value of measurement\n    global measurement\n    measurement = 0\n \n    ## start MQTT client loop\n    client.loop_start()\n \n    # Subscribe to a topic\n    client.subscribe(\"sensor/trigger/client1\", 0)\n \n    ## continuously update measurement value every second\n    ## simulates instrument operation\n    while True:\n        client.publish(\"sensor/expt1/measurement1\", payload = measurement)\n        time.sleep(1)\n        measurement += 1\n \n    # Disconnection\n    time.sleep(1) # wait till all messages are processed\n    client.loop_stop()\n    client.disconnect()\n \nif __name__ == '__main__':\n    logging.info('Starting Broadcast from ' + INSTRUMENT_ID, extra = d)\n    main()\n\n\nclient2 (virtual machine 3 - ip address = 10.0.2.5)\n## client 2 communications\n## \n## this is an MQTT client code that runs in the background\n## of client 2\n## publish: measurement2\n## subscribe: trigger1\n## response: if trigger1 then reset measurement2 to 20 \n \nimport paho.mqtt.client as mqtt\nimport logging\nimport socket\nimport time\n \nMQTT_BROKER = '10.0.2.15'\nHOSTNAME = socket.gethostname()\nIPADDR = socket.gethostbyname(HOSTNAME)\nINSTRUMENT_ID = 'machine 2'\n \n## define logging file\nFORMAT = '%(asctime)-15s %(clientip)s %(instrumentid)-10s %(message)s'\nlogging.basicConfig(filename = '/home/harvey/client2.log', format = FORMAT, datefmt = '%m/%d/%Y %I:%M:%S %p', level = logging.DEBUG)\nd = {'clientip': IPADDR, 'instrumentid': INSTRUMENT_ID}\n \n# Define the callback to handle CONNACK from the broker, if the connection created normal, the value of rc is 0\ndef on_connect(client, userdata, flags, rc):\n    logging.info(\"Connection returned with result code:\" + str(rc), extra = d)\n \n# Define the callback to hande publish from broker\ndef on_message(client, userdata, msg):\n    global measurement\n    logging.info(\"Received message, topic:\" + msg.topic + \"  payload:\" + str(msg.payload), extra = d)\n    if (msg.topic == 'sensor/trigger/client1'):\n        measurement = 20\n        logging.info(\"Trigger 1: measurement reset to \" + str(measurement), extra = d)\n \n# Callback handles disconnection, log the rc value\ndef on_disconnect(client, userdata, rc):\n    logging.info(\"Disconnection returned with result code:\" + str(rc), extra = d)\n \ndef main():\n \n    # Create an instance of `Client`\n    client = mqtt.Client()\n    client.on_connect = on_connect\n    client.on_disconnect= on_disconnect\n    client.on_message = on_message\n \n    # Connect to broker\n    client.connect(MQTT_BROKER, 1883, 60)\n \n    ## start MQTT client loop\n    client.loop_start()\n \n    # Subscribe to a topic\n    client.subscribe(\"sensor/trigger/client1\", 0)\n \n    # initial value of measurement\n    global measurement\n    measurement = 0\n \n    ## continuously update measurement value every second\n    ## simulates instrument operation\n    while True:\n        client.publish(\"sensor/expt1/measurement2\", payload = measurement)\n        time.sleep(1)\n        measurement += 1\n \n    # Disconnection\n    time.sleep(1) # wait till all messages are processed\n    client.loop_stop()\n    client.disconnect()\n \nif __name__ == '__main__':\n    logging.info('Starting Broadcast from ' + INSTRUMENT_ID, extra = d)\n    main()\n\n\nVisualization\nRunning all three codes leads to continuous output which updates every second. measurement1 and measurement2 are stored in the InfluxDB under database lab1 which can be visualized using grafana (default = localhost, port 3000).\nmeasurement1 and measurement2 increment every second. When measurement1 reaches 50 it resets itself to a random value between 20 and 50 and resets measurement2 to 20."
  },
  {
    "objectID": "posts/2019/2019-08-26-extract_pdf/index.html",
    "href": "posts/2019/2019-08-26-extract_pdf/index.html",
    "title": "Extracting data from LCMS PDF",
    "section": "",
    "text": "Here’s an example of using R to extract tabular content and metadata from a series of pdf files and push the data into a single table. The concept is fairly straightforward - read in PDF and convert to text, parse each line and use regular expressions to extract pertinent information.\nThree types of data are returned:\n\npeak data. Peak number, retention time, type, width, area and name. In fact all columns will be extracted from the table along with the column identifiers and units.\nmetadata. In this case injection date, data file name and sample name are pulled from the pdfs.\nfile data. The pdf file name and page containing the peak table.\n\nThe pdftools library is used to read in the PDF files.\n\nUnwanted or Missing spaces\nSo why use column identifiers from the table header instead of just splitting table columns using a delimeter such as a tab? Unfortunately tabular information is lost when the pdf is imported and any tabs are converted into spaces. A space character column delimeter could be used if all columns are populated and the sample names did not contain spaces. For these tables, however, the Type column is not always populated and the Name column can contain spaces. Therefore there is no way to be sure that we are accurately identifying the end of one column and beginning of another using delimeters.\nAn additional issue arises because when the pdf is imported some unexpected formatting issues can arise, particularly with respect to unwanted or missing spaces. To account for this when parsing the table we can nudge forward or back to identify spaces between values. This can be seen in the alignment of line 3 of the table below (pdf vs parsed text).\n\n\n\nPDF Version\n\n\n\n\n\nParsed Version\n\n\n\n\nCode\n\n## table_extract\n## extract table contents along with headers\n## this allows sample names to be retrieved too\n## uses heading underline separators to determine column widths\n\nlibrary(pdftools)\nlibrary(stringr)\nlibrary(dplyr)\n\nfolder &lt;- 'test_01'\n\n## identify files\nf_names &lt;- list.files(path = folder, pattern = '.pdf', full.names = TRUE)\n\n## loop over all files\nl.df &lt;- lapply(f_names, function(f) {\n  \n  txt &lt;- pdf_text(f)\n  \n  ## split text at carriage return\n  txt1 &lt;- strsplit(txt, '\\r\\n')\n  \n  ## loop over lines and retrieve table contents\n  l &lt;- list()\n  l_all &lt;- list()\n  read_table &lt;- FALSE\n  for (i in 1:length(txt1)) { # loop through pages\n    for (j in 1:length(txt1[[i]])) { # loop through lines\n      line &lt;- txt1[[i]][j]\n      \n      if (str_detect(line, 'Totals :')) { # end of record\n        read_table &lt;- FALSE\n        df.data &lt;- as.data.frame(do.call(rbind, l_data), stringsAsFactors = FALSE)\n        df.data$date &lt;- l[['date']]\n        df.data$data_file &lt;- l[['data_file']]\n        df.data$sample_name &lt;- l[['sample_name']]\n        df.data$pdf_file &lt;- basename(f)\n        df.data$page &lt;- i\n        l[['data']] &lt;- df.data\n        l_all[[length(l_all) + 1]] &lt;- l\n        l &lt;- list()  ## reset list\n      } else if  (str_detect(line, 'Injection Date')) { # found inj date\n        inj_date &lt;- as.POSIXct(str_extract(line, '\\\\d+/\\\\d+/\\\\d+ \\\\d+:\\\\d+:\\\\d+ [A|P]M'), format = '%m/%d/%Y %I:%M:%S %p')\n        l$date &lt;- inj_date\n        l_data &lt;- list()\n      } else if (str_detect(line, 'Peak RetTime')) { # found table\n        table_headers &lt;- line   ## save table headers for later use\n        read_table &lt;- TRUE\n      } else if (str_detect(line, 'Data File')) {\n        l[['data_file']] &lt;- basename(txt1[[2]][1])\n      } else if (str_detect(line, 'Sample Name:')) {\n        l[['sample_name']] &lt;- str_replace(line, 'Sample Name: ', '')\n      }\n      \n      if (read_table) {\n        \n        if (str_detect(line, '\\\\[min\\\\]')) { # found second header line\n          table_headers_2 &lt;- line   ## save table headers for later use\n        }\n        \n        if (!str_detect(line, '\\\\[min\\\\]') & !str_detect(line, 'Peak RetTime')) {\n          if (str_detect(line, '--|--')) { ## found separator line\n            locate_separators &lt;- str_locate_all(line, '\\\\|')\n            locate_separators &lt;- c(1, locate_separators[[1]][,1], nchar(line))\n            txt_headings &lt;- sapply(seq_along(locate_separators[-1]), function(x) {\n              trimws(substring(table_headers, locate_separators[x], locate_separators[x+1]))\n            })\n            \n            txt_headings_2 &lt;- sapply(seq_along(locate_separators[-1]), function(x) {\n              trimws(substring(table_headers_2, locate_separators[x], locate_separators[x+1]))\n            })\n            \n            txt_headings &lt;- sapply(seq_along(txt_headings), function(x) {\n              if (nchar(txt_headings_2[x]) &gt; 0) {\n                sprintf('%s (%s)', txt_headings[x], txt_headings_2[x])\n              } else {\n                txt_headings[x]\n              }\n            })\n            \n          } else {  ## found data\n            \n            ## add a space to the end of the line\n            ## necessary for identifying end-of-data points\n            line &lt;- paste0(line, ' ')\n            \n            data &lt;- sapply(seq_along(locate_separators[-1]), function(x) {\n              \n              ## sometimes text pull needs to start a few characters back\n              ## (due to import conversion of tabs to spaces)\n              start_pos &lt;- locate_separators[x]\n              end_pos &lt;- locate_separators[x+1]\n              \n              if (substring(line, start_pos, start_pos) != ' ') {\n                found_space &lt;- FALSE\n                while (!found_space & start_pos &gt; 2) {\n                  start_pos &lt;- start_pos - 1\n                  if (substring(line, start_pos, start_pos) == ' ') found_space &lt;- TRUE\n                }\n              }\n              \n              if (substring(line, end_pos, end_pos) != ' ') {\n                found_space &lt;- FALSE\n                while (!found_space & end_pos &gt; 2) {\n                  end_pos &lt;- end_pos - 1\n                  if (substring(line, end_pos, end_pos) == ' ') found_space &lt;- TRUE\n                }\n              }\n              \n              trimws(substring(line, start_pos, end_pos))\n            })\n            l_data[[length(l_data) + 1]] &lt;- setNames(data, txt_headings)\n          }\n        }\n      }\n    }\n  }\n  \n  ## join tables\n  df &lt;- do.call(rbind, lapply(l_all, function(x) x$data))\n  \n  ## convert table columns to numeric\n  for (n in names(df)) {\n    if (all(grepl(\"^(-|\\\\+)?((\\\\.?\\\\d+)|(\\\\d+\\\\.\\\\d+)|(\\\\d+\\\\.?)|(\\\\d*\\\\.*\\\\d+[E|e](-|\\\\+)\\\\d+))$\", df[[n]]))) {\n      df[[n]] &lt;- as.numeric(df[[n]])\n    }\n  }\n  df\n})\n\ndf_all &lt;- do.call(rbind, l.df)\n\nwrite.csv(df_all, 'table_out.csv', row.names = FALSE)\n\n\n\nInput File Example"
  },
  {
    "objectID": "posts/2019/2019-03-15-visnetwork_continuous/index.html",
    "href": "posts/2019/2019-03-15-visnetwork_continuous/index.html",
    "title": "visNetwork Continuous Colors",
    "section": "",
    "text": "visNetwork is a fantastic library used to make interactive network graphs in R. It has many features to style nodes and edges but lacks a way to fill nodes using a continuous variable. ThIs can readily be achieved by using findInterval to map a continuous variable to the closest color on a color scale. In the example below a random data set is generated with a probability between zero a one attached to each node. Color is then assigned from a palette of 101 shades of blue. The resultant graph illustrates the effect of coloring using a continuous variable - higher probabilities are darker (label = node number and probability).\n\n## visNetwork continuous color\n\nlibrary(visNetwork)\nlibrary(igraph)\nlibrary(dplyr)\nlibrary(RColorBrewer)\n\n## define number of nodes, edges and colors\n\nn_nodes &lt;- 100\nn_edges &lt;- 200\nn_cols &lt;- 101\npal &lt;- colorRampPalette(brewer.pal(9, 'Blues'))(n_cols)\n\n## create graph from random edges\n## p is a variable for color coding from 0 to 1\n\ndf.nodes &lt;- data.frame(id = seq(n_nodes), p = runif(seq(n_nodes))) %&gt;%\n  mutate(label = sprintf('n %i (%0.2f)', id, p)) %&gt;%\n  mutate(c_ref = findInterval(p, seq(from = 0, to = 1, length.out = n_cols))) %&gt;%\n  mutate(color = pal[c_ref])\n  \ndf.edges &lt;- data.frame(from = sample(seq(n_nodes), n_edges, replace = TRUE), to = sample(seq(n_nodes), n_edges, replace = TRUE))\n\nvisNetwork(nodes = df.nodes ,edges = df.edges) %&gt;%\n  visIgraphLayout()"
  },
  {
    "objectID": "posts/2019/2019-01-31-formattable/index.html",
    "href": "posts/2019/2019-01-31-formattable/index.html",
    "title": "Formattable - color data according to RSD",
    "section": "",
    "text": "Formattable is a powerful R library used to format tables. There are many built-in functions which allow a user to style tables using color, bars ad icons. In addition you can create your own custom formatters. Below is an example of how to color a data frame using information from a second data frame. Average values are colored red if the RSD is greater than 0.15 and green if it is below.\nThis was developed in order to represent a large table of data color-coded accordng to RSD so that the analyst could quickly identify potential sources of systematic error.\n\n\n\ntable of data\n\n\n\n\n\ntable of RSDs\n\n\n\n\n\ntable of data color-coded according to RSDs\n\n\n\nCode\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(formattable)\n\n## generate some dummy data\n\ndf_dummy &lt;- data.frame(sample = rep(sprintf('sample_%02i', 1:10), 4),\n                       value_A = rnorm(40, 100, 5),\n                       value_B = rnorm(40, 100, 15),\n                       value_C = rnorm(40, 100, 25),\n                       stringsAsFactors = FALSE)\n\n## calculate stats\n\ndf_stats &lt;- df_dummy %&gt;%\n  gather(ref, value, -sample) %&gt;%\n  group_by(sample, ref) %&gt;%\n  summarise(avg = mean(value), \n            stdev = sd(value)) %&gt;%\n  mutate(rsd = stdev / avg)\n\n## pull out a table of average results\n\ndf_avg &lt;- df_stats %&gt;%\n  select(sample, ref, avg) %&gt;%\n  spread(ref, avg)\n\n## pull out a table of RSDs\n\ndf_rsd &lt;- df_stats %&gt;%\n  select(sample, ref, rsd) %&gt;%\n  spread(ref, rsd)\n\n## create a series of formatters, one for each data column\n\nfmt &lt;- lapply(1:(ncol(df_rsd)-1), function(y) {\n  d &lt;- df_rsd[[y + 1]]\n  colors &lt;- sapply(d, function(x) ifelse(x &lt;= 0.15, '#81C784', '#e57373'))\n  \n  formatter(\"span\", \n            style = style(display = 'block',\n                          padding = '0 4px',\n                          `border-radius` = '4px',\n                          `background-color` = colors))\n})\n\n## name list items \n\nl.fmt &lt;- setNames(lapply(1:(ncol(df_avg)-1), function(x) fmt[[x]]), names(df_avg)[2:ncol(df_avg)])\n\n## create table\n\nformattable(df_avg, l.fmt)"
  },
  {
    "objectID": "posts/2019/2019-01-03-startup_options/index.html",
    "href": "posts/2019/2019-01-03-startup_options/index.html",
    "title": "Shiny app startup options",
    "section": "",
    "text": "Using parseQueryString in conjunction with session$clientData$url_search can be used to pass variables to a shiny app from the url address. It can also be used with Sys.getenv('SHINY_PORT') to follow programming paths based on variable values and execution environment. In the example below, the code points to different instances of a database, depending on user-specification and execution environment. Running locally or on the server points to different default databases and includes the ability to override. This code is useful when placed at the top of an app during development.\n\nlibrary(shiny)\n\n## allowed_databases stores the names of the allowable databases\nallowed_databases &lt;- c('test', 'production', 'uploadtest')\n\n## default database names for interactive and server modes\ndafault_interactive &lt;- 'test'\ndafault_server &lt;- 'production'\n\n## override database defaults for interactive mode\n## to override the default database set override_default_database to TRUE and \n## override_use_database to the database name\noverride_default_database &lt;- FALSE\noverride_use_database &lt;- 'production'\n\nserver &lt;- function(input, output, session) {\n  \n  val &lt;- reactiveValues(db = NULL)\n  \n  db_set_database &lt;- function(name) {\n    val$db &lt;- name\n  }\n  \n  ## set database\n  observe({\n    if(Sys.getenv('SHINY_PORT') == \"\") {\n      ## if running locally then use test database unless override set\n      if (override_default_database) {\n        ## run against specified instance\n        if (!override_use_database %in% allowed_databases) override_use_database &lt;- dafault_interactive\n        db_set_database(override_use_database)\n      } else {\n        ## run against default interactive instance\n        db_set_database(dafault_interactive)\n      }\n    } else {\n      ## if running on server then look for database in url\n      query &lt;- parseQueryString(session$clientData$url_search)\n      if (!is.null(query[['database']])) {\n        ## get database name from url and check that it is in the list of allowed database names\n        my_database &lt;- tolower(query[['database']])\n        if (!my_database %in% allowed_databases) my_database &lt;- dafault_server\n        ## run against selected instance\n        db_set_database(my_database)\n      } else {\n        ## default - run against default server instance\n        db_set_database(dafault_server)\n      }\n    }\n  })\n  \n  output$txt1 &lt;- renderPrint(paste0('Using database ', val$db))\n  \n}\n\nui &lt;- fluidPage(\n  verbatimTextOutput('txt1')\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2018/2018-11-07-shiny_restart_txt/index.html",
    "href": "posts/2018/2018-11-07-shiny_restart_txt/index.html",
    "title": "Restarting a Shiny App",
    "section": "",
    "text": "I have to post this for my own sanity. I tend to create shiny apps in a specific folder and link to them using symbolic links from the ShinyApp folder. This allows multiple versions (prod and dev) and keeps code clean. I don’t know how many times I’ve wrestled with an app pointing to an earlier version when updates have been made and it’s always driven me crazy. I also don’t know how many times I’ve read through the shiny-server documentation but never discovered section 3.1.1 - Restarting an Application. Now I’m happy I’ve discovered touch restart.txt as a way to force an app to restart. All my versioning issues have gone away."
  },
  {
    "objectID": "posts/2018/2018-08-05-cron_python_slack/index.html",
    "href": "posts/2018/2018-08-05-cron_python_slack/index.html",
    "title": "cron, python and slack - a beautiful combination",
    "section": "",
    "text": "This year I’m trying out slack as a platform for out fantasy football league. It provides channels for banter, keeping track of transfers and, with the use of rss feeds, up to date information. In addition I’ve set up a channel dedicated to injuries tied to an incoming webhook. The injury channel works by running a small python code on a server via a weekly cron job. The python code scrapes a site that lists current Premiership injuries and suspensions, reformats the output and then pushes it out to the slack channel. This results in a simple solution that updates a channel weekly.\n# -*- coding: utf-8 -*-\nimport pandas as pd\nfrom bs4 import BeautifulSoup\nimport requests\nimport json\n\nurl = \"https://www.fantasyfootballscout.co.uk/fantasy-football-injuries/\"\nwebhook = ## provided webhook url\n\n\nresponse = requests.get(url)\n\nsoup = BeautifulSoup(response.text, \"html5lib\")\n\ntable = soup.find('table', attrs={'class':'ffs-ib-full-content'})\ntable_body = table.find('tbody')\n\ndata = []\n\nrows = table_body.find_all('tr')\nfor row in rows:\n    cols = row.find_all('td')\n    cols = [ele.text.strip() for ele in cols]\n    data.append([ele for ele in cols if ele]) # Get rid of empty values\n\nstatus = {\"Injured\": \":inj-injured:\", \n          \"Available\": \":inj-available:\",\n          \"Unavailable\": \":inj-unavailable:\",\n          \"Knock\": \":inj-knock:\",\n          \"On Loan\": \":inj-on-loan:\",\n          \"Suspended\": \":inj-disciplinary:\",\n          \"Doubt 25%\": \":inj-doubt-25:\", \n          \"Doubt 50%\": \":inj-doubt-50:\", \n          \"Doubt 75%\": \":inj-doubt-75:\"}\n\np1 = pd.DataFrame(data, columns = ['Name', 'Club', 'Status', 'Return Date', 'Latest News', 'Last Updated'])\np1['status_icon'] = p1['Status'].replace(status)\np1['out'] = p1['status_icon'] + ' ' + p1['Name'] + ' ' + p1['Club']\n\n# build the payload\npayload = {}\npayload['username'] = 'injury-bot'\npayload['channel'] = '#injuries'\n\nattachments = []\nattachments.append({\"fallback\":\"Link to injury website: &lt;https://www.fantasyfootballscout.co.uk/fantasy-football-injuries/|full injury table&gt;\"})\nattachments.append({\"pretext\":\"Link to injury website: &lt;https://www.fantasyfootballscout.co.uk/fantasy-football-injuries/|full injury table&gt;\"})\n\nfield_inj = {}\nfield_inj['title'] = 'Injury Table'\nfield_inj['value'] = '\\n'.join(p1['out'].tolist())\nfield_inj['short'] = False\n\nattachments.append({\"fields\": [field_inj]})\npayload['attachments'] = attachments\n\nrequests.post(webhook, data = json.dumps(payload))"
  },
  {
    "objectID": "posts/2018/2018-06-13-asynchronous/index.html",
    "href": "posts/2018/2018-06-13-asynchronous/index.html",
    "title": "Interrupting a background process: asynchronous shiny",
    "section": "",
    "text": "I had been running a shiny app in which I could halt a long-running process. The process would update the shiny app and constantly looked for an updated shiny variable to inform if a cancel button had been pressed. The code had been adapted from a SO post at https://stackoverflow.com/questions/30587883/is-it-possible-to-stop-executing-of-r-code-inside-shiny-without-stopping-the-sh/34517844#34517844. Unfortunately this utilized the httpuv::service function in a manner for which it was not designed. At some point, when shiny and httpuv were updated, this functionality ceased to work. Thanks to some help from Joe Cheng a similar functionality can be derived using an asynchronous function. A working example is shown below.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  actionButton(\"start_list\", \"Start 'list' iterator\"),\n  actionButton(\"start_list2\", \"Start reactive 'list' iterator\"),\n  actionButton(\"start_while\", \"Start 'while' iterator\"),\n  actionButton(\"cancel\", \"Stop\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  val &lt;- reactiveValues(b = 100)\n  \n  \n  base_task_iterator &lt;- function(should_continue, iter_body) {\n    if (should_continue()) {\n      iter_body()\n      later::later(~base_task_iterator(should_continue, iter_body))\n    }\n    invisible()\n  }\n  \n  while_task_iterator &lt;- function(cancelExpr, whileExpr, func) {\n      cancelFunc &lt;- rlang::as_function(rlang::enquo(cancelExpr))\n      whileFunc &lt;- rlang::as_function(rlang::enquo(whileExpr))\n      \n      origCancelVal &lt;- isolate(try(silent = TRUE, cancelFunc()))\n      cancelled &lt;- function() {\n        !identical(origCancelVal, isolate(try(silent = TRUE, cancelFunc())))\n      }\n      \n        base_task_iterator(\n        function() {\n          !cancelled() && whileFunc()\n        },\n        func\n      )\n  }\n  \n  list_task_iterator &lt;- function(cancelExpr, x, func) {\n      cancelExpr &lt;- rlang::enquo(cancelExpr)\n      \n      origCancelVal &lt;- isolate(try(silent = TRUE, cancelFunc()))\n      pos &lt;- 1\n      \n        while_task_iterator(!!cancelExpr, pos &lt;= length(x), function() {\n        i &lt;- pos\n        pos &lt;&lt;- pos + 1L\n        isolate({\n          func(x[[i]])\n      })\n    })\n  }\n  \n  observeEvent(input$start_list, {\n    list_task_iterator(input$cancel, 1:10, function(x) {\n      message(x)\n      Sys.sleep(1)\n    })\n  })\n  \n  observeEvent(input$start_list2, {\n    list_task_iterator(input$cancel, 1:10, function(x) {\n      val$b &lt;- val$b + 1\n      message(val$b)\n      Sys.sleep(1)\n    })\n  })\n  \n  observeEvent(input$start_while, {\n    # Something's wrong with rlang::as_function, I can't use TRUE, only !FALSE\n    while_task_iterator(input$cancel, !FALSE, function() {\n      message(format(Sys.time()))\n      Sys.sleep(1)\n    })\n  })\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2018/2018-02-21-rstudio_and_redmine/index.html",
    "href": "posts/2018/2018-02-21-rstudio_and_redmine/index.html",
    "title": "Using Redmine with RStudio",
    "section": "",
    "text": "Redmine is a great tool for tracking project progress and bugs. With a little configuration it can integrate git repositories and integrate with R program / package development. The following assumes that Redmine, R and RStudio server are all configured and working.\n\nLinking a repository to Redmine\nWithout changing file permissions, Redmine cannot interact directly with git repositories created in RStudio server. A simple workaround is to clone the repository. In this example we’ll create a clone for a repository under ~/codes/redmine_demo\n# ~/git_redmine_clones is a directory to hold the clones\ncd ~/git_redmine_clones\n\n# clone the repository\ngit clone --mirror ~/codes/redmine_demo\n\n# set folder content permissions\nchmod a+r -R redmine_demo.git\nThis repository can now be added to a Redmine project through Settings-&gt;Repository. The path to the repository needs to be filled out in full.\n\n\nUpdating clone via cron job\nOne caveat to this approach is that as changes are made to the repository they are not reflected in Redmine. This can be overcome by adding a cron job that automatically fetches any new commits and updates the clone. Changes are visible in Redmine when the clone is updated.\n# use nano as the cron editor\nexport EDITOR=nano\n\n# edit crontab file\ncrontab -e\nThe following line should be aded to the crontab file:\n*/5 * * * * cd ~/git_redmine_clones/redmine_demo.git && git fetch -q --all –p\nThis states that the active directory should be changed to ~/git_redmine_clones/redmine_demo.git and then a git fetch command is run. The timing in the crontab file dictates that this will be run every 5 minutes."
  },
  {
    "objectID": "posts/2017/2017-11-28-sortable_tables/index.html",
    "href": "posts/2017/2017-11-28-sortable_tables/index.html",
    "title": "Sortable Tables",
    "section": "",
    "text": "The datatable widget is a powerful table-building tool used to display data in shiny apps. It can use many of the datatable plugins and extensions but a small javascript hack is needed for the rowReorder extension which allows rows to be reordered using drag and drop.\nIn the example below, the rowReorder options are set to selector = ‘tr’ (select by clicking anywhere on a row) and update = FALSE (do not fire an update to rowReorder). The removal of the update is due to the fact that the rows are not reordered properly in a shiny app. We can now use the row-order event which is fired irrespective of the setting of the update option (row-reordered, however, is only fired when update = true). The javascript function called on row-reorder simply grabs the new order of the table rows and exports it to a shiny variable. This can then be used to update the table.\nlibrary(shiny)\nlibrary(DT)\n\n## Sortable table\n\nserver &lt;- function(input, output) {\n  \n  df &lt;- reactiveValues(data = mtcars[c(1:20), c('mpg', 'cyl', 'disp')],\n                       data_reordered = mtcars[c(1:20), c('mpg', 'cyl', 'disp')])\n\n  output$tab1 &lt;- DT::renderDataTable({\n    DT::datatable(df$data, \n                  selection = 'none', \n                  extensions = c('Scroller', 'RowReorder'), \n                  options = list(rowReorder = list(selector = 'tr', update = FALSE), \n                                 columnDefs = list(list(targets = 0, visible = TRUE)),\n                                 deferRender = TRUE,\n                                 scrollY = 400,\n                                 scroller = TRUE,\n                                 dom = 't'),\n                  callback = JS(\"table.on('row-reorder', function(e, diff, edit) { \n                                  var arr = [];\n                                  $(this).parent().find('.dataTable tbody tr').each(function() { arr.push($(this).find('td').eq(0).text()); })\n                                  Shiny.onInputChange('tableReordered', arr);\n                                });\")\n                  )\n  })\n\n  observeEvent(input$tableReordered, {\n    df$data_reordered &lt;- df$data[order(match(row.names(df$data), input$tableReordered)), ]\n    df$order &lt;- input$tableReordered\n  })\n\n  output$df_original &lt;- renderTable(df$data, rownames = TRUE)  \n  output$df_reordered &lt;- renderTable(df$data_reordered, rownames = TRUE) \n}\n\nui &lt;- fluidPage(\n  column(4, \n           h4('Sortable Table'),\n           DT::dataTableOutput('tab1')\n         ),\n  column(4, \n           h4('Original Table'),\n           tableOutput('df_original')\n         ),\n  column(4, \n           h4('Sorted Table'),\n           tableOutput('df_reordered')\n         )\n)\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2017/2017-09-15-fancy_headers_in_automated_reports/index.html",
    "href": "posts/2017/2017-09-15-fancy_headers_in_automated_reports/index.html",
    "title": "Fancy Headers in Automated Reports",
    "section": "",
    "text": "Using RMarkdown with knitr is a great way of automating reports under R and I’ve used this approach extensively in shiny apps. For one particular project we’re storing raw data in a SQL database and processing on the fly under shiny. Results are displayed using heatmaps and graphs. We’re now considering pushing data reports to a filestore that connects to another corporate database via a visualizer. Not wanting to generate extra work, this is a great opportunity to put rmarkdown and knitr to work. I’ve added some code to the upload so that each time data are uploaded to the database some rudimentary calculations are performed and a pdf report is automatically generated. Unlike many of the other reports I’ve put together in the past, this one requires the title to be placed in a header along with a link to the app for further processing.\nAll this can be achieved with a little programming in R and latex as shown below…\n\nHere is a snippet from the app.R code. In this case ASSAY_TITLE refers to the name of the assay. Data have already been processed and are stored in a reactive variable (df.raw), comprising of Sample, Concentration and several columns of processed data.\n\n## Generate reports\nobserveEvent(input$butReport, {\n  req(df.raw())\n  for (sample in unique(df.raw()$Sample)) {  ## Create one report for each sample\n    output_file &lt;- paste(sample, Sys.Date(), 'ASSAY_TITLE', \"FA.pdf\", sep='_')\n    file_with_path &lt;- paste(tempdir(), output_file, sep = '/')\n    rmarkdown::render(input = \"./upload_report.Rmd\",\n            output_format = \"pdf_document\",\n            output_file = output_file,\n            output_dir = tempdir(),\n            params=list(sample=sample,  ## Send parameters to markdown yaml\n                        date=Sys.Date()))\n    df$report[df$report$Sample == sample, 'Uploaded'] &lt;- TRUE\n    ## send report to filestore\n    inq_metadata &lt;- '{\"file_content\": \"Report\", \"description\": \"ASSAY_TITLE Report file\"}'\n    uploadFile(parent_id, file_with_path, metadata = inq_metadata)\n  }\n})\n\nHere’s the entire rmarkdown file. The yaml at the top contains a params line to pass paraneters from the ramarkdown::render command. Two variables are set in yaml - the title and author - these contain data which will be used for two lines in the header. The author is used to store the subtitle data and consists of an r paste0 command concatenating teh sample name and date (passed as variables). A couple of latex packages are included: graphicx to include a graphic and fancyhdr to manage creating a header. The statement that reads \\AtBeginDocument{\\let\\maketitle\\relax} allows us to define the title in yaml but does not automatically print it to the document title page. The latex code defines a header/footer for the plain page style. The footer contains the page number, centered and the header contains the title and author variables, left justified, with the title on top. In addition to the title information in the header, a graphic is included, right justified. The graphic is embedded in an \\href command and links to the app. This allows the user to view the report which contains limited information and click to the app for further detail. Once this is all in place, all that is needed is to issue a \\newpage followed by \\pagestyle{plain} at the start of each page.\n\n---\nparams: \n  sample: \"\"\n  date: \"\"\ntitle: \"FATTY ACID ANALYSIS\"\nauthor: \"`r paste0('Sample: ', params$sample, ' --- Uploaded: ', params$date)`\"\nheader-includes:\n  \\usepackage{graphicx}\n  \\usepackage{fancyhdr}\n  \\AtBeginDocument{\\let\\maketitle\\relax}\noutput: pdf_document\n---\n\n\\makeatletter\n\\fancypagestyle{plain}{\n  \\fancyhf{}\n  \\fancyfoot[C]{\\thepage}\n  \\fancyhead[L]{\\Large \\textbf{\\@title} \\\\ \\large \\@author}\n  \\fancyhead[R]{\\href{http://link_to_shiny_app/}{\\includegraphics{link_button.png}}}\n}\n\n\\pagestyle{plain}\n\\vspace*{1\\baselineskip}\n\n## Raw data - averaged over each concentration\n```{r, results='asis'}\n\ndf.tab1 &lt;- df.raw() %&gt;%\n  filter(Sample == sample) %&gt;%\n  select(-Sample) %&gt;%\n  gather(FA, Value, -Conc) %&gt;%\n  group_by(FA, Conc) %&gt;%\n  summarise(av_Conc = round(mean(Value), 3)) %&gt;%\n  spread(Conc, av_Conc)\nnames(df.tab1)[-1] &lt;- paste(names(df.tab1)[-1], 'µM')\nkable(df.tab1)\n\n```\n\\newpage\n\\pagestyle{plain}\n\n## Normalized data - averaged over each concentration\n```{r results='asis'}\n\nfeatures &lt;- names(df.raw())[-c(1:2)]\ndf.tab2 &lt;- df.raw() %&gt;%\n  filter(Sample == sample) %&gt;%\n  select(-Sample) %&gt;%\n  mutate(total = rowSums(.[-1], na.rm = TRUE)) %&gt;%\n  mutate_at(features, funs(100*./total)) %&gt;%\n  select(-total) %&gt;%\n  gather(FA, Value, -Conc) %&gt;%\n  group_by(FA, Conc) %&gt;%\n  summarise(av_Conc = round(mean(Value), 3)) %&gt;%\n  spread(Conc, av_Conc)\nnames(df.tab2)[-1] &lt;- paste(names(df.tab2)[-1], 'µM')\nkable(df.tab2)\n\n```"
  },
  {
    "objectID": "posts/2017/2017-08-10-SQL_server/index.html",
    "href": "posts/2017/2017-08-10-SQL_server/index.html",
    "title": "SQL Server",
    "section": "",
    "text": "Connecting R to a SQL Server can be achieved using the RODBC or RJDBC libraries. Under CentOS this is a little more challenging than Windows and is generally achieved by installing the freeTDS ODBC driver and using the RODBC library. I found compilation a little difficult under CentOS 5.7 and so I moved on to JDBC instead.\nAfter installing the JDBC from https://www.microsoft.com/en-us/download/details.aspx?id=21599 and unpacking to /etc, it was simple to connect to a database as follows:\ndrv &lt;- JDBC(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\", \"/etc/sqljdbc_3.0/enu/sqljdbc4.jar\")\nconn &lt;- dbConnect(drv, 'jdbc:sqlserver://server_address', 'user', 'password')\ndbListTables(conn)"
  },
  {
    "objectID": "posts/2017/2017-04-08-shiny_background_process/index.html",
    "href": "posts/2017/2017-04-08-shiny_background_process/index.html",
    "title": "Shiny Background Process",
    "section": "",
    "text": "R is a very powerful language but was designed to run single-threaded. There are libraries that will run parallel code but there is no inherent support to run a background process and monitor for completion in the same way that you can in, for example, C++.\nOne way to overcome this is to launch a second instance of R and run the process in the background. If the background process generates a log file it can be monitored within Shiny using the reactivePoll or reactiveFileInput functions. Once completed subsequent action can be taken. The advantage of this method is that the second process is run under a second instance of R and does not interfere with the user interface of the Shiny app.\nBy way of example, there are two apps below. The first attempts to run the process within an observer which ties up the UI – the UI will only respond to changes once the calculation is completed. The second launches a second instance and the UI is not affected – the UI is fully responsive during the calculation."
  },
  {
    "objectID": "posts/2017/2017-04-08-shiny_background_process/index.html#running-as-a-single-process",
    "href": "posts/2017/2017-04-08-shiny_background_process/index.html#running-as-a-single-process",
    "title": "Shiny Background Process",
    "section": "Running as a Single Process",
    "text": "Running as a Single Process\nThe gist for the code can be found at https://gist.github.com/harveyl888/fa6ff9823b9c5a5fff11c946d8e7c9f5\n\n## Data creation\n## \n## Create a large Excel spreadsheet within a Shiny app\n##\n\nlibrary(shiny)\nlibrary(openxlsx)\n\n## Create a dummy matrix\n\nserver &lt;- function(input, output, session) {\n  \n  mydata &lt;- reactiveValues(wb = NULL)\n  status &lt;- reactiveValues(text = 'Waiting')\n  \n  ## Disable download button\n  observe({\n    session$sendCustomMessage('disableButton', 'butDownload')\n  })\n\n  ## Generate Excel output\n  observeEvent(input$butCreate, {\n    session$sendCustomMessage('disableButton', 'butDownload')\n    session$sendCustomMessage('disableButton', 'butCreate')\n    \n    ## Included for comparison - the status text will not update until after the spreadsheet is built\n    status$text &lt;- 'Building'\n    \n    m &lt;- matrix(rexp(input$numRows * input$numCols, rate = 0.1), ncol = input$numCols)\n    \n    wb &lt;- createWorkbook()\n    addWorksheet(wb, 'sheet1')\n    writeData(wb, 'sheet1', m)\n    mydata$wb &lt;&lt;- wb\n    session$sendCustomMessage('enableButton', 'butDownload')\n    session$sendCustomMessage('enableButton', 'butCreate')\n    status$text &lt;- 'Completed'\n  })\n  \n  output$butDownload &lt;- downloadHandler(\n    filename = function() {\n      'output.xlsx'\n    },\n    content = function(file) {\n      showNotification('Writing Excel File')\n      saveWorkbook(mydata$wb, file, overwrite = TRUE)\n    }\n  )\n  \n  output$uiStatus &lt;- renderUI(\n    h4(paste0('STATUS: ', status$text), style=\"color:red;\")\n  )\n\n  output$plt &lt;- renderPlot({\n    hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),\n         xlab = 'Duration (minutes)', main = 'Geyser eruption duration')\n    dens &lt;- density(faithful$eruptions, adjust = input$bw_adjust)\n    lines(dens, col = 'blue')\n  })\n}\n\nui &lt;- fluidPage(\n  singleton(tags$head(HTML('\n    &lt;script type=\"text/javascript\"&gt;\n    $(document).ready(function() {\n      // Enable button\n      Shiny.addCustomMessageHandler(\"enableButton\", function(id) {\n        $(\"#\" + id).removeAttr(\"disabled\");\n      });\n      // Disable button\n      Shiny.addCustomMessageHandler(\"disableButton\", function(id) {\n        $(\"#\" + id).attr(\"disabled\", \"true\");\n      });\n      })\n    &lt;/script&gt;\n    ')\n  )),\n  fluidRow(\n    column(4,\n           wellPanel(\n             fluidRow(\n               column(6, numericInput('numRows', 'Number of Rows', value = 100000, min = 1000, step = 1000)),\n               column(6, numericInput('numCols', 'Number of Columns', value = 50, min = 10, step = 10))\n             )\n           ),\n           fluidRow(\n             column(11, offset = 1,\n                    actionButton('butCreate', 'Create Data', class = 'btn action-button btn-success'),\n                    downloadButton('butDownload', 'Download Data', class = 'btn btn-warning'),\n                    br(),\n                    uiOutput('uiStatus')\n             )\n           )\n    ),\n    column(8,\n           wellPanel(\n             fluidRow(\n               column(4, selectInput('n_breaks', label = 'Number of bins:', choices = c(10, 20, 35, 50), selected = 20)),\n               column(4, sliderInput('bw_adjust', label = 'Bandwidth adjustment:', min = 0.2, max = 2, value = 1, step = 0.2))\n             )\n           ),\n           plotOutput('plt')\n           )\n    )\n  )\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2017/2017-04-08-shiny_background_process/index.html#running-as-an-asynchronous-process",
    "href": "posts/2017/2017-04-08-shiny_background_process/index.html#running-as-an-asynchronous-process",
    "title": "Shiny Background Process",
    "section": "Running as an Asynchronous Process",
    "text": "Running as an Asynchronous Process\nThe gist for the code can be found at https://gist.github.com/harveyl888/bf05d902b10c138a02acd5c9c65fc5da\n\n## Data creation\n## \n## Create a large Excel spreadsheet as a asynchronous process\n##\n\nlibrary(shiny)\n\n## Temporary files to store log, script, rds data and excel output\nlogfile &lt;- tempfile()\nscriptfile &lt;- tempfile()\ndatafile &lt;- tempfile()\nexcelfile &lt;- tempfile()\n\nserver &lt;- function(input, output, session) {\n\n  status &lt;- reactiveValues(text = 'Waiting')\n    \n  ## Disable download button\n  observe({\n    session$sendCustomMessage('disableButton', 'butDownload')\n  })\n  \n  # reactivePoll - look for changes in log file every second\n  logData &lt;- reactivePoll(1000, session,\n                          checkFunc = function() {\n                            if (file.exists(logfile))\n                              file.info(logfile)$mtime[1]\n                            else\n                              ''\n                            },\n                          valueFunc = function() {\n                            if (file.exists(logfile))\n                              readLines(logfile)\n                            else\n                              ''\n                            }\n  )\n\n  ## React to an update in the logfile\n  observe({\n    if (grepl('COMPLETED', logData())) {\n      session$sendCustomMessage('enableButton', 'butDownload')\n      session$sendCustomMessage('enableButton', 'butCreate')\n      status$text &lt;- 'Completed'\n    } \n  })\n\n  ## Generate Excel output\n  ## Once button is pressed create an R Script and run as a second process\n  ## to avoid tying up Shiny\n  observeEvent(input$butCreate, {\n    session$sendCustomMessage('disableButton', 'butDownload')\n    session$sendCustomMessage('disableButton', 'butCreate')\n    status$text &lt;- 'Building'\n\n    m &lt;- matrix(rexp(input$numRows * input$numCols, rate = 0.1), ncol = input$numCols)\n    \n    ## Write data to an rds file\n    saveRDS(m, file = datafile)\n    \n    ## Create script file\n    vfile &lt;- c('library(openxlsx)',\n               paste0('m &lt;- readRDS(\\\"', datafile, '\\\")'),\n               'wb &lt;- createWorkbook()',\n               'addWorksheet(wb, \\\"sheet1\\\")',\n               'writeData(wb, \\\"sheet1\\\", m)',\n               paste0('saveWorkbook(wb, \\\"', excelfile, '\\\", overwrite = TRUE)'),\n               paste0('fileConn &lt;- file(\\\"', logfile, '\\\")'),\n               'writeLines(\\\"COMPLETED\\\", fileConn)',\n               'close(fileConn)'\n               )\n    \n    ## Save script file\n    fileConn &lt;- file(scriptfile)\n    writeLines(vfile, fileConn)\n    close(fileConn)\n    \n    ## Execute script file\n    system(paste0(Sys.getenv('R_HOME'), '/bin/Rscript ', scriptfile), wait = FALSE)\n  })\n  \n  output$butDownload &lt;- downloadHandler(\n    filename &lt;- function() {\n      'excel-out.xlsx'\n    },\n    content &lt;- function(file) {\n      file.copy(excelfile, file)\n    }\n  )\n  \n  output$uiStatus &lt;- renderUI(\n    h4(paste0('STATUS: ', status$text), style=\"color:red;\")\n  )\n  \n  output$plt &lt;- renderPlot({\n    hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),\n         xlab = 'Duration (minutes)', main = 'Geyser eruption duration')\n    dens &lt;- density(faithful$eruptions, adjust = input$bw_adjust)\n    lines(dens, col = 'blue')\n  })\n}\n\nui &lt;- fluidPage(\n  singleton(tags$head(HTML('\n    &lt;script type=\"text/javascript\"&gt;\n    $(document).ready(function() {\n      // Enable button\n        Shiny.addCustomMessageHandler(\"enableButton\", function(id) {\n      $(\"#\" + id).removeAttr(\"disabled\");\n      });\n      // Disable button\n        Shiny.addCustomMessageHandler(\"disableButton\", function(id) {\n      $(\"#\" + id).attr(\"disabled\", \"true\");\n      });\n    })\n    &lt;/script&gt;\n    ')\n  )),\n  fluidRow(\n    column(4,\n           wellPanel(\n             fluidRow(\n               column(6, numericInput('numRows', 'Number of Rows', value = 100000, min = 1000, step = 1000)),\n               column(6, numericInput('numCols', 'Number of Columns', value = 50, min = 10, step = 10))\n             )\n           ),\n           fluidRow(\n             column(11, offset = 1,\n               actionButton('butCreate', 'Create Data', class = 'btn action-button btn-success'),\n               downloadButton('butDownload', 'Download Data', class = 'btn btn-warning'),\n               br(),\n               uiOutput('uiStatus')\n             )\n           )\n    ),\n    column(8,\n           wellPanel(\n             fluidRow(\n               column(4, selectInput('n_breaks', label = 'Number of bins:', choices = c(10, 20, 35, 50), selected = 20)),\n               column(4, sliderInput('bw_adjust', label = 'Bandwidth adjustment:', min = 0.2, max = 2, value = 1, step = 0.2))\n             )\n           ),\n           plotOutput('plt')\n           )\n    )\n  )\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2017/2017-03-30-rstudio_connect_databases/index.html",
    "href": "posts/2017/2017-03-30-rstudio_connect_databases/index.html",
    "title": "RStudio Connect and Databases",
    "section": "",
    "text": "I’m starting to experiment with RStudio Connect. I’ve been working on a shiny app that writes to a database and a flexdashboard that can illustrate the output. When writing this type of approach using Shiny Server, both pieces of code could simply point to the same sqlite database. This becomes a little more challenging under RStudio Connect. One solution is to point both pieces of code to a mysql database which resides outside of the RStudio Connect server. In order to run this way, the libmysqlclient library must be installed on the instance running RStudio Connect. Once deployed, the app can update the database and the flexdashboard can be configured to pool from the database and automatically update at fixed intervals."
  },
  {
    "objectID": "posts/2017/2017-03-20-rapid_anova/index.html",
    "href": "posts/2017/2017-03-20-rapid_anova/index.html",
    "title": "Rapid ANOVA p-value Calculation",
    "section": "",
    "text": "There are times when we need to perform ANOVA calculations on multiple sets of features in order to generate a list of p-values. A traditional approach is to use the base function aov and extract the p-value from it. This can be slow when analyzing thousands of features. An alternative is to use the multtest library and calculate the p-values from the F-values.\nAn example is shown below using a matrix of 20 samples (5 groups of 4) and 10000 features. Calculating p-values within an apply loop takes about 18 seconds. Calculating p-values from the F-values using the multtest library takes about 15 milliseconds. Both were determined on a Z640.\n## create an (g x s) x f matrix where g is the number of groups, s is the number of samples in each group and f is the number of features\ng &lt;- 5\ns &lt;- 4\nf &lt;- 10000\ndf.raw &lt;- replicate(g * s, sample(100:100000, f, rep = TRUE))  ## matrix of data\ngroups &lt;- factor(rep(seq(g), each = s))  ## column ids of groups\n## using an apply loop\nmultAnova1 &lt;- function(df.raw, groups) {\n pVector &lt;- apply(df.raw, 1, function(x) {\n   submodel &lt;- lm(x~groups)\n   subanova &lt;- aov(submodel)\n   summary(subanova)[[1]][['Pr(&gt;F)']][[1]]\n })\n p.adjust(pVector, method='BH')\n}\n\nlibrary(multtest)\n## using multtest\nmultAnova2 &lt;- function(df.raw, groups) {\n F_new &lt;- mt.teststat(df.raw, groups, test='f')\n P_new &lt;- pf(F_new, length(levels(groups))-1, length(groups)-length(levels(groups)), lower.tail = F)\n p.adjust(P_new, method='BH')\n}\n\n## benchmarking\nlibrary(microbenchmark)\nlibrary(ggplot2)\nmb &lt;- microbenchmark(\n multAnova1(df.raw, groups),\n multAnova2(df.raw, groups),\n times = 10\n)\nprint(mb)\nautoplot(mb)\nTiming (milliseconds)\n\n\n\n\n\n\n\n\n\n\n\n\n\nexpr\nmin\nlq\nmean\nmedian\nuq\nmax\nnval\n\n\n\n\nmultAnova1(df.raw, groups)\n17467.11\n17609.23\n18085.73\n17882.93\n18203.27\n19628.12\n10\n\n\nmultAnova2(df.raw, groups)\n13.89\n14.25\n15.66\n15.68\n16.31\n18.72\n10"
  },
  {
    "objectID": "posts/2017/2017-02-21-in_the_cloud/index.html",
    "href": "posts/2017/2017-02-21-in_the_cloud/index.html",
    "title": "In The Cloud",
    "section": "",
    "text": "About 2 years ago my beloved Asus G60VX died. I loved that laptop. We’d been through a lot together and enjoyed five wonderful years. After a brief mourn I had a long think about the future and decided to move to a Chromebook. Precisely an Acer C270. I’ve moved from 15”x10” (16” screen), 7.3lbs to 11”x8” (11.6” screen), 2.8lbs. The Asus would run for an hour on its 6-cell battery whereas the Chromebook can hold a charge for 8 hours. For storage I mostly use Google drive and for programming I use Codeanywhere and Digital Ocean droplets (along with firessh, caret and pixlr). Total cost is minimal. Everything I run or test is hosted remotely and internet is freely available almost everywhere - the few times I’ve been unable to connect, my cellphone has proved to be an adequate hotspot.\nIf anything ever happens to my chromebook I could transition to another machine and continue where I left off as if nothing happened. I’m totally cloud-based and loving it!"
  },
  {
    "objectID": "posts/2017/2017-01-14-monitor_player_list/index.html",
    "href": "posts/2017/2017-01-14-monitor_player_list/index.html",
    "title": "Monitoring Fantasy Football Transfers",
    "section": "",
    "text": "There are many fantasy sports out there. Since I’m from England I like playing fantasy football (that’s football, also known as soccer where I am now). Rules are pretty straight forward - pick a team of players from the Premier League and score points depending on how they perform. Most British leagues work on the principle that any team can contain any player and that two teams within a single league can each have the same player. This is contrary to many American fantasy NFL leagues in which the number of managers is limited and player repeats are not allowed. Several years ago, we changed our Premiership League so that each player could only exist in a single team.\nThis means that there is now an advantage to being first to transfer in an on-form player or a potential star once they hit the Premiership. FIFA regulates that leagues should have two transfer windows - one prior to the start of a season and one in the middle. For the Premiership, the in-season transfer window is the month of January. Now, since our league works on the princple that only one team can have any player and that the player has to be posted on the Premierleague site before he can be transferred into a team, there’s a distinct advantage to knowing as soon as a player is available. This can be easily accomplished using the script below.\nThe code works by monitoring the Premierleague site, in particular the web page that lists all the players. It grabs the player list, compares it to the previously grabbed list and, if there have been any changes, sends out a pushbullet notification. Pushbullet’s a great service allowing communication to multiple devices simultaneously. I run this on a Digital Ocean droplet through a cron job. The code is accompanied by a .rpushbullet.json file which contains the pushbullet key and device parameters.\n\n##\n## transferWatch\n##\n## Monitor fantasy premierleague player list for updates during transfer window.\n## Send a pushbullet notification when the player list has changed.\n## Run as a cron job to send updates at regular intervals\n##\n## crontab:\n## 0 * * * * Rscript $HOME/codes/transferWatch/transferWatch.R\n## run every hour\n##\n\nlibrary(rvest)\nlibrary(xml2)\nlibrary(dplyr)\nlibrary(RPushbullet)\nlibrary(methods)\n\ndataFolder &lt;- Sys.getenv('HOME')\nl.devices &lt;- RPushbullet::pbGetDevices()\ndevices &lt;- unlist(lapply(l.devices[['devices']], function(x) x[['nickname']]))\n\n# Scrape site and pull back tables of players\nurl &lt;- 'https://fantasy.premierleague.com/player-list/'\npos &lt;- c('GLK', 'DEF', 'MID', 'FWD')\ntabs &lt;- url %&gt;% xml2::read_html(url) %&gt;% html_nodes('.ism-table') %&gt;% html_table()\n\nfor (i in seq_along(tabs)) {\n  tabs[[i]]$Pos &lt;- pos[(i+1) %/% 2]\n}\nnew.tables &lt;- dplyr::bind_rows(tabs)\n\nfilename &lt;- paste0(dataFolder, '/players.csv')\nif (file.exists(filename)) {\n  # Read in old data\n  old.tables &lt;- read.csv(filename, stringsAsFactors = F, encoding = 'UTF-8')\n  # Compare tables\n  df.new &lt;- dplyr::setdiff(new.tables[, c(1,2,5)], old.tables[, c(1,2,5)])\n  if (nrow(df.new) &gt; 0) {\n    newPlayers &lt;- paste0(apply(df.new, 1, function(x) paste0(x, collapse = ', ')), collapse='\\n')\n    RPushbullet::pbPost('note', 'Transfer News', body = newPlayers, recipients = devices)\n  }\n} \n\n# Write new data to file\nwrite.csv(new.tables, filename, row.names=F)"
  },
  {
    "objectID": "posts/2017/2017-01-09-fantasy_football_optimize/index.html",
    "href": "posts/2017/2017-01-09-fantasy_football_optimize/index.html",
    "title": "Fantasy football",
    "section": "",
    "text": "For the 2016/17 Premiership season some friends set up a fantasy football league for kids to play against their dads. My son wanted his own team but doesn’t know much about Premiership players and their abilities so we decided to look into writing some code to pick a team for him. Our target was to pick a team, within certain constraints, with the potential for scoring the maximum points - sounds a lot like a linear optimization. A quick search led me to a blog entry where this has already been applied and we took this as the basis of our code (all written in R).\nFirst we want a list of the players with some information such as the team they play for and their cost. We’d also like some assessment of how much they are likely to score as this is what we’ll be aiming to maximize. In this case we’ll be using last season’s score. The player list can be easily scraped from the fantasy premierleague site.\n## Read in the current player list\n## This reads in the player list from premierleague.com.\n\nlibrary(rvest)\nlibrary(xml2)\n url &lt;- 'https://fantasy.premierleague.com/player-list/'\n pos &lt;- c('GLK', 'DEF', 'MID', 'FWD')\n tabs &lt;- url %&gt;% read_html() %&gt;% html_nodes('.ism-table') %&gt;% html_table()\n \n for (i in seq_along(tabs)) {\n   tabs[[i]]$Pos &lt;- pos[(i+1) %/% 2]\n }\n df &lt;- dplyr::bind_rows(tabs)\nScraping from the site provides an up to date player list including any additions / subtractions from the beginning of the season as well as the current score. We pulled back the list before the season started which included last season’s score and stored it in a Gist.\ndf &lt;- read.csv('https://gist.githubusercontent.com/harveyl888/269ee507a9dc2939c84bfd1f550a6931/raw/3f4c8986623af7a06831fc51322261e95a350024/playerlist_2016_start.csv', stringsAsFactors = FALSE, check.names = FALSE)\nAt this point we have a data frame that contains player name, team, points scored last season, cost and position. Points scored last season can be used as an approximate indicator of performance this year but what about players who are new to the Premiership? A very crude estimation can be made by assuming that cost is somewhat proportional to points accrued. Of course, every season there are players who under- or over-perform based on their cost and we’re not taking into account random events such as season-ending injuries, but we’ll assume that the gurus at the Premiership have got the price assessment somewhat right and will use this to estimate the new players.\n## Load a few libraries\nlibrary(dplyr)\nlibrary(lpSolve)\nlibrary(formattable)\nlibrary(ggplot2)\n\n## Pull out the numeric cost\ndf$Cost_Val &lt;- as.numeric(substring(df$Cost, 2))\n\n## Define positions\npos &lt;- c('GLK', 'DEF', 'MID', 'FWD')\n\nl.cost &lt;- lapply(pos, function(x) \n  df %&gt;% \n    filter(Pos == x & Points &gt; 0) %&gt;% \n    select(c(Cost_Val, Points))\n)\n\nl.sum &lt;- lapply(l.cost, function(x) \n  summary(lm(x$Points ~ x$Cost_Val))\n)\n\n## Estimate points for new players based on associated cost\ndf$newPoints &lt;- apply(df, \n                      1, \n                      function(x) ifelse(as.numeric(x['Points']) &gt; 0, \n                                         as.numeric(x['Points']), \n                                         as.numeric(l.sum[[match(x['Pos'], pos)]]$coefficients[[2]]) * as.numeric(x['Cost_Val']) + as.numeric(l.sum[[match(x['Pos'], pos)]]$coefficients[[1]])\n                                         ))\n\n## Generate plots\nl.plot &lt;- lapply(pos, function(x) {\n  df %&gt;% filter(Pos == x) %&gt;%\n    mutate(PredPoints = ifelse(Points == 0, newPoints, Points)) %&gt;%\n    mutate(Pred = ifelse(Points == 0, 2, 4)) %&gt;%\n    select(Cost_Val, PredPoints, Pred)\n})\n\nlapply(seq_along(l.plot), function(x) \n  ggplot(l.plot[[x]], aes(x=Cost_Val, y=PredPoints, col=Pred)) + \n  geom_point(aes(size = Pred)) + \n  theme(legend.position = \"none\") +\n  labs(title = paste0('Position = ', pos[x]))\n)\nIn the plots below the red dots represent predicted points for new players based on cost alone.\nNow we have cost and points assigned to each player we can build out linear solver. First we define some constraints. In the fantasy Premierleague game, a squad comprises of 15 players (2 goalkeepers, 5 defenders, 5 midfielders and 3 forwards). The total cost of the squad cannot exceed £100M. These constraints are defined below.\n### Constraints\nnum_gk = 2\nnum_def = 5\nnum_mid = 5\nnum_fwd = 3\nmax_cost = 100\nIn addition, the maximum number of players from any one team is capped at 3. I prefer to stack the odds and bias the squad to teams that, history has shown, are likely to score higher in fantasy football. Finally, several players have been injured prior to the start of the season. These are players that I wouldn’t want to select and so an injury flag of 0 or 1 is added.\n## Add player positions as flag 0 or 1\nfor (p in pos) {\n  df[[p]] &lt;- ifelse(df$Pos == p, 1, 0)\n}\n\n## flag injured players\ndf[['inj']] &lt;- 0\ndf[df$Player %in% c('Bellerín', 'Mertesacker', 'Welbeck', 'Mings', 'Stanislas', 'Mikel',\n                    'Zouma', 'Campbell', 'Sako', 'Besic', 'Browning', 'Pennington', 'Bruce',\n                    'Dawson', 'Maguire', 'McGregor', 'Odubajo', 'Karius', 'Gündogan', 'Ayala',\n                    'Bernardo', 'Husband', 'Leadbitter', 'Bertrand', 'Afellay', 'Ireland',\n                    'Cattermole', 'Kirchhoff', 'Larsson', 'Baston', 'Dja Djédjé', 'Cresswell',\n                    'Lanzini', 'Sakho'), 'inj'] &lt;- 1\n\nteams &lt;- unique(df$Team)\nteam_max &lt;- c(3,3,3,3,3,2,2,2,2,2,2,1,2,1,0,1,0,0,0,1)\ndf.teams &lt;- data.frame(team = unique(df$Team), 'max pick' = team_max)\nNow we’re ready to build our optimizer.\n## Now let's build our constraint matrix\n## The first 4 columns define the player position as either goalkeeper, defender, midfielder \n## or forward.  Players either play in that position (1) or not (0)\n## Column 5 contains the player cost\n## Columns 6-25 cover the team (1 if they player plays for the team and 0 if he does not)\n## The last column contains injury information (0 if healthy and 1 if injured)\nteam_constraint = unlist(lapply(unique(df$Team), function(x, df) {\n  ifelse(df$Team==x, 1, 0)\n}, df=df))\n\nconst_mat = matrix(c(df$GLK, df$DEF, df$MID, df$FWD,\n                     df$Cost_Val, team_constraint, df$inj),\n                   nrow=(6 + length(unique(df$Team))),\n                   byrow=TRUE)\n\n## Next we need to define the righthand side of the constraints.\n## Each of these terms have been defined above.\nconst_rhs = c(num_gk, num_def, num_mid, num_fwd, max_cost, team_max, 0)\n\n## Finally we define the constraint direction.  This defines how the left and righthand sides\n## are related.\n## In this case we hold the number of goalkeepers, defenders, midfielders and forwards constant.\n## The total cost should be less than or equal to max_cost and the number of players per team is\n## less than or equal to each team's maximum.\n## The number of injured players has been set to zero.\nconst_dir &lt;- c(\"=\", \"=\", \"=\", \"=\", rep(\"&lt;=\", 21), '=')\nWe have our optimizer ready. Repeated runs will lead to the same outcome but it’s useful to generate more than one team for comparison therefore we’ll repeat the calculation with a slight jitter to the predicted score.\nnum_repeats &lt;- 100  ## generate 100 teams\n\ndf.rep &lt;- df\nl.out &lt;- list()\nfor (i in seq(num_repeats)) {\n  \n  ## Add a little jitter to the predicted points\n  df.rep$newPoints &lt;- jitter(df.rep$newPoints, factor = 250)\n\n  # Define the vector to optimize against\n  objective = df.rep$newPoints\n\n  ## Perform the optimization\n  x = lp(\"max\", objective, const_mat, const_dir, const_rhs, all.bin=TRUE, all.int=TRUE)\n  \n  ## Get the best solution\n  l.out[[i]] &lt;- arrange(df.rep[which(x$solution==1),], desc(GLK), desc(DEF), desc(MID), desc(FWD), desc(newPoints))\n}\n\n## plot the scores\nplot(sapply(l.out, function(x) sum(x$newPoints)))\nThis generates 100 teams. The predicted scores will generally increase over time due to the fact that we’re starting from an optimized team each time.\nI put this together for my son and he went through the teams, selecting one that appealed to him. We’re around 1/2 way through the season now - how is he doing?\nlibrary(jsonlite)\n\n#leagueID &lt;- ?????\n\n## Get league information\nurl &lt;- paste0('https://fantasy.premierleague.com/drf/leagues-classic-standings/', leagueID, '?phase=1')\nleagueTableData &lt;- fromJSON(url)\nl.man &lt;- leagueTableData$standings$results$entry\n\n## Get team history information\nl.teams &lt;- lapply(l.man, function(x) {\n  Sys.sleep(0.2)\n  url &lt;- paste0('https://fantasy.premierleague.com/drf/entry/', x, '/history')\n  fromJSON(url)\n})\n\n## Put together a table of scores\nl.teamleague &lt;- lapply(seq(l.teams), function(x) {\n  data.frame(team = x, week = l.teams[[x]]$history$event, score = l.teams[[x]]$history$points, total_score = l.teams[[x]]$history$total_points)\n})\n\ndf.teamleague &lt;- bind_rows(l.teamleague)\ndf.teamleague$team &lt;- factor(df.teamleague$team, levels = unique(df.teamleague$team))\ndf.teamleague &lt;- df.teamleague %&gt;% \n  arrange(week, total_score) %&gt;% \n  group_by(week) %&gt;% \n  mutate(rank = 8 - row_number()) %&gt;%\n  arrange(week, rank)\n\nggplot(df.teamleague, aes(x=week, y=score, group=team)) + geom_line(aes(col=team))\nggplot(df.teamleague, aes(x=week, y=total_score, group=team)) + geom_line(aes(col=team))\nggplot(df.teamleague, aes(x=week, y=rank, group=team)) + \n  geom_line(aes(col=team)) + \n  scale_y_reverse(breaks=seq(1,7))\nHe’s doing pretty good! His team is team #1 in the graphs below. At week 8 he took the lead and has manage to hold it. We’re at week 20 so we’ll see how the rest of the season goes. As the season goes on he’s learning more about players but is still at a disadvantage compared to other managers in terms of Premiership knowledge. Next season we’ll work changing the team thoughout the season."
  },
  {
    "objectID": "posts/2017/2017-01-09-fantasy_football_optimize/index.html#update-may-22-2017",
    "href": "posts/2017/2017-01-09-fantasy_football_optimize/index.html#update-may-22-2017",
    "title": "Fantasy football",
    "section": "Update (May 22, 2017)",
    "text": "Update (May 22, 2017)\nOh so close! Jake led up to the penultimate week and was then caught."
  },
  {
    "objectID": "posts/2016/2016-11-24-black_friday/index.html",
    "href": "posts/2016/2016-11-24-black_friday/index.html",
    "title": "Scraping for Dishwashers",
    "section": "",
    "text": "Our dishwasher broke and was beyond repair. Time for a new one. Fortunately Black Friday was approaching so there were plenty of deals to be found. It seems it’s now easier than ever to pull information off the web and much of it is in a usable format so, if you ask me to identify a replacement dishwasher, web-scraping is where I’m going to start. I’m a big fan of the R library rvest and it took little time to pull back some useful information off the Home Depot website.\n\nlibrary(rvest)\nlibrary(xml2)\n\n## Choose a starting point\nbaseurl &lt;- 'http://www.homedepot.com/b/Appliances-Dishwashers-Built-In-Dishwashers/N-5yc1vZc3nj'\n\n## Data frame to hold results\ndf &lt;- data.frame(model = character(0), rating = numeric(0), link = character(0))\nurl &lt;- baseurl\nloadNextPage &lt;- TRUE\nwhile(loadNextPage) {  ## Loop through pages\n  print('Reading Page')\n  Sys.sleep(0.1)  ## Let's be nice\n  html &lt;- url %&gt;%\n    read_html()  ## pull back the page\n  dw &lt;- html %&gt;%\n    html_nodes('.plp-pod') ## focus in on the dishwashers\n  model &lt;- dw %&gt;%\n    html_node('.pod-plp__model') %&gt;%\n    html_text() ## get model ID\n  model &lt;- gsub('[^[:alnum:] ]', '', model)\n  model &lt;- trimws(sub(\"Model\\\\s([^ ]*).*$\", \"\\\\1\", model)) ## remove the unwanted\n  rating &lt;- dw %&gt;%\n    html_nodes('.pod-plp__ratings') %&gt;%\n    html_node('a') %&gt;%\n    html_node('span') %&gt;%\n    html_attr('rel') %&gt;%\n    as.numeric() ## rating can be found in a link\n  link &lt;- dw %&gt;%\n    html_nodes('.plp-pod__image') %&gt;%\n    html_nodes('a') %&gt;%\n    html_attr('href') ## link to more information\n  df &lt;- rbind(df, data.frame(model = model, rating = rating, link = paste0('http://www.homedepot.com', link)))\n  gotoNext &lt;- html %&gt;%\n    html_nodes('.hd-pagination__link') %&gt;%\n    html_nodes(xpath = '//a[contains(@title,\"Next\")]') ## Link to the next page\n  if (length(gotoNext) &gt; 0) {\n    url &lt;- gotoNext %&gt;% html_attr('href')\n    url &lt;- paste0('http://www.homedepot.com', url)\n    loadNextPage &lt;- TRUE  ## Next page exists\n  } else {\n    loadNextPage &lt;- FALSE ## We've reached the last page\n  }\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Harvey Lieberman",
    "section": "",
    "text": "My name is Harvey and I’m a\n          \n        \n\n        \n      \n\nAbout Blog"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "I’m a passionate data scientist who works in the Pharmaceutical Industry. I love both science and technology and the blurry interface between them.\nI spent many years at Sanofi working in areas such as property prediction, laboratory automation and omics biomarker analysis. I am currently working at Novartis as a data scientist within biostatistics.\nI also help run R/Pharma, an organization dedicated to promoting data science (primarily through R) within the Pharma and Biotech industries.\nI’ve been programming for around 40 years now and have experience in more than 20 languages and many operating systems, including several extinct ones! Currently, much of my programming favors R with python thrown in where applicable."
  },
  {
    "objectID": "posts/2016/2016-11-23-why_blog/index.html",
    "href": "posts/2016/2016-11-23-why_blog/index.html",
    "title": "Why blog? Why now?",
    "section": "",
    "text": "So why write a blog and why write it now?\nI’m not a writer. I won’t even pretend to be a writer. That’s something reserved for my wife (she is actually a professional writer). I do, however, spend quite a bit of time writing code and it’s now time to articulate some thoughts and share code. I’m also getting to the point where I find myself going through the same thought process to solve a problem and, in the spirit of DRY programming, I’d like to keep a record so that I can save some time. Quite frankly it’s a selfish thing I’m doing here but feel free to join the ride.\nThis site is created using Jekyll along with a theme called Skinny Bones and hosted on Github pages (I’m a huge fan of all things Github)."
  },
  {
    "objectID": "posts/2016/2016-12-20-R_notebooks_collapse/index.html",
    "href": "posts/2016/2016-12-20-R_notebooks_collapse/index.html",
    "title": "R-Notebooks Collapse Button",
    "section": "",
    "text": "I’ve taken to using R Notebooks for many of the tasks that I used to write in R Markdown. Advantages are that code chunks can be executed independently, leading to easier management and debugging, and that the output is still a usable document.\nThere are times, however, when I would like to include a large table or multiple plots but don’t want them to take up too much of the output document. For tables this can easily be accomplished using a datatable but for more complex tables or multiple plots placing them in a collapsible div attached to a button works well. In the code chunk below, formattable is used to format the iris dataset.\n\nlibrary(htmltools)\nlibrary(formattable)\nHTML('&lt;div class=\"row\"&gt;\n        &lt;div class=\"col-md-12\"&gt;\n          &lt;button type=\"button\" class=\"btn btn-warning btn-sm code-folding-btn\" data-toggle=\"collapse\" data-target=\"#table_iris\" aria-expanded=\"false\"&gt;\n            &lt;span&gt;Iris Data&lt;/span&gt;\n          &lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n&lt;div id=\"table_iris\" class=\"collapse\"&gt;')\nas.htmlwidget(formattable(iris,\n                          list(Sepal.Length = color_tile(\"white\", \"lightpink\"),\n                          Sepal.Width = color_tile(\"white\", \"lightgreen\"),\n                          Petal.Length = color_tile(\"white\", \"lightpink\"),\n                          Petal.Width = color_tile(\"white\", \"lightgreen\"))), \n                          width = '30%')\nHTML('&lt;/div&gt;')"
  },
  {
    "objectID": "posts/2017/2017-01-13-managing_users/index.html",
    "href": "posts/2017/2017-01-13-managing_users/index.html",
    "title": "Managing Users",
    "section": "",
    "text": "There are several ways that users can be managed in Shiny apps but they all require access to the config file. User access can be managed within the app itself using a database to hold user information. Two examples are given below: The first utilizes a simple database in which the passwords are not encrypted (not recommended for multiple reasons!) The second is very similar but it uses the sodium library to encode the passwords in the database. These are very simplistic examples and contain no functions for password management (such as users being able to change their passwords or password reset) but these would be straight forward to add."
  },
  {
    "objectID": "posts/2017/2017-01-13-managing_users/index.html#user-login---no-encrpytion",
    "href": "posts/2017/2017-01-13-managing_users/index.html#user-login---no-encrpytion",
    "title": "Managing Users",
    "section": "User login - No encrpytion",
    "text": "User login - No encrpytion\nhttps://gist.github.com/harveyl888/a85e17c3048e0da03cf4e6b52d1da3db\n\n## Authentication\n## This is a small app to demonstrate user-managed authentication without encoded passwords.\n## Users are stored in a SQL database with passwords along with roles.  \n## Once a user is logged in the shiny app responds to the user's role.\n## In order to use in a real setting, additional code for password management,\n## changing and resetting would need to be implemented.\n\nlibrary(shiny)\nlibrary(RSQLite)\n\n## create the initial password database\n## This code should be run once to create the initial database of users, passwords and roles\n##\n# db.pw &lt;- data.frame(user = c('Augustin', 'Matt', 'Harvey'), role = c('Manager', 'User', 'User'), password = c('ABC', 'DEF', 'GHI'))\n# db = dbConnect(SQLite(), dbname = 'auth_nohash.sqlite')\n# dbSendQuery(db, 'CREATE TABLE pw (user TEXT, password TEXT, role TEXT)')\n# apply(db.pw, 1, function(x) dbSendQuery(db, paste0('INSERT INTO pw VALUES(\"', x['user'], '\", \"', x['password'], '\", \"', x['role'], '\")')))\n# dbDisconnect(db)\n\n## Connect to the database (may be a remote connection)\ndb = dbConnect(SQLite(), dbname = 'auth_nohash.sqlite')\n\nserver &lt;- function(input, output, session) {\n  \n  ## Initialize - user is not logged in\n  user &lt;- reactiveValues(login = FALSE, name = NULL, role = NULL, header = NULL)\n  \n  ## Display login modal\n  observe({\n    showModal(modalDialog(\n      title = \"Enter Login Details\",\n      textInput('userInp', 'Login'),\n      passwordInput('pwInp', 'Password'),\n      actionButton('butLogin', 'Login', class = 'btn action-button btn-success', icon = icon('sign-in')),\n      size = 's',\n      easyClose = FALSE,\n      footer = NULL\n    ))\n  })\n  \n  ## Check for user in database\n  observeEvent(input$butLogin, {  ## login button pressed\n    req(input$userInp, input$pwInp)  ## ensure we have inputs\n    removeModal()  ## remove the modal\n    pw_out &lt;- dbGetQuery(db, paste0('SELECT password FROM pw WHERE user = \\\"', input$userInp, '\\\"'))  ## query database\n    if (nrow(pw_out) == 0) {  ## user does not exist\n      user$login &lt;- FALSE\n      user$header &lt;- 'ERROR - UNKNOWN USER'\n    } else {\n      pw &lt;- as.character(pw_out$password)[[1]]  ## grab password from database\n      passwordVerified &lt;- pw == input$pwInp  ## check that it matches user input\n      if (passwordVerified) {  ## match\n        user$login &lt;- TRUE\n        user$name &lt;- input$userInp\n        user$role &lt;- db.pw[db.pw$user == input$userInp, 'role']\n        user$header &lt;- paste0(user$name, ' (', user$role, ')')\n      } else {  ## no match\n        user$login &lt;- FALSE\n        user$header &lt;- 'ERROR - INCORRECT PASSWORD'\n      }\n    }\n  })\n  \n  ## close database on exit\n  session$onSessionEnded(function(){\n    dbDisconnect(db)\n  })\n  \n  output$data &lt;- renderUI({\n    h4(user$header)\n  })\n  \n  output$myPlot &lt;- renderPlot({\n    req(user$login)\n    if (user$role == 'Manager') {  ## If manager role, display iris plot\n      plot(iris$Sepal.Length, iris$Sepal.Width)\n    } else {  ## If user role, display mtcars plot\n      plot(mtcars$mpg, mtcars$cyl)\n    }\n  })\n  \n}\n\nui &lt;- fluidPage(\n  uiOutput('data'),\n  plotOutput('myPlot')\n)\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2017/2017-01-13-managing_users/index.html#user-login---with-encrpytion",
    "href": "posts/2017/2017-01-13-managing_users/index.html#user-login---with-encrpytion",
    "title": "Managing Users",
    "section": "User login - With encrpytion",
    "text": "User login - With encrpytion\nhttps://gist.github.com/harveyl888/3e5123a6469fbdc3830123e3efb31a2a\n\n## Authentication\n## This is a small app to demonstrate user-managed authentication using a hash to encode passwords.\n## Users are stored in a SQL database with passwords along with roles.\n## Once a user is logged in the shiny app responds to the user's role.\n## In order to use in a real setting, additional code for password management,\n## changing and resetting would need to be implemented.\n\nlibrary(shiny)\nlibrary(RSQLite)\nlibrary(sodium)\n\n## create the initial password database\n## This code should be run once to create the initial database of users, passwords and roles\n##\n# db.pw &lt;- data.frame(user = c('Augustin', 'Matt', 'Harvey'), role = c('Manager', 'User', 'User'), password = c('ABC', 'DEF', 'GHI'))\n# db.pw$encrypt &lt;- apply(db.pw, 1, function(x) password_store(x['password']))\n# db = dbConnect(SQLite(), dbname = 'auth_hash.sqlite')\n# dbSendQuery(db, 'CREATE TABLE pw (user TEXT, password TEXT, role TEXT)')\n# apply(db.pw, 1, function(x) dbSendQuery(db, paste0('INSERT INTO pw VALUES(\"', x['user'], '\", \"', x['encrypt'], '\", \"', x['role'], '\")')))\n# dbDisconnect(db)\n\n## Connect to the database (may be a remote connection)\ndb = dbConnect(SQLite(), dbname = 'auth_hash.sqlite')\n\nserver &lt;- function(input, output, session) {\n  \n  ## Initialize - user is not logged in\n  user &lt;- reactiveValues(login = FALSE, name = NULL, role = NULL, header = NULL)\n  \n  ## Display login modal\n  observe({\n    showModal(modalDialog(\n      title = \"Enter Login Details\",\n      textInput('userInp', 'Login'),\n      passwordInput('pwInp', 'Password'),\n      actionButton('butLogin', 'Login', class = 'btn action-button btn-success', icon = icon('sign-in')),\n      size = 's',\n      easyClose = FALSE,\n      footer = NULL\n    ))\n  })\n  \n  ## Check for user in database\n  observeEvent(input$butLogin, {  ## login button pressed\n    req(input$userInp, input$pwInp)  ## ensure we have inputs\n    removeModal()  ## remove the modal\n    pw_out &lt;- dbGetQuery(db, paste0('SELECT password FROM pw WHERE user = \\\"', input$userInp, '\\\"'))  ## query database\n    if (nrow(pw_out) == 0) {  ## user does not exist\n      user$login &lt;- FALSE\n      user$header &lt;- 'ERROR - UNKNOWN USER'\n    } else {\n      pw &lt;- as.character(pw_out$password)[[1]]  ## grab password from database\n      passwordVerified &lt;- password_verify(pw, input$pwInp)  ## check that it matches user input\n      if (passwordVerified) {  ## match\n        user$login &lt;- TRUE\n        user$name &lt;- input$userInp\n        user$role &lt;- db.pw[db.pw$user == input$userInp, 'role']\n        user$header &lt;- paste0(user$name, ' (', user$role, ')')\n      } else {  ## no match\n        user$login &lt;- FALSE\n        user$header &lt;- 'ERROR - INCORRECT PASSWORD'\n      }\n    }\n  })\n  \n  ## close database on exit\n  session$onSessionEnded(function(){\n    dbDisconnect(db)\n  })\n  \n  output$data &lt;- renderUI({\n    h4(user$header)\n  })\n  \n  output$myPlot &lt;- renderPlot({\n    req(user$login)\n    if (user$role == 'Manager') {  ## If manager role, display iris plot\n      plot(iris$Sepal.Length, iris$Sepal.Width)\n    } else {  ## If user role, display mtcars plot\n      plot(mtcars$mpg, mtcars$cyl)\n    }\n  })\n  \n}\n\nui &lt;- fluidPage(\n  uiOutput('data'),\n  plotOutput('myPlot')\n)\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2017/2017-02-06-split_apply_combine/index.html",
    "href": "posts/2017/2017-02-06-split_apply_combine/index.html",
    "title": "Split-Apply-Combine",
    "section": "",
    "text": "A common task when working with data is split-apply-combine – splitting a dataset up, applying a function and then recombining the results. It’s often performed in creating summary tables around a factor.\nFirst let’s define the data to be used. I’m interested in a scenario where I have nS samples at nC concentrations repeated nR times. For each of these I’d like nF pieces of data (features). The table to construct will have nS.nC.nR rows and nF columns of data.\n\nlibrary(data.table)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(naturalsort)\n\n### Generate table\n\nnF &lt;- 50  # number of features\nnS &lt;- 20  # number of samples\nnR &lt;- 5  # number of replicates\nconc &lt;- c(0, 5, 10, 20)  # concentration per sample\nnormalizeConc &lt;- conc[1]  # concentration for normalization\n\ndt &lt;- data.table(\n  Sample = rep(paste0('Sample_', seq(nS)), each = nR * length(conc)),\n  Concentration = rep(rep(conc, each = nR), times = nS)\n)\nfor (i in seq(nF)) dt[, paste0('F', i) := runif(n = nS * nR * length(conc), min = 0, max = 100)]\ndf &lt;- as.data.frame(dt)\n\nThe top of the table is shown below.\n\nTable dimensions = 400 x 52.\nThe data is stored as both a data frame (df) and a data table (dt) for comparison later.\nFor my application, I’d like to take a table, split or group it by Sample and Concentration, calculate the mean of the replicates for each sample-concentration pair and then divide all data by the corresponding sample at concentration = 0. This can readily be accomplished under base R by using the split.data.frame function which takes a data frame and splits it into a list of data frames defined by a vector. The method below splits the data frame by Sample and then again by Concentration, performing the ratio calculation for each Concentration under each Sample. It then recombines all the data frames using rbind.\n\n## Using base R\nbase_method &lt;- function(df, normalizeConc) {\n  split.data &lt;- split.data.frame(df, df$Sample)  ## split by sample\n  features &lt;- names(df)[grep('F[0-9]+', names(df))]  ## grab column names corresponding to features\n  l.split &lt;- lapply(split.data, function(x) {  ## loop over samples\n    v.means &lt;- colMeans(x[x$Concentration == normalizeConc, features])  ## calculate average of normalizing concentration\n    split.data2 &lt;- split.data.frame(x, x$Concentration)  ## split by concentration\n    l.splitConc &lt;- lapply(split.data2, function(y) {  ## loop over concentrations within a sample\n      df.ratio &lt;- colMeans(y[, features]) / v.means  ## calc ratio of average of each concentration to average of normalizing concentration\n    })\n    df.splitConc &lt;- data.frame(Sample = x[['Sample']][1], Concentration = as.numeric(names(l.splitConc)), do.call('rbind', l.splitConc), stringsAsFactors = FALSE)  ## construct a data frame of all concentration ratios for a single sample\n    df.splitConc &lt;- df.splitConc[df.splitConc$Concentration != normalizeConc, ]  ## get rid of the normalizing concentration (ratio = 1)\n  })\n  names(l.split) &lt;- NULL\n  do.call('rbind', l.split)  ## combine all into a single data frame\n}\n\nThe method under base R works but it’s fairly long and not very efficient, using nested lapply loops. A quick look using profvis suggests that the time to run is distributed fairly equally throughout the function so it would be difficult to optimize.\nCleaner code can be written using the data.table package. In this case the table is grouped by Sample and Concentration and the means are calculated in a single step:\n\n## Using data.table\ndt_method &lt;- function(dt, normalizeConc) {\n  features &lt;- names(dt)[grep('F[0-9]+', names(dt))]  ## grab column names corresponding to features\n  dt1 &lt;- dt[, lapply(.SD, mean), by = list(Sample, Concentration), .SDcols = features]  ## calculate means for each sample concentration\n  dt2 &lt;- dt1[, lapply(.SD, function(x) {x / x[Concentration == normalizeConc]} ), by = Sample, .SDcols = features]  ## calculate ratio to the normalizing concentration\n  dt2[, Concentration := dt1[, Concentration]]  ## add the concentration back as a column\n  dt3 &lt;- dt2[Concentration != normalizeConc]  ## get rid of the normalizing concentration (ratio = 1)\n  setcolorder(dt3, c('Sample', 'Concentration', features))  ## reorder columns\n  return(dt3)\n}\n\nThe beauty is in the use of .SD which is a subset of the input data.table.\nOf course, all this can be accomplished in a single line using dplyr and tidyr. I’m a big fan of the tidyverse and the more I use dplyr, the happy I become.\n\n## using dplyr and tidyr\ntidyverse_method &lt;- function(df, normalizeConc) {\n  df %&gt;% \n    gather(feature, value, starts_with('F')) %&gt;%  ## wide -&gt; long\n    group_by(Sample, feature, Concentration) %&gt;%  ## group by Sample, feature and concentration\n    summarise(meanVal = mean(value)) %&gt;%   ## calculate the mean concentration for each sample/feature pair\n    mutate(ratio = meanVal / meanVal[Concentration == normalizeConc]) %&gt;%  ## determine ratio to specific concentration\n    filter (Concentration != normalizeConc) %&gt;%  ## get rid of the rows with ratio = 1\n    select(-meanVal) %&gt;%  ## remove meanVal column\n    spread(feature, ratio) %&gt;%  ## long -&gt; wide\n    arrange(as.numeric(sub('.*_', '', Sample))) %&gt;%  ## rearrange sample ID by number\n    select(Sample, Concentration, one_of(names(df[3:ncol(df)])))  ## original feature order\n}\n\ndata.table wins out on speed but tidyverse is cleaner and more straightforward to modify.\n\nlibrary(microbenchmark)\nmb &lt;- microbenchmark(\n  base_method(df, 0),\n  dt_method(dt, 0),\n  tidyverse_method(df, 0),\n  times = 10\n)\n\nprint(mb)\n\nTiming (milliseconds)\n\n\n\n\n\n\n\n\n\n\n\n\n\nexpr\nmin\nlq\nmean\nmedian\nuq\nmax\nnval\n\n\n\n\nbase_method\n186.05\n206.71\n266.95\n239.96\n330.96\n399.50\n10\n\n\ndt_method\n8.59\n8.90\n17.13\n16.84\n20.22\n36.87\n10\n\n\ntidyverse_method\n72.06\n75.83\n101.01\n82.10\n106.67\n194.53\n10"
  },
  {
    "objectID": "posts/2017/2017-03-06-DT_embedded_table/index.html",
    "href": "posts/2017/2017-03-06-DT_embedded_table/index.html",
    "title": "Datatable Embedded Tables",
    "section": "",
    "text": "Here’s an example of how to embed subtables in a datatable. It’s an enhancement of the child rows example found at https://rstudio.github.io/DT/002-rowdetails.html and works by storing JSON versions of subtables as a column in the main table dataframe. The current release of the DT library converts the JSON format into a javascript array which can simply be rendered to an HTML table (DT version 1.x returned a JSON string which must be converted using JSON.parse).\n\n##\n## EmbeddedTable\n## \n## Shiny app demonstrating how to embed subtables into a datatable\n##\n\nlibrary(shiny)\nlibrary(DT)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output) {\n  \n  ## Generate a data frame containing grouped data\n  ## Subtable is included, formatted as JSON\n  df.start &lt;- data.frame(car = row.names(mtcars), mtcars, row.names = NULL, stringsAsFactors = FALSE)\n  l.df &lt;- split(df.start, df.start$carb)\n  l.cars &lt;- lapply(l.df, function(x) list(num = nrow(x),\n                                          max_hp = max(x$hp),\n                                          cyl_range = ifelse(min(x$cyl) == max(x$cyl), min(x$cyl), paste(range(x$cyl), collapse = '-')),\n                                          subTable = toJSON(x)))\n  df &lt;- data.frame(carb = names(l.cars), do.call('rbind', l.cars), stringsAsFactors = FALSE)\n  \n  \n  output$dt1 &lt;- DT::renderDataTable({\n    DT::datatable(mtcars)\n  })\n  \n  ## shiny table output\n  ## datatable with expand/collapse buttons\n  ## on expanding, subtable is rendered from JSON to HTML\n  output$dt &lt;- DT::renderDataTable({\n    df &lt;- cbind(' ' = '&oplus;', df)\n    datatable(\n      df, \n      escape = -2,\n      options = list(\n        dom = 't',\n        columnDefs = list(\n          list(visible = FALSE, targets = c(0, 6)),  \n          list(orderable = FALSE, className = 'details-control', targets = 1)\n        )\n      ),\n      \n      callback = JS(\"\n                    var format = function(d) {\n                      var table = document.createElement('table');\n                      var tableBody = document.createElement('tbody');\n                      var embeddedTableRows = d[6];  // JSON automatically converted to array\n                      var subtable = [];\n                      var arr = [];\n                      $.each(embeddedTableRows, function (index, item) {\n                        arr = [];\n                        $.each(item, function(k, v) {\n                          arr.push(v);\n                        })\n                        subtable.push(arr);\n                      });\n                      \n                      // Add table headers\n                      headers = [];\n                        $.each(embeddedTableRows[0], function(k, v) {\n                        headers.push(k);\n                      })\n                      for(var i=0; i&lt;headers.length; i++){\n                        table.appendChild(document.createElement('th')).\n                        appendChild(document.createTextNode(headers[i]));\n                      }\n                      \n                      // Add table body\n                      for (var i = 0; i &lt; subtable.length; i++) {\n                        var row = document.createElement('tr');\n                        for (var j = 0; j &lt; subtable[i].length; j++) {\n                          var cell = document.createElement('td');\n                          cell.appendChild(document.createTextNode(subtable[i][j]));\n                          cell.style.backgroundColor = 'lightblue';\n                          row.appendChild(cell);\n                        }\n                        tableBody.appendChild(row);\n                      }\n                      table.appendChild(tableBody);\n                      return(table);\n                    };\n                    \n                    // Event handler - expand inner table\n                    table.on('click', 'td.details-control', function() {\n                      var td = $(this), row = table.row(td.closest('tr'));\n                      if (row.child.isShown()) {\n                        row.child.hide();\n                        td.html('&oplus;').css('color', 'green');\n                      } else {\n                        row.child(format(row.data())).show();\n                        td.html('&CircleMinus;').css('color', 'red');\n                      }\n                    });\"\n      ),\n      selection = 'none') %&gt;% \n      formatStyle(1,  color = 'green', fontWeight = 'bold', fontSize = '150%', cursor = 'pointer')\n  })\n}\n\nui &lt;- fluidPage(\n  br(),\n  h4('Example of embedding subtables in a datatable'),\n  br(),\n  DT::dataTableOutput('dt')\n)\n\nshinyApp(server = server, ui = ui)"
  },
  {
    "objectID": "posts/2017/2017-03-29-chemSymWords/index.html",
    "href": "posts/2017/2017-03-29-chemSymWords/index.html",
    "title": "ChemSymWords",
    "section": "",
    "text": "There seems to be a fad right now of merchandising articles containing words made up of chemical symbols. Beryllium Erbium (BeEr) is particularly popular and I have to admit I have a T-Shirt claiming “Call me NErDy”. I’ve put together a small code in R which will check to see if a word can be created purely by element symbols and then output a PNG.\nThe algorithm to turn a word into symbols is fairly straightforward and involves a little recursion. The recursive function is shown below. It comprises of an outer function (chemwordRecurse) and an inner one chemwordRecurseInternal. The output variable (a list) is initialized in the outer function and utilized within the inner one. This allows a single output to be updated which can be a problem when recursion traverses a tree-like pathway as there could be multiple instances of the output. Recall is a way to recursively call using a placeholder as opposed to specifying the function name.\n\nchemWordRecurse &lt;- function(w, t, sym=elements) {\n  out &lt;- list()\n\n  chemWordRecurseInternal &lt;- function(w, t, sym) {\n    if (nchar(w) == 0) {\n      out[[length(out) + 1]] &lt;&lt;- unlist(t)\n    }\n    for (i in 1:min(max(nchar(sym)), nchar(w))) {\n      find_el &lt;- match(toupper(substring(w, 1, i)),toupper(sym))\n      if (!is.na(find_el)) {\n        Recall(substring(w, i + 1), c(t, find_el), sym)\n      }\n    }\n  }\n  chemWordRecurseInternal(w, t, sym)\n  return(out)\n}\n\nAn old stackexchange thread (http://puzzling.stackexchange.com/questions/5456/the-longest-word-made-from-chemical-symbols) challenges the longest word which can be made out of chemical symbols. At the time of this writing it’s Floccinaucinihilipilifications at 30 letters.\n\nThe code can be found at https://github.com/harveyl888/chemSymWords."
  },
  {
    "objectID": "posts/2017/2017-04-06_querybuilder/index.html",
    "href": "posts/2017/2017-04-06_querybuilder/index.html",
    "title": "queryBuilder",
    "section": "",
    "text": "queryBuilder is an htmlwidget wrapper for jQuery queryBuilder, a fantastic jQuery plugin to create queries and filters. The htmlwidget generates a dplyr string that can be used to filter a data frame within a shiny app. In addition I’m playing with some experimental features to expand functionality. The first is a way to filter on up/down trend, something that I’ve used in metabolomics studies. The second is a group comparison feature, something that’s achieved by switching out the html on the fly - toggling between a textbox and a combobox. An example of the group comparison filter can be found on codepen and the htmlwidget is hosted on github."
  },
  {
    "objectID": "posts/2017/2017-05-24-multidplyr/index.html",
    "href": "posts/2017/2017-05-24-multidplyr/index.html",
    "title": "parallel dplyr",
    "section": "",
    "text": "I’m a big fan of the R packages in the tidyverse and dplyr in particular for performing routine data analysis. I’m currently working on a project that requires fitting dose-repsonse curves to data. All works well when the amount of data is small but as the dataset grows so does the computational time. Fortunately there’s a library (multidplyr) to perform dplyr operations under parallel conditions. By way of example we’ll create a set of dummy data and compare curve fitting using dplyr and multidplyr.\nThe dataset used is the spinach dataset that comes with the drc package. It’s a data frame containing 105 observations in 5 groups. Each group consists of 7 concentrations run in triplicate. To compare dplyr and multidplyr we’ll take these measurements and copy them 1000 times with some jitter."
  },
  {
    "objectID": "posts/2017/2017-05-24-multidplyr/index.html#introduction",
    "href": "posts/2017/2017-05-24-multidplyr/index.html#introduction",
    "title": "parallel dplyr",
    "section": "",
    "text": "I’m a big fan of the R packages in the tidyverse and dplyr in particular for performing routine data analysis. I’m currently working on a project that requires fitting dose-repsonse curves to data. All works well when the amount of data is small but as the dataset grows so does the computational time. Fortunately there’s a library (multidplyr) to perform dplyr operations under parallel conditions. By way of example we’ll create a set of dummy data and compare curve fitting using dplyr and multidplyr.\nThe dataset used is the spinach dataset that comes with the drc package. It’s a data frame containing 105 observations in 5 groups. Each group consists of 7 concentrations run in triplicate. To compare dplyr and multidplyr we’ll take these measurements and copy them 1000 times with some jitter."
  },
  {
    "objectID": "posts/2017/2017-05-24-multidplyr/index.html#code",
    "href": "posts/2017/2017-05-24-multidplyr/index.html#code",
    "title": "parallel dplyr",
    "section": "Code",
    "text": "Code\n\n## Libraries\nlibrary(drc)\nlibrary(dplyr)\nlibrary(multidplyr)\nlibrary(microbenchmark)\nlibrary(ggplot2)\nlibrary(tidyr)\n\n## Create a dummy dataset\ndata &lt;- spinach\nfor (i in 1:1000) {\n  addData &lt;- spinach\n  addData$CURVE &lt;- addData$CURVE + 5 * i\n  addData$SLOPE &lt;- sapply(addData$SLOPE, function(x) jitter(x, factor = 10))\n  data &lt;- rbind(data, addData)\n}\n\n## Define some functions\nmakeFit &lt;- function(d) {\n  tryCatch(drm(SLOPE ~ DOSE, data = d, fct = LL.4()), error = function(e) NA)\n}\n\nfit_dplyr &lt;- function(data, n) {\n  data %&gt;%\n    filter(CURVE &lt;= n) %&gt;%\n    group_by(CURVE) %&gt;%\n    do(fit = makeFit(.))\n}\n\nfit_multidplyr &lt;- function(data, n) {\n  data %&gt;%\n    filter(CURVE &lt;= n) %&gt;%\n    partition(CURVE) %&gt;%\n    cluster_copy(makeFit) %&gt;%\n    cluster_library('drc') %&gt;%\n    do(fit = makeFit(.)) %&gt;%\n    collect(unique_indexes = 'CURVE')\n}\n\n## Benchmark our data\nmicrobenchmark(fit_dplyr(data, 10), times = 3)\nmicrobenchmark(fit_dplyr(data, 100), times = 3)\nmicrobenchmark(fit_dplyr(data, 1000), times = 3)\nmicrobenchmark(fit_dplyr(data, 5000), times = 3)\nmicrobenchmark(fit_multidplyr(data, 10), times = 3)\nmicrobenchmark(fit_multidplyr(data, 100), times = 3)\nmicrobenchmark(fit_multidplyr(data, 1000), times = 3)\nmicrobenchmark(fit_multidplyr(data, 5000), times = 3)\n\n## Conclude with a table and graph\ndf.graph &lt;- data.frame(n = rep(c(10, 100, 1000, 5000), 2), library=rep(c('dplyr', 'multidplyr'), each=4), timing=c(0.20, 3.04, 39.07, 212.89, 0.13, 1.13, 10.13, 49.29))\n\nggplot(df.graph, aes(x=n, y=timing, colour=library)) +\n  geom_point(size = 2) +\n  geom_line() +\n  labs(x = 'number of groups', y = 'timing (seconds)')\n\ndf.table &lt;- df.graph %&gt;%\n  spread(library, timing) %&gt;%\n  mutate(enhancement = round(dplyr / multidplyr, 2))"
  },
  {
    "objectID": "posts/2017/2017-05-24-multidplyr/index.html#conclusion",
    "href": "posts/2017/2017-05-24-multidplyr/index.html#conclusion",
    "title": "parallel dplyr",
    "section": "Conclusion",
    "text": "Conclusion\nIn this case, multidplyr runs up to 4.3 times faster on a 16 core PC. The speed enchancement increases with increasing size of the dataset.\n\n\n\nn\ndplyr (secs)\nmultidplyr (secs)\n\n\n\n\n10\n0.20\n0.13\n\n\n100\n3.04\n1.13\n\n\n1000\n39.07\n10.13\n\n\n5000\n212.89\n49.29"
  },
  {
    "objectID": "posts/2017/2017-09-08-KEGG_neo4j/index.html",
    "href": "posts/2017/2017-09-08-KEGG_neo4j/index.html",
    "title": "KEGG and neo4j",
    "section": "",
    "text": "The KEGG (Kyoto Encyclopedia of Genes and Genomes) database is a useful reference of biochemical pathways often employed in metabolomics and proteomics studies. Various tables from the database can be downloaded in flat file format via ftp (ftp://ftp.pathway.jp/kegg). In addition, xml files containing information on pathway reactions can be download. Although these provide a useful interface to query properties, the real interest in pathways is in their connectivity.\nOf the KEGG tables, the following are most of interest:\n\nreaction: Information on individual reactions (id tag(entry), reaction name, definition of reaction, equation, list of rclass, pathways on which it can be found, enzyme involved in reaction)\nrclass: Information on different reaction classes (id tag (entry), definition of reaction class, pathways on which it can be found, series of pairs of compounds which undergo the reaction (substrate and product pairs), reactions in which this reaction class can be found)\ncompound: Information on compounds (id tag (entry), name, formula, accurate mass, pathways on which it can be found)\nenzyme: Information on enzymes (id tag (entry), name, reaction in which its involved, substrate and product information, pathways on which it can be found)\n\nThe xml files contain three types of element, namely entry (compounds and enzymes), relation (connections between entries) and *reaction^ (information on reactions between substrates/products).\nThere’s considerable redundancy between the tables and it’s relatively straightforward to create a neo4j database from these pieces of information.\nThe command used to populate the database is simply:\n\"MERGE (c1:Compound{properties}) MERGE (c2:Compound{properties}) CREATE (c1)-[:REACTION{properties}]-&gt;(c2)\"\nwhere properties refer to the properties associated with nodes and relations (in JSON notation).\nTo run this within a transaction it’s:\ntx = graph.begin()\nfor t in triples:\n   mergeText = \"MERGE (c1:Compound{properties}) MERGE (c2:Compound{properties}) CREATE (c1)-[:REACTION{properties}]-&gt;(c2)\"\n   tx.append(mergeText)\ntx.commit()\nreplacing the properies with properties of each reaction.\nThree neo4j databases were constructed, comparing the success and information available in each case.\n\nconstruct from rclass file\nThe most straightforward approach is to use the data stored in the rclass file. Each rclass record contains an identifier (entry) and pairs of molecules which undergo the reaction. The database is constructed by Simply taking the pairs of molecules and constructing a series of merge and create records. This method is successful, however the records do not contain information about the direction of the reaction (A-&gt;B, A&lt;-B, A&lt;-&gt;B).\n\n\n\nMapping Connections\n\n\n\n\nconstruct from xml files\nThe xml files contain data on the nodes (compounds / enzymes) and relationships (reactions). They also include the reaction direction (reversible or irreversible). Once read and parsed, the reaction information can be used to populate the database (cross-referencing to information in additional tables). Upon inspection, however, its apparent that the xml files are missing some connectivity information. Indeed, the files have been constructed to aid in visual interpretation of the data which leads to redundancy and missing information.\n\n\n\n\n\n\n\n\n\nMapping Connections\n\n\n\n\n\n\n\nMapping Reactions\n\n\n\n\n\n\n\nconstruct from reaction and file\nCross-referencing the reaction file with the compound, rclass and enzyme files provides the richest information. Two types of relationships can be constructed here - each individual reaction (multiple connections between each pair of compounds) as well as single points of connection between each pair (equivalent to rclass). This highlights the ability of neo4j to store multiple types of relationship between nodes.\n\n\n\n\n\n\n\n\n\nMapping Connections\n\n\n\n\n\n\n\nMapping Reactions\n\n\n\n\n\nThe code can be found at https://github.com/harveyl888/neo4jKEGG"
  },
  {
    "objectID": "posts/2017/2017-10-26-plotly_errorbars/index.html",
    "href": "posts/2017/2017-10-26-plotly_errorbars/index.html",
    "title": "Plotly Error Bar Hack",
    "section": "",
    "text": "Plotly is a great plotting library that I’ve started to use extensively in part due to the ease in connecting graphs together under R. There is, however, a bug when using error bars in conjunction with a group variable - error bars are not drawn in the correct order. This can be fixed with a hack by adding each group as an individual trace.\n\nlibrary(plotly)\nlibrary(dplyr)\nlibrary(tidyr)\n\n## Raw data\ndf &lt;- data.frame(sample = rep(paste0('sample ', 1:5), 4),\n                 x = rnorm(20),\n                 group = rep(paste0('group ', 1:2), each = 10),\n                 stringsAsFactors = FALSE\n)\n\n## Stats table\ndf2 &lt;- df %&gt;%\n  group_by(sample, group) %&gt;%\n  summarise(avg = mean(x), sd = sd(x)) %&gt;%  ungroup()\n\ndf2\n\n# A tibble: 10 × 4\n   sample   group       avg     sd\n   &lt;chr&gt;    &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;\n 1 sample 1 group 1  1.13   0.816 \n 2 sample 1 group 2  0.946  1.55  \n 3 sample 2 group 1  0.798  2.98  \n 4 sample 2 group 2 -0.0644 1.11  \n 5 sample 3 group 1  1.48   0.0388\n 6 sample 3 group 2 -0.439  0.346 \n 7 sample 4 group 1 -0.507  0.225 \n 8 sample 4 group 2  1.59   0.779 \n 9 sample 5 group 1  0.820  1.82  \n10 sample 5 group 2  0.542  1.13  \n\n\n\n## Plotly barchart with error bars.  Error bars are incorrectly assigned\np1 &lt;- plot_ly(df2, x = ~sample, y = ~avg, color = ~group, type = 'bar', error_y = list(array = ~df2$sd))\np1\n\n\n\n\n\n\n## Create individual columns for group data and errors\ndf3 &lt;- df2 %&gt;%\n  gather(key, value, -c(sample, group)) %&gt;%\n  mutate(ref = paste0(group, ifelse(key == 'sd', '_sd', ''))) %&gt;%\n  select(-group, -key) %&gt;%\n  spread(ref, value)\n\ndf3\n\n# A tibble: 5 × 5\n  sample   `group 1` `group 1_sd` `group 2` `group 2_sd`\n  &lt;chr&gt;        &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1 sample 1     1.13        0.816     0.946         1.55 \n2 sample 2     0.798       2.98     -0.0644        1.11 \n3 sample 3     1.48        0.0388   -0.439         0.346\n4 sample 4    -0.507       0.225     1.59          0.779\n5 sample 5     0.820       1.82      0.542         1.13 \n\n\n\n## Plotly barchart displays error bars correctly\np2 &lt;- plot_ly(df3, type = 'bar')\nfor (g in unique(df2$group)) {\n  p2 &lt;- add_trace(p2, x = df3[['sample']], y = df3[[g]], name = g, color = g, error_y = list(array = df3[[paste0(g, '_sd')]]))\n}\np2"
  },
  {
    "objectID": "posts/2018/2018-01-07-code_instead_of_excel/index.html",
    "href": "posts/2018/2018-01-07-code_instead_of_excel/index.html",
    "title": "Code instead of Spreadsheet",
    "section": "",
    "text": "There are many reasons why data analysis should be performed using a language such as R or python over Excel but I’m constantly fighting with colleagues who refuse to adapt.\nHere are five reasons to stop using Excel:\n\nReproducibility\nIt’s very challenging to use what’s been done before with a spreadsheet. You can make additional copies of a workbook but sooner or later the file naming convention is forgotten and you have no idea what you were working on a year ago.\n\n\nVersion Control\nI’ve started applying git to all kids of work, not just programming. From a coding perspective if I can’t keep a detailed log of what I’ve done and branch to try new things I’m lost. Excel 2016 does seem to have some version control through the History pane but since I use Office 2010 at work it’s a moot point. Version control is essential when you’re working with anything that might break.\n\n\nTesting\nWithout built-in tests how can you be sure youre analyses are correct? All too often we find systematic mistakes in spreadsheets. This generally arises from a cut-and-paste operation to an incorrect cell, mixing relative and absolute cell references or not updating a formula from a older spreadsheet version. Breaking a problem into chunks, programming the chunks as functions and running unit tests on those functions will help eradicate any bugs. A few favorite examples - Panko’s analysis of 13 field audits suggested that 94% of spreadsheets contained errors and 5.2% of cells were questionable. (Stephen G. Powell, Kenneth R. Baker and Barry Lawson, 12/01/2007. “A Critical Review of the Literature on Spreadsheet Errors”. Tuck School of Business at Darthmouth College) - The report on J.P. Morgan Chase $6 billion derivatives trading loss points to an unnamed overworked staffer in London who copied and pasted the wrong figures into an Excel spreadsheet, throwing the firm’s risk models out of whack. - One in five papers published genetics papers from 2005-2015 (3600 papers, 18 journals) contain errors due to Excel autoformatting Genome Biology, 2016, 17, 177\n\n\nMaintainability\nI work in Analytical Chemistry and often deal with assay data - essentially a block of data which could be summarized as s samples each run r times against f features. Changing r from two repeat samples to three in Excel is challenging and generally requires adding additional columns and reapplying formulae. This is much more amenable in a programming paradigm where formulae can be much more flexible and account for future changes.\nIn addition, it’s far easier to write and maintain functions under R or python that Excel. The last significant change in VBA was around 2000.\n\n\nNumerical Accuracy\nNumerical accuracy can be an issue for any computing system. The way floating point values are stored has always meant that we have to be careful with rounding and comparing to zero. One particular anomoly has been identified with Excel, however. An old thread at https://office-watch.com/2008/excel-sum-anomaly/ highlights a typical floating point issue. Adding a list of numbers does not exactly equal zero. This is expected since numbers are stored using a limited number of binary digits. What’s interesting is if you take the same column of numbers and order them numerically (high to low or low to high) they do equate to exactly zero. It appears that the result is dependent on the order of the numbers and refutes the commutativity of addition!\n\n\n\n\n-127551.73\n-127551.73\n103130.41\n\n\n\n103130.41\n1568.90\n9028.59\n\n\n\n1807.75\n1794.71\n7390.11\n\n\n\n7390.11\n1807.75\n2831.26\n\n\n\n9028.59\n2831.26\n1807.75\n\n\n\n2831.26\n7390.11\n1794.71\n\n\n\n1568.90\n9028.59\n1568.90\n\n\n\n1794.71\n103130.41\n-127551.73\n\n\nSUM\n0.0000000000086402\n0.0000000000000000\n0.0000000000000000"
  },
  {
    "objectID": "posts/2018/2018-05-23-r_package_update/index.html",
    "href": "posts/2018/2018-05-23-r_package_update/index.html",
    "title": "R 3.5.0 Package Update",
    "section": "",
    "text": "After our IT colleagues updated R to version 3.5.0 I found that I have many packages duplicated between the system library and my user library. This short piece of code lists all packages with their version for all libraries. It helps identify those that can be removed from the user library or updated.\n\n## assess user and system packages\n##\n\nlibrary(purrr)\nlibrary(dplyr)\n\ndf.all &lt;- as.data.frame(installed.packages()[,c(1:4, 16)], stringsAsFactors = FALSE)\ndf.split &lt;- split.data.frame(df.all, df.all$LibPath)\ndf.wide &lt;- reduce(df.split, full_join, by = 'Package')\nnames(df.wide) &lt;- c('Package', paste0(rep(c('libpath_', 'version_', 'priority_', 'built_'), length(df.split)), rep(seq(length(df.split)), each = 4)))\n\n## in library 2 but not 1\ndf.user_lib &lt;- df.wide %&gt;%\n  filter(is.na(libpath_1) & !is.na(libpath_2))\n\n## in both library 1 and 2\ndf.libs12 &lt;- df.wide %&gt;%\n  filter(!is.na(libpath_1) & !is.na(libpath_2))"
  },
  {
    "objectID": "posts/2018/2018-07-13-css_variables/index.html",
    "href": "posts/2018/2018-07-13-css_variables/index.html",
    "title": "Using CSS Variables with Shiny",
    "section": "",
    "text": "Method One - Does not work with IE\nCSS variables are a powerful way to make wholesale changes to the style throughout an entire document. They are set using a custom notation --variable_name and accessed throughout the document using var(--variable_name). With a little javascript these variables can be used in Shiny apps and updated as needed. The example below contains three files: a shiny app (app.R), the CSS styling (style.css) and the associated javascript functions which update the CSS variables (var_change.js). The CSS and javascript files are stored in the www folder. This method works well under Chrome but does not work with Internet Explorer (css variables do not work under IE). Later on in this post we’ll see how to perform the same wholesale changes but with IE.\n\napp.R\n\nlibrary(shiny)\n\nintial_size &lt;- 20\nintial_color &lt;- 'orange'\n\nserver &lt;- function(input, output, session) {\n  \n  session$sendCustomMessage(\"col_change\", intial_color)\n  session$sendCustomMessage(\"size_change\", intial_size)\n  \n  observeEvent(input$but1, {\n    session$sendCustomMessage(\"col_change\", \"green\")\n  })\n  \n  observe({\n    session$sendCustomMessage(\"size_change\", input$sld1)\n  })\n}\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"style.css\"),\n    tags$script(src=\"var_change.js\")\n  ),\n  actionButton('but1', 'change color'),\n  sliderInput('sld1', 'change size', value = 20, min = 1, max = 100, step = 1),\n  h1(\"Heading 1\"),\n  h2(\"Heading 2\"),\n  h3(\"Heading 3\")\n)\n\nshinyApp(ui, server)\n\n\n\nstyle.css\n:root {\n  --heading-color: black;\n  --heading-size: 12px;\n}\n\nh1 {\n  color: var(--heading-color);\n  font-size: var(--heading-size);\n}\n\nh2 {\n  color: var(--heading-color);\n}\n\nh3 {\n  color: var(--heading-color);\n}\n\n\nvar_change.js\nShiny.addCustomMessageHandler(\"col_change\", col_change);\nShiny.addCustomMessageHandler(\"size_change\", size_change);\n\nfunction col_change(x) {\n  document.documentElement.style.setProperty('--heading-color', x);\n}\n\nfunction size_change(x) {\n  document.documentElement.style.setProperty('--heading-size', x + \"px\");\n}\n\n\n\nMethod Two - Not as elegant but does work with IE\n\napp.R\n\nlibrary(shiny)\n\nintial_size &lt;- 20\nintial_color &lt;- 'orange'\n\nserver &lt;- function(input, output, session) {\n  \n  session$sendCustomMessage(\"col_change\", intial_color)\n  session$sendCustomMessage(\"size_change\", intial_size)\n  \n  observeEvent(input$but1, {\n    session$sendCustomMessage(\"col_change\", \"green\")\n  })\n  \n  observe({\n    session$sendCustomMessage(\"size_change\", input$sld1)\n  })\n}\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"style.css\"),\n    tags$script(src=\"var_change.js\")\n  ),\n  actionButton('but1', 'change color'),\n  sliderInput('sld1', 'change size', value = 20, min = 1, max = 100, step = 1),\n  h1(\"Heading 1\", class = \"header_col_change header_size_change\"),\n  h2(\"Heading 2\", class = \"header_col_change\"),\n  h3(\"Heading 3\", class = \"header_col_change\")\n)\n\nshinyApp(ui, server)\n\n\n\nstyle.css\n\nheader_col_change {\n  color: black;\n}\n\nheader_size_change {\n  font-size: 12;\n}\n\n\nvar_change.js\nShiny.addCustomMessageHandler(\"col_change\", col_change);\nShiny.addCustomMessageHandler(\"size_change\", size_change);\n\nfunction col_change(x) {\n  $(\".header_col_change\").css('color', x)\n}\n\nfunction size_change(x) {\n  $(\".header_size_change\").css('fontSize', x)\n}"
  },
  {
    "objectID": "posts/2018/2018-10-11-DT_callback_shiny_module/index.html",
    "href": "posts/2018/2018-10-11-DT_callback_shiny_module/index.html",
    "title": "Datatable Callback in Shiny Module",
    "section": "",
    "text": "Using shiny modules a large shiny application can be broken down into manageable chunks. Modules work well with most aspects of shiny code but care needs to be taken when referencing inputs. This is especially true when javascript is used within a module. Here’s a piece of code which uses a callback in a datatable to capture the current and previous row (something I use to allow automatic updating of a database when a row is changed). The important point is to remember to use session$ns in the server code whenever referencing an input created in the module.\n\nCode outside of a modules\n\n## callback to capture current and previous row - allows automatic updating of database when a new row is selected\ncallback = JS(\n  \"table.on('click.dt', 'tr', function() {\n    $(this).toggleClass('active');\n    if (typeof(current_row) === 'undefined') {\n      Shiny.onInputChange('assay_previous_row', null);\n    } else {\n      Shiny.onInputChange('assay_previous_row', current_row);\n    }\n    current_row = table.rows('.selected').data()[0][0];\n    Shiny.onInputChange('assay_selected_row', current_row);\n  });\"\n)\n\n\n\nCode within a shiny modules\n\n## callback to capture current and previous row - allows automatic updating of database when a new row is selected\ncallback = JS(paste0(\n  \"table.on('click.dt', 'tr', function() {\n    $(this).toggleClass('active');\n    if (typeof(current_row) === 'undefined') {\n      Shiny.onInputChange('\", session$ns('assay_previous_row'), \"', null);\n    } else {\n      Shiny.onInputChange('\", session$ns('assay_previous_row'), \"', current_row);\n    }\n    current_row = table.rows('.selected').data()[0][0];\n    Shiny.onInputChange('\", session$ns('assay_selected_row'), \"', current_row);\n  });\"\n))\n\nThis aproach can also be applied for functions within tables. For example here’s code for a delete button within a table.\n\n\nCode outside of a modules\n\ndelete = as.character(actionButton(paste0('newassaydelete_', newassay$counter), label = NULL, icon = icon('trash'), onclick = paste0('Shiny.onInputChange(\\\"delete_new_assay\\\", this.id)'), style=\"color: #fff; background-color: #cc0000; border-color: #660000\"))\n\n\n\nCode within a shiny modules\n\ndelete = as.character(actionButton(session$ns(paste0('newassaydelete_', newassay$counter)), label = NULL, icon = icon('trash'), onclick = paste0('Shiny.onInputChange(\\\"', session$ns('delete_new_assay'), '\\\", this.id)'), style=\"color: #fff; background-color: #cc0000; border-color: #660000\"))"
  },
  {
    "objectID": "posts/2018/2018-11-09-mimic_button_press/index.html",
    "href": "posts/2018/2018-11-09-mimic_button_press/index.html",
    "title": "Mimic Button Press with Enter Key",
    "section": "",
    "text": "Sometimes it’s useful to mimic a button press in a shiny app when the Enter key is pressed, for example when entering a password. This has been documented before and works well for most situations but fails when the button widget is housed within renderUI. Here’s an alternative that works wherever the password input and button are located.\n\nlibrary(shiny)\nlibrary(shinyjs)\nlibrary(shinyWidgets)\n\njscode &lt;- '\n  shinyjs.setbutton = function(params) {\n    var defaultParams = {\n      id: null,\n      button: null\n    };\n    params = shinyjs.getParams(params, defaultParams);\n    var el = $(\"#\" + params.id);\n    var button = $(\"#\" + params.button);\n    el.keyup(function(event) {\n      if (event.keyCode === 13) {\n        button.click();\n      }\n    })\n  };'\n\nui &lt;- fluidPage(\n  useShinyjs(),\n  extendShinyjs(text = jscode, functions = c('setbutton')),\n  tags$head(tags$script(HTML(jscode))),\n  fluidRow(\n    br(),\n    column(4, offset = 4, uiOutput('loginpanel')),\n    br(),\n    verbatimTextOutput('txtout')\n  )\n)\n\n\nserver &lt;- function(input, output, session) {\n  \n  ## reactiveValue to hold username and password\n  out &lt;- reactiveValues(user = NULL, pw = NULL)\n  \n  output$loginpanel &lt;- renderUI({\n    panel(heading = 'login', status = 'danger',\n          selectInput('user', label = NULL, choices = c('bob', 'ben', 'bill')),\n          textInput('txt1', label = 'textbox', value =''),  ## textbox to show that hitting Enter here has no effect\n          uiOutput('pw'),\n          actionBttn('butLogin', label = 'login', style = 'simple', color = 'success'))\n  })\n  \n  output$pw &lt;- renderUI({\n    passwordInput('pwinp', label = NULL)\n  }) \n  \n  ## attach an event to the passwordInput after a delay to ensure that the widget has been rendered\n  delay(100, \n        js$setbutton('pw', 'butLogin')\n  )\n\n  ## triggered when button pressed or Enter key when focussed on passwordInput widget\n  observeEvent(input$butLogin, {\n    out$user &lt;- input$user\n    out$pw &lt;- input$pwinp\n  })\n  \n  output$txtout &lt;- renderPrint({\n    paste(out$user, out$pw)\n  })\n}\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2019/2019-01-08-crashed_rstudio_session/index.html",
    "href": "posts/2019/2019-01-08-crashed_rstudio_session/index.html",
    "title": "Stopping a crashed RStudio Server Instance",
    "section": "",
    "text": "RStudio Server is a fantastic IDE. Amongst its numerous features is the STOP button which allows execution to be halted. This works well in most instances but there are times when its use can cause a session to hang, in particular when the interrupted code is running a C function (this is a behavior of R rather than RStudio Server). The process can still be stopped through the linux command line, however after running the following command to identify rsessions running under a specific user id (my user id is nm61135n):\nps aux |grep \"rsession.*nm61135n\"\n\nThe output returns the process id along with the rsession identifier allowing the culprit to be shut down using the kill command."
  },
  {
    "objectID": "posts/2019/2019-02-19-shiny_notifications/index.html",
    "href": "posts/2019/2019-02-19-shiny_notifications/index.html",
    "title": "Alerts in Chrome and IE",
    "section": "",
    "text": "The sendSweetAlert function from the shinyWidgets package is a great way to communicate behavior to an end-user. As of version 0.4.9 shinyWidgets now uses SweetAlert2 which is no longer compatible with Internet Explorer thus breaking historical apps which use this feature. This is due to the fact that IE does not support arrow functions.\nOne workaround is to switch from using sweetalert to using shiny’s built in showNotification function. This function works under both Chrome and IE but is not as customizable or beautiful as sweetalert. Another alternative is to identify the browser and provide a sweetalert if running Chrome or shiny notification if not. This is achieved by using javascript to assign a shiny INPUT (input$chrome) variable and using this value to determine whch type of notification to show.\n\nIncluded in UI\n\ntags$script(HTML(\n      '$(document).on(\"shiny:sessioninitialized\", function(event) {\n      var runningChrome = /Chrome/.test(navigator.userAgent);\n      Shiny.setInputValue(\"chrome\", runningChrome);\n    });'\n\n\n\nIncluded in server\n\nshow_alert &lt;- function(session = getDefaultReactiveDomain(), chrome_browser = FALSE, title = NULL, text = NULL, type = 'error', btn_labels = NULL) {\n  if (!type %in% c('info', 'success', 'warning', 'error')) type &lt;- 'info'\n  if (chrome_browser) {\n    if (!is.null(btn_labels)) {\n      sendSweetAlert(session = session, title = title, text = text, type = type, btn_labels = btn_labels, closeOnClickOutside = TRUE)\n    } else {\n      sendSweetAlert(session = session, title = title, text = text, type = type, closeOnClickOutside = TRUE)\n    }\n  } else {\n    text &lt;- str_replace(text, '\\\\n', '&lt;br&gt;')\n    if (type == 'info') type &lt;- 'default'\n    if (type == 'success') type &lt;- 'message'\n    showNotification(session = session, ui = title, action = HTML(text), type = type)\n  }\n}\n\nThe show_alert function takes a session variable, chrome_browser logical and some additional pararmeters to build a notification."
  },
  {
    "objectID": "posts/2019/2019-06-15-app_setup/index.html",
    "href": "posts/2019/2019-06-15-app_setup/index.html",
    "title": "Setting up Shiny Apps - An Opinionated View",
    "section": "",
    "text": "I work with a single server and hence cannot set up a dev, test, prod environment. We also cannot use CI/CD and so I’ve developed a particular way of working under these constraints.\nAll code is stored under a codes folder, residing under the home folder. The folder structure of the app is shown below and subfolders are explained below the image.\n\n\n\nWorking folder contents\n\n\nworking directory contains all the current, development versions of app related files (eg app.R).\nmodules contains all the shiny modules for the application. All work is partitioned into shiny modules for reusability and debugging. I find that, when working with a tabbed application, placing the ui and server logic for each tab in a module makes for easy development (tabs can be easily added, removed or changed).\nrelease is a subfolder containing the latest stable release (see below).\narchive is a subfolder containing the historical release versions (see below).\nreports contains any rmarkdown reports.\nservice is a folder containing an app which displays a service message. This is used in cases when the app is not functioning or an upgrade is in progress (see below).\n\nActive Development\nAll work is performed in the active folder, using git to track changes. Once a version has been completed and tested it is copied to the release folder replacing the current contents. An additional copy is placed in a version subfolder under archive.\n\n\n\nRelease folder contents\n\n\n\n\n\nArchive folder - each subfolder contains an all app-related files\n\n\n\n\n\nExample archive folder contents\n\n\nIn this case, the active folder contains a dev version, release contains the current prod version and archive contains all historical prod versions.\n\n\nLinking\nI run a shiny server pro instance with other users and store apps in a ~/ShinyApps subfolder under home. Each app has its own subfolder and, rather than copy a working version of the app into the subfolder I use a symbolic link to point to the app instance under my codes folder. The prod version points to the release folder, containing the latest release of the app and the dev version points to the app’s active folder. This allows code development and testing on the dev version as other users access the prod version.\n\n\nUpdates and Downtime\nWhen an update needs to be made, or if there’s an issue with the app and a hotfix needs to be applied it can be useful to have a service page informing users of the app’s status. I use a service subfolder containing a shiny app that generates a static webpage to let users know of potential issues. In addition to informing, it can also point to another subfolder under ~/ShinyApps containing a symbolic link to an archived version. This allows users to continue to use the previous version of the app as changes are made. In order to use a service page, the link in the ShinyApps prod subfolder is simply changed from pointing to the release folder to point to the service folder (both contain an app.R file). An example of a service app is shown below.\n\n## \n## Users directed here when PDS_Request or a database are under service\n##\n\nlibrary(shiny)\nlibrary(shinyWidgets)\n\nserver &lt;- function(input, output, session) {\n  \n}\n\nui &lt;- fluidPage(\n  navbarPage('PDS',\n             tabPanel('Under Service',\n                      br(),\n                      fluidRow(\n                        column(6, offset = 3,\n                               panel(status = 'danger', heading = 'UPGRADE',\n                                     h3('PDS_Request application is being upgraded (4/15/2019)', style = 'text-align: center;'),\n                                     h3('Upgrade Should be completed by 14:45 pm', style = 'text-align: center;'),\n                                     br(),\n                                     h4('To continue to use through upgrade please connect through:', style = 'text-align: center;'),\n                                     div(h3(tags$a(href = '&lt;link to previous version&gt;', 'this link'), style = 'text-align: center;'))\n                               )\n                        )\n                      )\n             )\n  )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2019/2019-09-21-star_checkbutton/index.html",
    "href": "posts/2019/2019-09-21-star_checkbutton/index.html",
    "title": "Star Checkbutton",
    "section": "",
    "text": "Here’s a short shiny app along with some css that allows a font-awesome icon to behave as a checkbox. The font-weight setting in the css file determines if the icon should be solid (font-weight = 900 for TRUE) or regular (font-weight = 400 for FALSE).\n\n\ncheckbox.css\n.fancy-checkbox input[type=\"checkbox\"] {\n    display: none;\n}\n \n.fancy-checkbox span:before {\n    content: \"\\f005\"; \n    font-family: \"Font Awesome 5 Free\";\n    font-size: 1.5em;\n    font-style: normal;\n    font-weight: 400;\n    text-decoration: inherit;\n}\n \n.fancy-checkbox input[type=\"checkbox\"]:checked ~ span:before {\n    font-weight: 900;\n}\n\n\napp.R\n\nlibrary(shiny)\n\ncheckboxbutton &lt;- function(inputId, value = FALSE, color = \"#000000\") {\n  \n  if (value) {\n    checked_str &lt;- 'checked=\"checked\"'\n  } else {\n    checked_str &lt;- NULL\n  }\n  inputTag &lt;- HTML(paste0('&lt;input id=\"', inputId, '\" type = \"checkbox\" ', checked_str, '\" /&gt;'))\n  tags$div(class=\"checkbox\",\n           tags$label(NULL, class=\"fancy-checkbox\", style = paste0(\"color: \", color),\n                      inputTag,\n                      tags$span()\n                      )\n           )\n}\n\nserver &lt;- function(input, output, session) {\n  \n  output$txt1 &lt;- renderPrint(\n    input$chk1\n  )\n  \n}\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.3.1/css/all.min.css\"),\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"checkbox.css\")\n  ),\n  br(),\n  fluidRow(\n    column(1, checkboxbutton('chk1', color = \"darkred\")),\n    column(2, verbatimTextOutput('txt1'))\n  )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2019/2019-10-16-towards_lot_iot_01/index.html",
    "href": "posts/2019/2019-10-16-towards_lot_iot_01/index.html",
    "title": "Towards Lab IoT Part One",
    "section": "",
    "text": "Chemistry scale-up labs tend to have multiple pieces of equipment connected to a single reactor. These items can work indepentently, co-dependently or fully-dependently with respect to each other. Automated reactors have been in existence for a number of years. These systems can generally collect and store data for a limited number of interfaces and typically work through wired connections. Here I’m documenting the first step towards a fully-functioning internet-of-things (IoT) lab so that multiple reactors can run processes that may be dependent on one another.\nThe final system should allow for the following:\n\nunidirectional and bidirectional communication\nsoftware-managed PID control so that one input can be controlled by another output\nalarms and failsafes - raise an alarm when out of spec and provide the ability to return to a setpoint\ncontinual monitor of connection and checking for disconnect (drop leads to alarm and return to failsage)\ndatabase to store measurements\nvisualization to monitor data\n\nI settled on a few hardware and software solutions to put this into effect. Much of the MQTT and database development was inspired by several thingsmatic blog entries\n\nHardware Solutions\nEach instrument can be controlled by a small controller. The controller should be able to interface with the instrument and publish and receive data. It should run background code that allows it to react to received data. It should also communicate wirelessly via wifi and allow ssh communication. Obvious choice is the Raspberry Pi ZeroW but we could also consider the Adafruit Feather HUZZAH ESP8266 (a little more challenging to add ssh).\n\n\nSoftware Solutions\nI chose to implement MQTT as a protocol. It’s a lightweight messaging protocol that runs over TCP/IP. MQTT works by having clients publish messages through topics to a broker, which manages all the traffic. Clients can also subscribe to any topics, receiving messages from the broker as they arrive. This routes all messages through a central location as well as allowing clients to communicate with each other (via the broker). For IoT data received from multiple sources with time being a key piece of metadata a time series database (in this case InfluxDB) is a suitable choice for data storage. The data can then be displayed in real-time using grafana.\n\n\nTest Sandbox\nI used virtualbox to test the concept. Ultimately I created three ubuntu instances to mimic a server and two remote linux controllers.\n\n\nInstalling software\nInfluxDB and grafana were installed to the server instance and MQTT was installed on the server as well as the two other virtual machines.\n\nInstalling InfluxDB\nAdd the InfluxData repository\nwget -qO- https://repos.influxdata.com/influxdb.key | sudo apt-key add -\nsource /etc/lsb-release\necho \"deb https://repos.influxdata.com/${DISTRIB_ID,,} ${DISTRIB_CODENAME} stable\" | sudo tee /etc/apt/sources.list.d/influxdb.list\nInstall and start the InfluxDB service\nsudo apt-get update && sudo apt-get install influxdb\nsudo service influxdb start\nConfiguration file is located under /etc/influxdb/influxdb.conf\nMost settings are commented out and take the default. Apply the following changes for a simple system:\n# remove data-usage reporting\nreporting-disabled = true\n\n[http]\n  # Determines whether HTTP endpoint is enabled.\n  enabled = true\n\n  # The bind address used by the HTTP service.\n  bind-address = \":8086\"\n\n  # Determines whether user authentication is enabled over HTTP/HTTPS.\n  auth-enabled = false\nLaunch / relaunch with config file\ninfluxd -config /etc/influxdb/influxdb.conf\nsudo service influxd restart -config /etc/influxdb/influxdb.conf\n\n\nTesting InfluxDB\n$ influx  -precision rfc3339  // starts the InfluxDB shell and shows time in rfc3339 format\nConnected to http://localhost:8086 version 1.2.0\nInfluxDB shell version: 1.2.0\n&gt; create database demo        // Creates a new database\n&gt; use demo\nUsing database demo\n&gt; insert mysensor1 value=0.51 // Insert new datapoints\n&gt; insert mysensor1 value=0.53 // for the measurement\n&gt; insert mysensor1 value=0.45 // \"mysensor1\"\n&gt; select * from mysensor1     // Get the whole time series\nname: mysensor1                \ntime                           value\n----                           -----\n2017-02-26T13:33:49.00279827Z  0.51\n2017-02-26T13:33:53.045762633Z 0.53\n2017-02-26T13:33:57.015427575Z 0.45\n\n\nInstalling grafana\nAdd repository\nsudo add-apt-repository \"deb https://packages.grafana.com/oss/deb stable main\"\nwget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add -\nInstall grafana\nsudo apt-get update\nsudo apt-get install grafana\nStart service\nsudo service grafana-server start\nTo start at bootup:\nsudo update-rc.d grafana-server defaults\nThe configuration file is found at /etc/grafana/grafana.ini and we’ll need to enable http protocol before use:\n[server]\n# Protocol (http, https, socket)\nprotocol = http\n\n# The ip address to bind to, empty will bind to all interfaces\n;http_addr =\n\n# The http port  to use\nhttp_port = 3000\nService can be relaunched with\nsudo service grafana-server restart\n\n\nTesting grafana\nConnect database Point browser to http://localhost:3000/ A getting-started guide can be found at https://grafana.com/docs/guides/getting_started/\nlog in (default = admin/admin) and click on “add data source” select InfluxDB as the source and then set the following parameters:\nName: InfluxDB\nHTTP URL: http://10.0.2.15:8086  (obtained from ifconfig command)\nDatabase name: demo\nCreate dashboard Dashboards can be built using “create dashboard”. Add a query that reads\nQuery: sensordata\nFROM default mysensor1 WHERE\nSELECT field(value) mean()\nThe grafana time plot should show data from the Influx database, for example:\n\n\n\nInstalling MQTT\nMQTT (MQ Telemetry Protocol) is a lightweight protocol for communication in IoT devices. In order to utilize it we must install Mosquitto, a message broker that implements the MQTT protocol. Mosquitto is lightweight and is suitable for use on all devices from low power single board computers to full servers.\nMosquitto is available in the Ubuntu repositories:\nsudo apt-get install mosquitto\nsudo apt-get install mosquitto-clients  # Mosquitto cmd line clients (use via bash)\nTesting Mosquitto is running\nservice mosquitto status\n\n\nRunning a test communication between two servers (command line)\nIn order to ensure that each VM has a separate IP address do the following:\n\nVirtualBox control Panel: File -&gt; Preferences -&gt; Network\nselect NAT networks tab and create a new network called “NatNetwork”\nin each VM: Settings -&gt; Network -&gt; Attached to: change to “Nat Network” and select “NatNetwork” from the Name dropdown\nRestart all VMs\n\nThe following lines will create a subscriber on machine 1 which will listen for messages from machine 2 which have a topic starting with message followed by any other sub-topic. More details on how to use the protocol can be found at https://mosquitto.org/\nmachine 1 (ip address = 10.0.2.15)\nmosquitto_sub -h 10.0.2.15 -t 'message/+' &\nlistens for message in background\nmachine 2 (ip address = 10.0.2.4)\nmosquitto_pub -h 10.0.2.15 -t 'message/my_comp' -m 'Hi there'\nPublish message\nIf all works well machine 1 should display ‘Hi there’ each time the mosquitto_pub command is run."
  },
  {
    "objectID": "posts/2019/2019-12-26-check_cas/index.html",
    "href": "posts/2019/2019-12-26-check_cas/index.html",
    "title": "Checking internal consistency of CAS numbers",
    "section": "",
    "text": "CAS numbers consist of three numbers separated by dashes. The first comprises of two to seven digits, the second is two digits and the third is one digit. The last number is, in fact, a check digit for the rest of the code. It’s simple to check if a CAS number contains an error by calculating a checksum as follows:\n\nRemove the last digit and all dashes\nReverse the rest of the digits\nMultiply the first digit by one, the second by two, and so on\nSum the multiplied values\nTake the modulo of ten of this sum\nThis should equal the check digit\n\nFor example, the CAS number for ethanol is 64-17-5.\nChecking: (7 x 1) + (1 x 2) + (4 x 3) + (6 x 4) = 45. 45 mod 10 = 5 (which is the check digit).\nAs a function in R this is:\n\ncas_check &lt;- function(cas) {\n  cas_split &lt;- strsplit(cas, '-')[[1]]\n  cas_validation &lt;- as.numeric(cas_split[3])\n  cas_to_check &lt;- as.numeric(rev(strsplit(paste0(cas_split[1], cas_split[2]), '')[[1]]))\n  cas_sum &lt;- sum(cas_to_check * seq(length(cas_to_check)))\n  return(cas_sum %% 10 == cas_validation)\n}\n\n\ncas_check(\"64-17-5\")\n\n[1] TRUE"
  },
  {
    "objectID": "posts/2021/2021-05-10-email_R/index.html",
    "href": "posts/2021/2021-05-10-email_R/index.html",
    "title": "Emailing under Windows using R",
    "section": "",
    "text": "Programatically sending an email under Linux is relatively simple. There are several command line clients such as sendmail and mail which are very easy to use. There are also several R packages to help send emails such as {mailr} and {blastula}.\nGenerally you need access to an SMTP to send messages programatically and this may not be possible in a work setting.\nHere’s a simple R function to send an email under Windows. It uses vbs scripting to send an email via the Outlook client itself, without needing server parameters.\n\n#' Send an email with attachments\n#'\n#' Sends an email to a recipient using vbs scripting.\n#' `body` contains the body of the email and `files` contains a list of files\n#' to attach.\n#'\n#' @param to Recipient email address\n#' @param subject Subject line\n#' @param body Body text\n#' @param files List of files to attach\n#'\n#' @export\nlc_send_email &lt;- function(to = NULL, subject = \"\", body = \"\", files = list()) {\n\n  if (is.null(to)) return(NULL)\n\n  if (length(files) &gt; 0) {\n    v.files &lt;- unlist(sapply(files, function(f) {\n      paste0('myAttachments.Add \"', normalizePath(f), '\", olByValue')\n    }))\n  } else {\n    v.files &lt;- ''\n  }\n\n  ## build a vbs script to send an email to user\n  v.outlook_commands &lt;- c(\n    'Dim olApp',\n    'Dim objMailItem',\n    'Dim myAttachments',\n    'Set olApp = CreateObject(\"Outlook.Application\")',\n    'Set objMailItem = olApp.CreateItem(0)',\n    'Set myAttachments = objMailItem.Attachments',\n    paste0('objMailItem.Subject = \"', subject, '\"'),\n    paste0('objMailItem.To = \"', to, '\"'),\n    paste0('objMailItem.Body = \"', body, '\"'),\n    v.files,\n    'objMailItem.Send',\n    'Set olApp = Nothing',\n    'Set objMailItem = Nothing'\n  )\n\n  ## write script to temporary location\n  script_file &lt;- tempfile(fileext = '.vbs')\n  sink(script_file, append = FALSE)\n  cat(v.outlook_commands, sep='\\n')\n  sink()\n\n  ## execute script\n  system_script &lt;- paste0('WScript ', normalizePath(script_file))\n  system(system_script)\n\n}"
  },
  {
    "objectID": "posts/2021/2021-06-02-reactivity/index.html",
    "href": "posts/2021/2021-06-02-reactivity/index.html",
    "title": "Shiny Reactivity",
    "section": "",
    "text": "Examples of passing a list of reactives, reactiveValues list and reactiveValues to a shiny module. This helps explain reactivity when passing values to a shiny module. In each case we pass a value A which triggers mod A and value B which triggers mod B. The code below and output demonstrates which outputs in the shiny module are updated upon changing a value in the main app."
  },
  {
    "objectID": "posts/2021/2021-06-02-reactivity/index.html#example-1---list-of-reactives",
    "href": "posts/2021/2021-06-02-reactivity/index.html#example-1---list-of-reactives",
    "title": "Shiny Reactivity",
    "section": "Example 1 - List of Reactives",
    "text": "Example 1 - List of Reactives\nPass two reactives (react_A and react_B) to a shiny module. react_A is attached to a reactiveVal and initially set to A. react_B is a reactive set to B. react_A is then changed to C by changing the reactiveVal.\nIn this setup react_A and react_B are sent to the shiny module when it is called. react_A is updated which triggers an update of the module.\nOutput to the console is:\n[1] \"response from module A: A\"\n[1] \"response from module B: B\"\n[1] \"response from module A: C\"\n\n## checking reactivity - reactive list vs list of reactives\n## list of reactives\nlibrary(shiny)\n\n## module UI\nmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    uiOutput(ns(\"modA\")),\n    uiOutput(ns(\"modB\"))\n  )\n}\n\n## module server\nmod &lt;- function(id, inputvar) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      output$modA &lt;- renderUI({\n        req(inputvar$A())\n        print(paste0(\"response from module A: \", inputvar$A()))\n        h3(paste0(\"response from module A: \", inputvar$A()))\n      })\n      \n      output$modB &lt;- renderUI({\n        req(inputvar$B())\n        print(paste0(\"response from module B: \", inputvar$B()))\n        h3(paste0(\"response from module B: \", inputvar$B()))\n      })\n    }\n  )\n}\n\nui &lt;- fluidPage(\n\n  mod_UI(\"shinymod\")\n\n)\n\nserver &lt;- function(input, output, session) {\n\n  rv &lt;- reactiveVal(\"A\")\n\n  react_A &lt;- reactive({\n    rv()\n  })\n\n  react_B &lt;- reactive({\n    \"B\"\n  })\n\n  mod(\"shinymod\", inputvar = list(A = reactive(react_A()), B = reactive(react_B())))\n\n  ## Update rv$A triggers refresh of modA in shiny module but not modB\n  observe({\n    rv(\"C\")\n  })\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-02-reactivity/index.html#example-2---reactivevalues-list",
    "href": "posts/2021/2021-06-02-reactivity/index.html#example-2---reactivevalues-list",
    "title": "Shiny Reactivity",
    "section": "Example 2 - ReactiveValues List",
    "text": "Example 2 - ReactiveValues List\nPass a reactiveValue, rv$AB containing a list of two members (A = A and B = B) to a shiny module. One member of rv$AB is then changed so that rv$AB contains A = C and B = B.\nIn this setup rv$AB is sent to the shiny module when it is called. rv$AB is updated which triggers an update of the module.\nOutput to the console is:\n[1] \"response from module A: A\"\n[1] \"response from module B: B\"\n[1] \"response from module A: C\"\n[1] \"response from module B: B\"\nHere it is clear that updating the reactiveValue triggers two updates - one for the first list member (which changed) and one for the second (which did not). This is a highly inefficient way of passing data to a module.\n\n## checking reactivity - reactive list vs list of reactives\n## reactiveValue\nlibrary(shiny)\n\n## module UI\nmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    uiOutput(ns(\"modA\")),\n    uiOutput(ns(\"modB\"))\n  )\n}\n\n## module server\nmod &lt;- function(id, inputvar) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      \n      output$modA &lt;- renderUI({\n        req(inputvar()$A)\n        print(paste0(\"response from module A: \", inputvar()$A))\n        h3(paste0(\"response from module A: \", inputvar()$A))\n      })\n      \n      output$modB &lt;- renderUI({\n        req(inputvar()$B)\n        print(paste0(\"response from module B: \", inputvar()$B))\n        h3(paste0(\"response from module B: \", inputvar()$B))\n      })\n  \n    }\n  )\n}\n\n\nui &lt;- fluidPage(\n\n  mod_UI(\"shinymod\")\n\n)\n\nserver &lt;- function(input, output, session) {\n\n  rv &lt;- reactiveValues(\n    AB = list()\n  )\n\n  observe({\n    rv$AB &lt;- list(A = \"A\", B = \"B\")\n  })\n\n  mod(\"shinymod\", inputvar = reactive(rv$AB))\n\n  ## Update rv$AB triggers refresh of modA and modB in shiny module\n  observe({\n    rv$AB &lt;- list(A = \"C\", B = \"B\")\n  })\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-06-02-reactivity/index.html#example-3---reactivevalues",
    "href": "posts/2021/2021-06-02-reactivity/index.html#example-3---reactivevalues",
    "title": "Shiny Reactivity",
    "section": "Example 3 - ReactiveValues",
    "text": "Example 3 - ReactiveValues\nPass a set of reactiveValues, rv containing two elements (A = A and B = B) to a shiny module. Change one element (A = C). In this setup rv is sent to the shiny module when it is called. rv is updated which triggers an update of the module.\nOutput to the console is:\n[1] \"response from module A: A\"\n[1] \"response from module B: B\"\n[1] \"response from module A: C\"\n\n## checking reactivity - reactive list vs list of reactives\n## reactiveValues\nlibrary(shiny)\n\nmod_UI &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    uiOutput(ns(\"modA\")),\n    uiOutput(ns(\"modB\"))\n  )\n}\n\n## module server\nmod &lt;- function(id, inputvar) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      \n      output$modA &lt;- renderUI({\n        req(inputvar()$A)\n        print(paste0(\"response from module A: \", inputvar()$A))\n        h3(paste0(\"response from module A: \", inputvar()$A))\n      })\n      \n      output$modB &lt;- renderUI({\n        req(inputvar()$B)\n        print(paste0(\"response from module B: \", inputvar()$B))\n        h3(paste0(\"response from module B: \", inputvar()$B))\n      })\n  \n    }\n  )\n}\n\nui &lt;- fluidPage(\n\n  mod_UI(\"shinymod\")\n\n)\n\nserver &lt;- function(input, output, session) {\n\n  rv &lt;- reactiveValues(\n    A = \"A\",\n    B = \"B\"\n  )\n\n  mod(\"shinymod\", inputvar = reactive(rv))\n\n  ## Update rv$A triggers refresh of modA in shiny module\n  observe({\n    rv$A &lt;- \"C\"\n  })\n\n  ## Update rv$B does not trigger refresh of modB in shiny module (no change to rv$B)\n  observe({\n    rv$B &lt;- \"B\"\n  })\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-07-16-magrittr/index.html",
    "href": "posts/2021/2021-07-16-magrittr/index.html",
    "title": "Implementing magrittr",
    "section": "",
    "text": "magrittr is the pipe, commonly used in tidyverse packages, that enables simple sequencing of operators. The simple forward pipe replaces f(x, y) with x %&gt;% f(y). Code becomes much more readable when chaining multiple pipes together.\nIt’s very simple to use this in any package. the usethis package provides a command usethis::use_pipe() which takes care of everything for you. Once run, the magrittr pipe operator will be exported and available for users.\n\nadd_number &lt;- function(x, y) {\n  return(x + y)\n}\n\n3 %&gt;% \n  add_number(5) %&gt;% \n  add_number(2)\n\n[1] 10"
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html",
    "title": "Multiwindow App",
    "section": "",
    "text": "This is an initial concept of a framework for multiwindow shiny apps. Shiny is a great R package for building an interactive, web-based, graphical UI using R. It does, however, suffer from some limitations. One of these is the fact that a Shiny app runs in a single browser window. To make a more complex interface we can extend the browser window to full screen and add tab panels or scrollbars. Another concept is to break parts of the app into separate apps, each with their own window, separate but linked through a single data source (a single source of truth).\nIn this prototype, one app pushes data to a json file and two others read the data from this file using a reactiveFileReader. The reactiveFileReader ensures that any changes made to the data updates the apps that are dependent upon it. One additional shiny app (launcher) is responsible for opening and closing all other apps."
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html#launcherapp.r",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html#launcherapp.r",
    "title": "Multiwindow App",
    "section": "launcher/app.R",
    "text": "launcher/app.R\n\n## App lauuncher\n## This app manages all others\n\n\nlibrary(shiny)\nlibrary(shinyWidgets)\n\nserver &lt;- function(input, output, session) {\n  \n  ## create a temp folder with access permissions\n  jsonfile &lt;- tempfile(fileext = \".json\")\n  \n  ## replace this with the shiny server URL (subfolder = mutiwindow)\n  url_base &lt;- ###\n  \n  ## define app windows\n  app_windows &lt;- data.frame(\n    name = c(\"app_options\", \"app_graphics\", \"app_details\"),\n    app = c(\"app_options\", \"app_graphics\", \"app_details\"),\n    height = c(0.25, 0.4, 0.25),\n    width = c(0.095, 0.2, 0.095),\n    left = c(0.02, 0.02, 0.125),\n    top = c(0.02, 0.33, 0.02),\n    closable = c(TRUE, TRUE, TRUE),\n    stringsAsFactors = FALSE\n  )\n  app_windows$url &lt;- paste0(url_base, app_windows$app, \"/?file=\", jsonfile)\n  \n  \n  ## launch all apps\n  for (i in 1:nrow(app_windows)) {\n    session$sendCustomMessage(\"launch_app\", app_windows[i, ])\n  }\n  \n  observe({\n    req(!is.null(input$txt_com_file))\n    session$sendCustomMessage(\"disable\", \"txt_com_file\")\n  })\n  \n  output$ui_communications &lt;- renderUI({\n    column(10, offset = 1, textInput(\"txt_com_file\", label = \"Communications File\", width = \"100%\", value = jsonfile))\n  })\n  \n  \n  # app_options ------------------------------------------------------------------\n  \n  ## options UI\n  output$ui_app_options &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_options\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: setting options\")),\n      column(2, offset = 1, actionBttn(\"but_close_all\", label = \"Close All\", style = \"simple\", color = \"danger\", size = \"sm\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_options))\n    if (!app_windows[1, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_options\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_options, {\n    if (input$swt_app_options == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[1, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[1, ])\n    }\n  })\n\n\n  # app_graphics ------------------------------------------------------------------\n  \n  ## graphics UI\n  output$ui_app_graphics &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_graphics\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: plotting graphics\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_graphics))\n    if (!app_windows[2, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_graphics\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_graphics, {\n    if (input$swt_app_graphics == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[2, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[2, ])\n    }\n  })\n\n\n  # app_details ------------------------------------------------------------------\n  \n  ## details UI\n  output$ui_app_details &lt;- renderUI({\n    fluidRow(\n      column(1, offset = 1, style = \"margin-top: 8px;\", prettySwitch(\"swt_app_details\", status = \"success\", label = NULL, inline = TRUE, bigger = TRUE, value = TRUE)),\n      column(5, h4(\"shiny app: setting details\"))\n    )\n  })\n  \n  ## switch enable\n  observe({\n    req(!is.null(input$swt_app_details))\n    if (!app_windows[3, ]$closable) {\n      session$sendCustomMessage(\"disable\", \"swt_app_details\")\n    }\n  })\n  \n  ## close app_options\n  observeEvent(input$swt_app_details, {\n    if (input$swt_app_details == TRUE) {\n      session$sendCustomMessage(\"launch_app\", app_windows[3, ])\n    } else {\n      session$sendCustomMessage(\"close_app\", app_windows[3, ])\n    }\n  })\n  \n  ## close all apps\n  observeEvent(input$but_close_all, {\n    for (i in 1:nrow(app_windows)) {\n      session$sendCustomMessage(\"close_app\", app_windows[i, ])\n    }\n  })\n\n}\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(type = \"text/javascript\", src = \"script.js\")\n  ),\n  br(),\n  br(),\n  fluidRow(column(10, offset = 1, \n                  panel(status = \"primary\", heading = \"App Launcher\",\n                        panel(status = \"danger\", heading = \"Communications\",\n                              uiOutput(\"ui_communications\")\n                        ),\n                        br(),\n                        panel(status = \"danger\", heading = \"App Windows\",\n                              fluidRow(uiOutput(\"ui_app_options\")),\n                              fluidRow(uiOutput(\"ui_app_graphics\")),\n                              fluidRow(uiOutput(\"ui_app_details\"))\n                        )\n                  )\n  ))\n)\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html#launcherwwwscript.js",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html#launcherwwwscript.js",
    "title": "Multiwindow App",
    "section": "launcher/www/script.js",
    "text": "launcher/www/script.js\n\nvar shiny_app_options = \"\";\nvar shiny_app_graphics = \"\";\nvar shiny_app_details = \"\";\n\n// launch a shiny app in a minimal window\n// window opens with a specified size at a specified screen location (based on fraction of total screen width and height)\nShiny.addCustomMessageHandler('launch_app', function(x) {\n  scr_height = window.screen.height;\n  scr_width = window.screen.width;\n  window_height = scr_height * x.height;\n  window_width = scr_width * x.width;\n  window_left = scr_width * x.left;\n  window_top = scr_height * x.top;\n  window_options = \"height=\" + window_height + \", width=\" + window_width + \", left=\" + window_left + \", top=\" + window_top;\n  \n  if (x.name == \"app_options\") {\n    shiny_app_options = window.open(x.url, x.name, window_options);\n  } else if (x.name == \"app_graphics\") {\n    shiny_app_graphics = window.open(x.url, x.name, window_options);\n  } else if (x.name == \"app_details\") {\n    shiny_app_details = window.open(x.url, x.name, window_options);\n  }\n});\n\n// close a shiny app\nShiny.addCustomMessageHandler('close_app', function(x) {\n  console.log(x.name);\n  // can't pass window name as variable to close so have to hardcode :(\n  if (x.name == \"app_options\") {\n    console.log('close app_options');\n    shiny_app_options.close();\n  } else if (x.name == \"app_graphics\") {\n    console.log('close app_graphics');\n    shiny_app_graphics.close();\n  } else if (x.name == \"app_details\") {\n    console.log('close app_details');\n    shiny_app_details.close();\n  }\n});\n\n// disable a shiny input\nShiny.addCustomMessageHandler('disable', function(id) {\n  var input_type = $(\"#\" + id).prop(\"type\");\n  if (input_type.startsWith(\"select\")) {\n    $(\"#\" + id)[0].selectize.disable();\n  } else {\n    $(\"#\" + id).prop(\"disabled\", true);\n  }\n});"
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html#app_optionsapp.r",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html#app_optionsapp.r",
    "title": "Multiwindow App",
    "section": "app_options/app.R",
    "text": "app_options/app.R\n\n## app_options\n## A simple app that offers a series of options\n\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  filename &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$file)) {\n      query$file\n    } else {\n      \"\"\n    }\n  })\n  \n  output$ui_axes &lt;- renderUI({\n    req(input$sel_data)\n    ## select x and y parameters from numeric columns\n    df &lt;- get(input$sel_data)\n    columns &lt;- names(df)[sapply(df, class) == \"numeric\"]\n    tagList(\n      selectizeInput(\"sel_x\", \"X parameter\", choices = columns),\n      selectizeInput(\"sel_y\", \"Y parameter\", choices = columns)\n    )\n  })\n  \n  ## write file when updating parameter\n  observeEvent(input$sel_data, {\n    write_file()\n  })\n  \n  observeEvent(input$sel_x, {\n    write_file()\n  })\n  \n  observeEvent(input$sel_y, {\n    write_file()\n  })\n  \n  ## write a file\n  write_file &lt;- function() {\n    if (filename() != \"\") {\n      output &lt;- list(\n        data = input$sel_data,\n        x = input$sel_x,\n        y = input$sel_y\n      )\n      json_out &lt;- toJSON(output, auto_unbox = TRUE, null = \"null\")\n      con &lt;- file(filename(), open = \"wt\")\n      writeLines(json_out, con)\n      close(con)\n    }\n  }\n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Options\", status = \"primary\",\n        selectizeInput(\"sel_data\", \"dataset\", choices = c(\"iris\", \"mtcars\")),\n        uiOutput(\"ui_axes\")\n        )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html#app_graphicsapp.r",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html#app_graphicsapp.r",
    "title": "Multiwindow App",
    "section": "app_graphics/app.R",
    "text": "app_graphics/app.R\n\n## app_graphics\n## A simple app that draws a ggplot\n\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(ggplot2)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  filename &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$file)) {\n      query$file\n    } else {\n      \"\"\n    }\n  })\n  \n  ## retrieve data from file\n  json_data &lt;- reactiveFileReader(2000, session, filePath = filename, readFunc = function(filePath) {\n    tryCatch({\n      con &lt;- file(filePath)\n      file_contents &lt;- readLines(con)\n      close(con)\n      file_contents\n    },\n    error = function(e) NA\n    )\n  })\n  \n  output$plt &lt;- renderPlot({\n    req(json_data())\n    \n    ## check all plotting parameters are present\n    params &lt;- c(\"data\", \"x\", \"y\")\n    data &lt;- fromJSON(json_data())\n    if (all(sapply(params, function(x) !is.null(data[[x]])))) {\n      ggplot(get(data[[\"data\"]]), aes(x = .data[[data[[\"x\"]]]], y = .data[[data[[\"y\"]]]])) +\n        geom_point() +\n        labs(title = paste0(\"Plot data = \", data[[\"data\"]]),\n             x = data[[\"x\"]], \n             y = data[[\"y\"]])\n    }\n\n  })\n  \n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Graphics\", status = \"primary\",\n        plotOutput(\"plt\")\n  )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-08-30-multiwindow_app/index.html#app_detailsapp.r",
    "href": "posts/2021/2021-08-30-multiwindow_app/index.html#app_detailsapp.r",
    "title": "Multiwindow App",
    "section": "app_details/app.R",
    "text": "app_details/app.R\n\n## app_details\n## A simple app that lists some details\n\nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(jsonlite)\n\nserver &lt;- function(input, output, session) {\n  \n  filename &lt;- reactive({\n    query &lt;- parseQueryString(session$clientData$url_search)\n    if (!is.null(query$file)) {\n      query$file\n    } else {\n      \"\"\n    }\n  })\n  \n  ## retrieve data from file\n  json_data &lt;- reactiveFileReader(2000, session, filePath = filename, readFunc = function(filePath) {\n    tryCatch({\n      con &lt;- file(filePath)\n      file_contents &lt;- readLines(con)\n      close(con)\n      file_contents\n    },\n    error = function(e) NA\n    )\n  })\n  \n  output$txt_details &lt;- renderPrint({\n    prettify(json_data())\n  })\n  \n}\n\nui &lt;- fluidPage(\n  br(),\n  br(),\n  panel(heading = \"Output\", status = \"primary\",\n        verbatimTextOutput(\"txt_details\")\n  )\n)\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2021/2021-10-10-R6_shiny_mod/index.html",
    "href": "posts/2021/2021-10-10-R6_shiny_mod/index.html",
    "title": "Connecting shiny modules through R6",
    "section": "",
    "text": "Here’s a simple example of working with a reactive R6 in a shiny app. It is inspired by a post to RStudio Community (https://community.rstudio.com/t/good-way-to-create-a-reactive-aware-r6-class/84890) and uses the code provided by Winston Chang to create an R6 class that is reactive. The example code is located in https://github.com/harveyl888/reactive_R6.\nI can see two advantages and one disadvantage to using a reactive R6 class in a shiny app.\n\n\n\nA single class instance can be shared between all shiny modules. This is particularly useful when working with shiny modules that are interdependent - ie content in module A is dependent on modules B and C, content in module B is dependent on modules A and C and content in module C is dependent on modules A and B. Using a reactive class means that we would simply send the class instance to each module. Any changes made to the class would automatically update in all shiny modules.\nThe R6 class instance itself can be saved and read back in at a later date, essentially providing a snapshot. Saving and reimporting the class instance is a great way to keep a set of complex data together.\n\n\n\n\n\nSince updating the class triggers a refresh, some reactive outputs may be updated when their content has not changed. This is due to the class itself being reactive.\n\nIn this post I’ll demonstrate a reactive R6 class called Analysis using a simple PCA and clustering example."
  },
  {
    "objectID": "posts/2021/2021-10-10-R6_shiny_mod/index.html#introduction",
    "href": "posts/2021/2021-10-10-R6_shiny_mod/index.html#introduction",
    "title": "Connecting shiny modules through R6",
    "section": "",
    "text": "Here’s a simple example of working with a reactive R6 in a shiny app. It is inspired by a post to RStudio Community (https://community.rstudio.com/t/good-way-to-create-a-reactive-aware-r6-class/84890) and uses the code provided by Winston Chang to create an R6 class that is reactive. The example code is located in https://github.com/harveyl888/reactive_R6.\nI can see two advantages and one disadvantage to using a reactive R6 class in a shiny app.\n\n\n\nA single class instance can be shared between all shiny modules. This is particularly useful when working with shiny modules that are interdependent - ie content in module A is dependent on modules B and C, content in module B is dependent on modules A and C and content in module C is dependent on modules A and B. Using a reactive class means that we would simply send the class instance to each module. Any changes made to the class would automatically update in all shiny modules.\nThe R6 class instance itself can be saved and read back in at a later date, essentially providing a snapshot. Saving and reimporting the class instance is a great way to keep a set of complex data together.\n\n\n\n\n\nSince updating the class triggers a refresh, some reactive outputs may be updated when their content has not changed. This is due to the class itself being reactive.\n\nIn this post I’ll demonstrate a reactive R6 class called Analysis using a simple PCA and clustering example."
  },
  {
    "objectID": "posts/2021/2021-10-10-R6_shiny_mod/index.html#the-reactive-class",
    "href": "posts/2021/2021-10-10-R6_shiny_mod/index.html#the-reactive-class",
    "title": "Connecting shiny modules through R6",
    "section": "The Reactive Class",
    "text": "The Reactive Class\nThe main part of the code is the reactive class. Our class is built up from the code in the RStudio Community article when the class is initialized as reactive using Analysis$new(data=mydata)$reactive() (chaining), or by running the reactive() method on an initialized class instance, a couple of things occur:\n\na reactiveVal, reactiveDep is created, linked to a counter, which increases when the private invalidate() method is called.\na reactive expression, reactiveExpr is created which updates when reactiveDep changes.\n\nThe skeleton for the reactive R6 class is shown below:\n\nAnalysis &lt;- R6Class(\"Analysis\",\n                               public = list(\n                                   initialize = function(data = NULL) {\n                                       private$reactiveDep &lt;- function(x) NULL\n                                    },\n                                    reactive = function() {\n                                        # Ensure the reactive stuff is initialized.\n                                        if (is.null(private$reactiveExpr)) {\n                                            private$reactiveDep &lt;- reactiveVal(0)\n                                            private$reactiveExpr &lt;- reactive({\n                                                private$reactiveDep()\n                                                self\n                                            })\n                                        }\n                                        private$reactiveExpr\n                                    },\n                               ),\n                               private = list(\n                                   reactiveDep = NULL,\n                                   reactiveExpr = NULL,\n                                   invalidate = function() {\n                                       private$count &lt;- private$count + 1\n                                       private$reactiveDep(private$count)\n                                       invisible()\n                                    },\n                                    count = 0\n                               )\n                    )\n\nThe invalidate method can be used to invalidate the reactive class. This is used when calling other methods that update the class contents. Invalidating the class forces an update in the shiny app of anything that is dependent on the class instance. In our example, the Analysis class contains the following reactive methods:\nfilter(), pca(), cluster() and set_clusters()\nand the following non-reactive methods:\nimport(), get_data() and print()."
  },
  {
    "objectID": "posts/2021/2021-10-10-R6_shiny_mod/index.html#use-in-shiny-app",
    "href": "posts/2021/2021-10-10-R6_shiny_mod/index.html#use-in-shiny-app",
    "title": "Connecting shiny modules through R6",
    "section": "Use in Shiny App",
    "text": "Use in Shiny App\nOne use of this class is in a complex shiny app with many shiny modules. Using a reactive class simplifies the data that needs to be passed between the modules. This is particularly true when there are multiple dependencies. In this case, we define our class and assign it to a reactiveValue which is then shared between shiny modules. When the class instance is updated it is reflected in all the shiny modules; no data need be returned from one class and passed to another. The class instance is defined in the app.R server function as follows:\n\ndata &lt;- iris\n\nrv &lt;- reactiveValues(\n    analysis = NULL\n)\n\nobserve({\n    analysis &lt;- Analysis$new(data)\n    analysis$pca()\n    analysis$cluster()\n    rv$analysis &lt;- analysis$reactive()\n})\n\nHere, a class instance is initiated using iris data, PCA and clustering methods are run and the result is stored in a reactiveValue which is then passed to each of the shiny modules.\ngraph TB\n  subgraph rv$analysis\n    app.R --&gt; mod_data.R;\n    app.R --&gt; mod_multivariate.R;\n    app.R --&gt; mod_cluster.R;\n  end\nEach shiny module sits in a different tab which look as follows:\n\n\n\nUpon changing the data (for example filtering), the reactive class is updated, triggering updates of all dependent outputs in all shiny modules:"
  },
  {
    "objectID": "posts/2021/2021-10-10-R6_shiny_mod/index.html#conclusion",
    "href": "posts/2021/2021-10-10-R6_shiny_mod/index.html#conclusion",
    "title": "Connecting shiny modules through R6",
    "section": "Conclusion",
    "text": "Conclusion\nReactive R6 classes in shiny apps provides a useful way to share complex data and parameters across multiple interdependent shiny modules. Example code can be found in https://github.com/harveyl888/reactive_R6."
  },
  {
    "objectID": "posts/2021/2021-11-30-learnr_distill/index.html",
    "href": "posts/2021/2021-11-30-learnr_distill/index.html",
    "title": "Embedding {learnr} in {distill}",
    "section": "",
    "text": "{learnr} is an R package from RStudio which uses R Markdown to create interactive tutorials. Once completed, the tutorial can be published via shiny server or RStudio Connect. As a {learnr} markdown file contains its own yaml header it cannot be directly included in a website built by distill. It can, however, be included if it is hosted (shiny server or RStudio Connect) and embedded using iframe\n\n```{r, layout=\"l-screen-inset\"}\nhtmltools::tags$iframe(src = \"&lt;RSCONNECT URL&gt;\", height = \"600px\", width = \"100%\", `data-external` = \"1\")\n```\n\nwhere  is the url of the {learnr} tutorial. The use of data-external is related to the way that pandoc processes iframe tags (see https://community.rstudio.com/t/insert-raw-html-iframe-into-rmarkdown/94334 and https://pandoc.org/MANUAL.html#option–self-contained)."
  },
  {
    "objectID": "posts/2022/2022-01-05-hot_reload/index.html",
    "href": "posts/2022/2022-01-05-hot_reload/index.html",
    "title": "Shiny hot reload",
    "section": "",
    "text": "Here’s something I’ve discovered that may save a huge amount of time in future development. I’m working on a shiny app that uses reads parameters from a json file and generates a series of plots from the data. It would be great to use a hot reload during the development phase so that edits to the json file can be visualized without restarting the app each time. This can be done by setting an option before running the app the first time with this simple line:\n\noptions(shiny.autoreload.pattern = glob2rx(\"*.json\"))\n\nNow any time a json file is changed the app will automatically reload. Magic!"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html",
    "title": "{distill} Comments With Replies",
    "section": "",
    "text": "This post expands upon the post on {distill} Comments. It includes a method to reply to comments and store comments and replies in an hierarchical manner.\nIn the previous post I covered how we could use RStudio Connect to manage commenting on a static blog. Here we extend it, adding a way to reply to comments and store comments plus replies in a hiersrchical data structure.\nThe concept is essentially the same as the earlier version: a {distill} blog is connected to a {pins} data source via plumber. Here, however, the data source is a data.tree as opposed to a data frame. data.tree is an R package that manages hierarchical data and tree structures. Page comments with replies lends itself nicely to a hierarchical data structure where each node is a comment or reply to a comment. The pinned data.tree holds the comments and replies which can be added or retrieved through the API. Comments are retrieved through javascript functions in the distill blog. The blog, pin board and plumber API all sit on the same RStudio Connect instance."
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#new-comment-form",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#new-comment-form",
    "title": "{distill} Comments With Replies",
    "section": "New Comment Form",
    "text": "New Comment Form\nNew comment form is very similar to the original version. The function comment_form_dt takes site_id and page_id arguments and returns an HTML form. site_id is a unique identifier for a website and page_id is a unique identifier for a page on that site.\nThe form captures a comment and optional user name and passes each of these, along with site_id, page_id and parent_ref to a plumber API. Each comment or reply is given a unique reference number and parent_ref is the reference number of the parent. For page comments parent_ref is simply the page_id but for replies parent_ref is the reference to a comment or a reply. The plumber API updates a pinned data.tree with the new comment. In fact, a javascript function intercepts the submit button triggering an update of the page comments after adding the new one. This allows a new comment to be added without having to refresh the page manually.\nIn addition, the comment_form_dt function adds a div with the id rtncomments which is a placeholder to display comments.\nThe comment_form_dt R function along with the javascript eventListener are shown below. In the code, /addcomment_dt refers to the plumber API endpoint for adding a new comment.\nThe javascript function formsubmit is essentially the same as the earlier function.\n\nlibrary(htmltools)\n\ncomment_form_dt &lt;- function(page_id = 0, site_id = 0) {\n  \n  comment_html &lt;- paste0('\n  &lt;div class=\"comments\"&gt;\n    &lt;div class=\"form-container\"&gt;\n      &lt;h3 class=\"comment-header\"&gt;Post a Comment&lt;/h3&gt;\n      &lt;form action=\"&lt;rsconnect URL&gt;/addcomment_dt\" id=\"my-form\"&gt;\n      \n        &lt;div class=\"form-contents\"&gt;\n          &lt;span class=\"comment-pic\"&gt;\n            &lt;i class=\"far fa-user\"&gt;&lt;/i&gt;\n          &lt;/span&gt;\n          \n          &lt;div class=\"form-details\"&gt;\n            &lt;div class=\"comment-comments\"&gt;\n              &lt;input type=\"text\" id=\"comment\" name=\"comment\" placeholder=\"Your comment\"&gt;&lt;/textarea&gt;\n            &lt;/div&gt;\n            &lt;div class=\"comment-user\"&gt;\n              &lt;span class=\"comment-short\"&gt;\n                &lt;input type=\"text\" id=\"user_name\" name=\"user_name\" placeholder=\"Your name (optional)\" /&gt;\n              &lt;/span&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n\n          &lt;input type=\"hidden\" name=\"site_id\" value=\"', site_id, '\" /&gt;\n          &lt;input type=\"hidden\" name=\"page_id\" value=\"', page_id, '\" /&gt;\n          &lt;input type=\"hidden\" name=\"parent_ref\" value=\"', page_id, '\" /&gt;\n      \n          &lt;span class=\"button-container\"&gt;\n            &lt;input type=\"submit\" value=\"Comment\"&gt;\n          &lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n      &lt;div id=\"rtncomments\"&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  ')\n  htmltools::HTML(comment_html)\n}\n\n\nwindow.addEventListener(\"load\", function() {\n  // add eventlistener to new comment submit button\n  document.getElementById(\"my-form\").addEventListener(\"submit\", formsubmit);\n});\n\n// Intercept submit button and run fetch code\nasync function formsubmit(e) {\n  \n  e.preventDefault();\n  \n  // get event-handler element\n  const form = e.currentTarget;\n  \n  // get form url\n  const url = form.action;\n  \n  // get form data as json string\n  formdata = new FormData(form);\n  const plainFormData = Object.fromEntries(formdata.entries());\n  const jsonFormData = JSON.stringify(plainFormData);\n  \n  // send request and capture output\n  out = await fetch(url, {\n    method: 'POST',\n    body: jsonFormData,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"Accept\": \"application/json\"\n    }\n  })\n  .then(response =&gt; response.json());\n  \n  // update comments\n  update_comments_dt(plainFormData.page_id, plainFormData.site_id);\n\n};"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#existing-comments",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#existing-comments",
    "title": "{distill} Comments With Replies",
    "section": "Existing Comments",
    "text": "Existing Comments\nRetrieving existing comments introduces a new function to build replies and a reply box for each comment/reply. The main function takes site_id and page_id arguments and calls a plumber API which returns comments belonging to the page in json form. A recursive function then builds comments and any replies, terminating each tree branch with a reply box.\nHere, /page_comments_dt refers to the plumber API endpoint for retrieving comments. The search parameters site_id and page_id are appended to the url so that we can limit the returning data to a specific page on a specific site. Since we are using fetch, the webpage and API must live on the same RStudio Connect instance.\n\n// build and populate comment reply box\nfunction reply_comment_box(page_id, site_id, parent_ref) {\n  var out = $('&lt;div/&gt;', {class: 'form-container'}).append([\n    $('&lt;h5/&gt;', {class: 'comment-header comment-header-margin-narrow', text: 'Post a reply'}),\n    $('&lt;form/&gt;', {action: 'https://rsconnect-prod.dit.eu.novartis.net/content/1200/addcomment_dt', method: 'POST', class: 'reply-form'}).append([\n      $('&lt;div/&gt;', {class: 'form-contents'}).append(\n        $('&lt;span/&gt;', {class: 'comment-pic'}).append($('&lt;i/&gt;', {class: 'far fa-user'})),\n        $('&lt;div/&gt;', {class: 'form-details'}).append(\n          $('&lt;div/&gt;', {class: 'comment-comments'}).append(\n            $('&lt;input/&gt;', {type: 'text', name: 'comment', placeholder: 'Your reply'})\n          ),\n          $('&lt;div/&gt;', {class: 'comment-user'}).append(\n            $('&lt;span/&gt;', {class: 'comment-short'}).append(\n              $('&lt;input/&gt;', {type: 'text', name: 'user_name', placeholder: 'Your name (optional)'})\n            )\n          )\n        ),\n        $('&lt;input/&gt;', {type: 'hidden', name: 'site_id', value: site_id}),\n        $('&lt;input/&gt;', {type: 'hidden', name: 'page_id', value: page_id}),\n        $('&lt;input/&gt;', {type: 'hidden', name: 'parent_ref', value: parent_ref}),\n        $('&lt;span/&gt;', {class: 'button-container'}).append(\n          $('&lt;input/&gt;', {type: 'submit', value: 'submit'})\n        )\n      )\n\n    ])\n  ])\n  return(out)\n};\n\n\n// update comments on the page\nfunction update_comments_dt(page_id, site_id) {\n\n  const url = \"&lt;rsconnect URL&gt;/page_comments_dt?\"\n\n  fetch(url + new URLSearchParams({\n    site: site_id, \n    page: page_id,\n  }))\n  .then(response =&gt; response.json())  \n  .then(data =&gt; {\n    \n    // recursive function to print comments\n    function comment_recurse(d) {\n      if (d.hasOwnProperty('children')) {\n        const ul_list_comments = $('&lt;ul/&gt;', {class: 'comment-list'});\n\n        // loop over children (replies) and populate\n        $.each(d.children, function(i, x) {\n          user_name = x.user_name == \"null\" ? \"anonymous user\" : x.user_name;\n          style_txt = 'margin-left: 20px;'\n          ul_list_comments.append(\n            $('&lt;li/&gt;', {class: 'comment-item', style: style_txt}).append([\n              $('&lt;div/&gt;', {class: 'comment-top'}).append([\n                $('&lt;h3/&gt;', {class: 'comment-name', text: user_name}),\n                $('&lt;span/&gt;', {class: 'date-holder'}).append([\n                  $('&lt;i/&gt;', {class: 'far fa-clock'}),\n                  $('&lt;h3/&gt;', {class: 'comment-date', text: x.date})\n                ])\n              ]),\n              $('&lt;p/&gt;', {class: 'comment-text', text: x.comment}),\n              $('&lt;details/&gt;').append([\n                $('&lt;summary/&gt;', {class: 'text-reply', text: 'reply'}),\n                reply_comment_box(x.page_id, x.site_id, x.ref)\n              ]),\n              comment_recurse(x)\n            ]),\n\n          );\n          \n        });\n        return(ul_list_comments)\n      } else {\n        return(null)\n      }\n      \n    }\n      \n    // outer_div - placeholder for comments\n    div_outer = $('&lt;div/&gt;').attr('id', 'div_outer');\n    \n    // add comments if exist\n    if (data.children) {\n      // add comments count\n      div_outer.append('&lt;h3&gt;' + data.children.length + ' Comments&lt;/h3&gt;');\n      \n      // recursively loop through returned comments, building unordered lists\n      ul_list_comments = comment_recurse(data);\n      \n      // add comments to outer div\n      div_outer.append(ul_list_comments);\n    }\n    \n    // update comment holder\n    $(\"#rtncomments\").html(div_outer);\n    \n    // add event listener to class\n    const reply_forms = document.querySelectorAll('.reply-form');\n    reply_forms.forEach(item =&gt; item.addEventListener('submit', formsubmit));\n    \n  })\n  .catch((err) =&gt; console.log(\"Can’t access \" + url + \" response. Blocked by browser?\" + err));\n  \n};"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#plumber-api",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#plumber-api",
    "title": "{distill} Comments With Replies",
    "section": "plumber API",
    "text": "plumber API\nAs previously, the distill blog pages via a plumber API. The API contains two endpoints, a POST endpoint, addcomment_dt which is used to add a new comment and a GET endpoint, page_comments_dt which is used to retrieve comments for a specific page. The comments are stored in a hierarchical data.tree format which is accessible via the {pins} package.\nIn the code below, board_register(\"rsconnect\", server = \"&lt;rsconnect URL&gt;, account = \"&lt;account id&gt;\", key = connectAPIKey) registers a pin board which holds a pin called blog_comment_table+dt.  refers to the RStudio Connect URL and,  is the account associated with the pin. An RStudio Connect API key must be defined and exposed as an environment variable (see below).\n\naddcomment_dt adds the comment to a parent id which sits under a page id, that is, in turn, under a site id. Each comment is given a unique reference id, used as an identifier when comments or replies are added.\npage_comments_dt retrieves a hierarchy of comments and replies for a specified site id and page id. The data.tree obtained is returned as a list.\n\nlibrary(plumber)\nlibrary(jsonlite)\nlibrary(pins)\nlibrary(lubridate)\nlibrary(data.tree)\nlibrary(stringi)\n\n#* Add a comment to the comment table\n#* \n#* @param req request body\n#* \n#* @serializer unboxedJSON\n#* \n#* @post /addcomment_dt\nfunction(req) {\n  \n  ## get the message body\n  body &lt;- jsonlite::fromJSON(req$postBody)\n  \n  ## RSConnect API Key\n  connectAPIKey &lt;- Sys.getenv(\"CONNECT_API_KEY\")\n  \n  ## register rsconnect pin board\n  board_register(\"rsconnect\",\n                 server = \"&lt;rsconnect URL&gt;\",\n                 account = \"&lt;account id&gt;\",\n                 key = connectAPIKey)\n  \n  ## generate a ref for the comment\n  comment_ref &lt;- stringi::stri_rand_strings(n = 1, length = 12)\n  \n  comment &lt;- c(\n    body,\n    list(\n      ref = comment_ref,\n      date = lubridate::now()\n    )\n  )\n  \n  ## check for comments table and create if not present\n  if (nrow(pins::pin_find(\"blog_comment_table_dt\", board = \"rsconnect\")) == 0) {\n    comment_tree &lt;- Node$new(\"comments\")\n  } else {\n    comment_tree &lt;- pins::pin_get(name = \"blog_comment_table_dt\", board = \"rsconnect\") \n  }\n  \n  ## does site_id child node exist?\n  if (is.null(FindNode(comment_tree, comment$site_id))) {\n    comment_tree$AddChild(comment$site_id)\n  }\n  \n  ## does page_id child node exist?\n  site_node &lt;- FindNode(comment_tree, comment$site_id)\n  if (is.null(FindNode(site_node, comment$page_id))) {\n    site_node$AddChild(comment$page_id)\n  }\n  \n  ## add new comment\n  if (!is.na(comment$parent_ref)) {\n    parent_node &lt;- FindNode(site_node, comment$parent_ref)\n  } else {\n    parent_node &lt;- FindNode(site_node, comment$page_id)\n  }\n  do.call(parent_node$AddChild, c(list(name = comment$ref), comment))\n  \n  pins::pin(comment_tree, name = \"blog_comment_table_dt\", board = \"rsconnect\")\n  \n  return(comment)\n}\n\n\n#* Retrieve all comments for a page\n#* \n#* @param site site id\n#* @param page page id\n#* \n#* @serializer unboxedJSON\n#* \n#* @get /page_comments_dt\nfunction(site = \"site_01\", page = \"page_01\") {\n  \n  ## RSConnect API Key\n  connectAPIKey &lt;- Sys.getenv(\"CONNECT_API_KEY\")\n  \n  ## register rsconnect pin board\n  board_register(\"rsconnect\", \n                 server = \"https://rsconnect-prod.dit.eu.novartis.net\",\n                 account = \"liebeha1\",\n                 key = connectAPIKey)\n  \n  ## get table and filter\n  rtn_subtree &lt;- list()\n  if (nrow(pins::pin_find(\"blog_comment_table_dt\", board = \"rsconnect\")) &gt; 0) {\n    \n    ## get pinned comment tree\n    comment_tree &lt;- pins::pin_get(name = \"blog_comment_table_dt\", board = \"rsconnect\")\n    \n    ## is site in comment tree?\n    if (!is.null(FindNode(comment_tree, site))) {\n      \n      ## is page in comment tree and does it have comments?\n      found_page_comments &lt;- FindNode(comment_tree[[site]], page)\n      if (!is.null(found_page_comments)) {\n        rtn_subtree &lt;- as.list(found_page_comments, \n                               mode = \"explicit\", unname = TRUE)\n      }\n      \n    }\n  }\n  return(rtn_subtree)\n}\n\n\n\n\ndata.tree with comments illustrating hierarchy. Data are nested as comments, replies, replies-to-replies, etc. For example, page_01 contains two comments: R8VkpR08pQTA (with a reply cVGBQzLRV9pa) and lHcoISddQbJp\n\n\n\n\n\noutput from data.tree illustrating the metadata held at each node"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#webpage-blog-post-with-comments",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#webpage-blog-post-with-comments",
    "title": "{distill} Comments With Replies",
    "section": "Webpage / Blog Post with Comments",
    "text": "Webpage / Blog Post with Comments\nAny page with comments follows the same approach. The page includes the javascript functions listed above (comments.js), some css styling (style.css, see below) and the comment_form function (sourced from comment.R).\nThere are a few things to note in the code below.\n\nThe two variables, site_id and page_id, are needed to identify comments for the webpage. Ideally, we’d define them in the yaml header and use them as parameters in the markdown text. Unfortunately, when using render_site, markdown parameters are not rendered (see open GitHub issue). site_id and page_id are therefore defined within a chunk.\nThe javascript function update_comments_dt does not sit in a javascript chunk (you can include javascript in rmarkdown by including a chunk with js instead of r in the chunk header). Instead, the code is placed directly within a &lt;script&gt; tag. When processed this way, we can access variables (site_id and page_id) stored in r language chunks earlier in the document.\n\n\n    ---\n    title: \"article 1\"\n    description: |\n      Blog post #1.\n    author:\n      - name: Harvey Lieberman\n    date: 03-03-2022\n    output:\n      distill::distill_article:\n        self_contained: false\n    ---\n\n    ```{r setup, include=FALSE}\n    knitr::opts_chunk$set(echo = FALSE)\n    ```\n\n\n    ```{r}\n    ## define site and page\n    page_id &lt;- \"page_01\"\n    site_id &lt;- \"site_02\"\n\n    ## add function, css and js to page\n    source(here::here(\"comment_dt.R\"))\n    htmltools::includeCSS(here::here(\"style.css\"))\n    htmltools::includeScript(here::here(\"comment_dt.js\"))\n    ```\n\n\n    This is a typical blog post but with a comment section added.  \n    Comments include nested replies.\n\n\n    ```{r}\n    ## include comment form\n    comment_form_dt(page_id = page_id, site_id = site_id)\n\n    ## js below placed in script tags so that R variable can be included\n    ```\n\n\n    &lt;script&gt;\n    update_comments_dt(page_id = \"`r page_id`\", site_id = \"`r site_id`\")\n    &lt;/script&gt;"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#css",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#css",
    "title": "{distill} Comments With Replies",
    "section": "css",
    "text": "css\nThe style.css file takes care of styling comments. The file is included below.\n.comments {\n  padding: 20px 10px;\n  margin: 0;\n}\n\n.form-container input[type=submit] {\n  background-color: #04AA6D;\n  color: white;\n  padding: 12px 20px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n.form-container input[type=submit]:hover {\n  background-color: #45a049;\n}\n\n.comment-header {\n  font-size: 1.5em;\n  line-height: 1.5em;\n  font-weight: 400;\n  margin-block-start: 1.5em;\n  margin-block-end: 1.5em;\n}\n\n.comment-header-margin-narrow {\n  margin-block-start: 0.5em;\n  margin-block-end: 0.5em;\n}\n\n.form-contents {\n    padding: 10px;\n    margin: 10px;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\n.form-contents .comment-pic {\n    display: flex;\n    font-size: 3em;\n    align-self: flex-end;\n}\n\n.form-details {\n    display: flex;\n    flex-direction: column;\n    flex: 2 1 auto;\n}\n\n.form-details input[type=text] {\n    border-top: 0px;\n    border-bottom: 1px solid #ccc;\n    border-left: 0px;\n    border-right: 0px;\n    outline: 0px;\n    padding: 0;\n    margin-top: 20px;\n    margin-left: 20px;\n    font-weight: normal;\n}\n\n.form-details input[type=text]:focus {\n    border-color: #04AA6D;\n    border-width: 2px;\n}\n\n.comment-comments input[type=text]{\n    width: 90%;\n}\n\n.comment-user {\n    display: flex;\n    flex-direction: row;\n}\n\n.comment-short {\n    width: 50%;\n}\n\n.comment-short input[type=text]{\n    width: 80%;\n}\n\n.button-container {\n    display: flex;\n    align-self: flex-end;\n}\n\n.button-container input[type=submit] {\n  margin: 2px 5px;\n  float: right;\n}\n\n.comment-holder {\n  margin-top: 50px;\n}\n\nul.comment-list {\n  list-style: none;\n  position: relative;\n  padding: 0;\n  border: 1px solid #ccc;\n}\n\nli.comment-item {\n  padding: 20px 10px;\n  margin: 20px 0;\n  position: relative;\n}\n\n.comment-top {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n}\n\n.comment-name {\n  font-size: 1.5em;\n  font-weight: 400;\n  margin: 5px 0;\n  color: #5d5d5d;\n  align-self: flex-start;\n}\n\n.date-holder {\n  color: #5d5d5d;\n  align-self: flex-end;\n  display: inline-flex;\n  align-items: baseline;\n}\n\n.comment-date {\n  font-size: 1em;\n  font-weight: 400;\n  margin: 5px 0 5px 10px;\n}\n\n.comment-text {\n  display: block;\n  margin: 0 0 10px 0;\n}"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#output",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#output",
    "title": "{distill} Comments With Replies",
    "section": "Output",
    "text": "Output\nThe follow screen captures illustrate adding comments and replies.\n\nFirst comment add to a blog post\n\n\n\nFirst comment add to a blog post\n\n\n\nAdding a reply added to comment #1\nClicking on the Reply dropdown opens a reply window\n\n\n\nOnce the reply is added it also includes a dropdown for nesting replies\n\n\n\nReply for comment #2 dropdown opened"
  },
  {
    "objectID": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#conclusion",
    "href": "posts/2022/2022-03-05-distill_comments_with_replies/index.html#conclusion",
    "title": "{distill} Comments With Replies",
    "section": "Conclusion",
    "text": "Conclusion\nRStudio Connect can be used with {pins} to hold nested comments for blog pages. This demonstrates the huge scope that RStudio Connect can play as a CMS."
  },
  {
    "objectID": "posts/2022/2022-05-28-metadata/index.html",
    "href": "posts/2022/2022-05-28-metadata/index.html",
    "title": "Adding Metadata to R Functions",
    "section": "",
    "text": "This post describes three ways to tag functions with metadata."
  },
  {
    "objectID": "posts/2022/2022-05-28-metadata/index.html#attributes",
    "href": "posts/2022/2022-05-28-metadata/index.html#attributes",
    "title": "Adding Metadata to R Functions",
    "section": "Attributes",
    "text": "Attributes\nUsing attributes is a simple way to add metadata to any object in R. Data frames and other objects already use attributes to hold metadata which are accessible via the attributes function.\n\ndf &lt;- data.frame(a = 1:5, b = letters[1:5])\n\n## retrieve attributes\nattributes(df)\n\n$names\n[1] \"a\" \"b\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3 4 5\n\n\nMetadata can be added by simply using the attributes function and retrieved using attr.\n\nf &lt;- function(x, y) {\n    sum(x, y)\n}\n\n## add two new attributes\nattributes(f) &lt;- c(attributes(f), f = \"function: sum\", param_count = 2)\n\n\n## list all attributes\nattributes(f)\n\n$srcref\nfunction(x, y) {\n    sum(x, y)\n}\n\n$f\n[1] \"function: sum\"\n\n$param_count\n[1] 2\n\n\n\n## retrieve a single attribute\nattr(f, \"param_count\")\n\n[1] 2"
  },
  {
    "objectID": "posts/2022/2022-05-28-metadata/index.html#metadata-in-comment",
    "href": "posts/2022/2022-05-28-metadata/index.html#metadata-in-comment",
    "title": "Adding Metadata to R Functions",
    "section": "Metadata in comment",
    "text": "Metadata in comment\nMetadata can be associated with any R object using comment. The comment is, in fact, simply an attribute with the limitation that it must be a character vector. Multiple items of metadata can be attached using the comment function.\n\nf &lt;- function(x, y) {\n    sum(x, y)\n}\n\ncomment(f) &lt;- c(f = \"function: sum\", param_count = \"2\")\n\nOnce set, comment can be used to retrieve one of more items of metadata.\n\ncomment(f)\n\n              f     param_count \n\"function: sum\"             \"2\" \n\ncomment(f)[[\"param_count\"]]\n\n[1] \"2\"\n\n\nFor a more complex data structure a json object can be attached. Note that in the example below, param_count is a numeric as opposed to a character type imposed when using comment to hold a vector.\n\nf &lt;- function(x, y) {\n    sum(x, y)\n}\n\ncomment(f) &lt;- jsonlite::toJSON(list(f = \"function: sum\", param_count = 2), auto_unbox = TRUE)\n\n\n## retrieving metadata (comment)\ncomment(f)\n\n{\"f\":\"function: sum\",\"param_count\":2} \n\njsonlite::fromJSON(comment(f))\n\n$f\n[1] \"function: sum\"\n\n$param_count\n[1] 2"
  },
  {
    "objectID": "posts/2022/2022-05-28-metadata/index.html#metadata-in-roxygen2",
    "href": "posts/2022/2022-05-28-metadata/index.html#metadata-in-roxygen2",
    "title": "Adding Metadata to R Functions",
    "section": "Metadata in roxygen2",
    "text": "Metadata in roxygen2\nMetadata can be included in custom roxygen2 tags. Once added it can be retrieved programatically.\nIn order to demonstrate this method we need to build two packages - one for the custom tag and the other to demonstate its use in a function.\n\nPackage 1 - Custom roxygen2 tag\nThis package consists of a number of functions to define a new roclet, metadata which can be used to store metadata for a function. The R code is shown below.\n\n#' roclet to parse @metadata tag\n#'\n#' @import roxygen2\n#' @export\nmetadata &lt;- function() {\n  roxygen2::roclet(\"metadata\")\n}\n\n\n#' @rdname metadata\n#' @importFrom roxygen2 tag_markdown\n#' @export\nroxy_tag_parse.roxy_tag_metadata &lt;- function(x) {\n  roxygen2::tag_markdown(x)\n}\n\n\n#' @rdname metadata\n#' @importFrom roxygen2 rd_section\n#' @export\nroxy_tag_rd.roxy_tag_metadata &lt;- function(x, base_path, env) {\n  roxygen2::rd_section('metadata', x$val)\n}\n\n#' @rdname metadata\n#' @export\nformat.rd_section_metadata &lt;- function(x, ...) {\n  paste0(\n    \"\\\\section{Metadata}{\\n\",\n    x$value,\n    \"}\\n\"\n  )\n}\n\n\n#' @rdname metadata\n#' @export\nroclet_process.roclet_metadata &lt;- function(x, blocks, env, base_path) {\n  x\n}\n\n\n#' @rdname metadata\n#' @export\nroclet_output.roclet_metadata &lt;- function(x, results, base_path, ...) {\n  x\n}\n\nAn explanation of extending roxygen2 can be found with the roxygen2 documentation.\nAfter running roxygen2::roxygenize() to document and build the NAMESPACE file, this package can be built and installed.\n\n\nPackage 2 - testing\nTo test the roclet we need to build a second package consisting of a single function, my_function.\n\n#' my function\n#'\n#' my function to test metadata roclet\n#'\n#' @metadata \\{\"a\":1, \"b\":\"text string\", \"c\": \\[4, 5, 6\\]\\}\n#'\n#' @export\nmy_function &lt;- function(x) {\n  x\n}\n\nThis function contains the new roclet @metadata which holds a json-encoded string of parameters.\nIn addition to the function we need to add this line to the DESCRIPTION file:\n\nRoxygen: list(markdown = TRUE, roclets = c(\"namespace\", \"rd\", \"collate\", \"roxymeta::metadata\"))\n\nOnce roxygen2::roxygenize() is run, the function documentation incudes the new tag:\n\n\n\nFunction to retrieve metadata\nNow that the metadata has been attached to a function it can be retrieved using the code below:\n\n#' extract parameters from roxygen tags\n#'\n#' extract parameters from roxygen tags\n#'\n#' @param n Namespace\n#' @param f Function\n#'\n#' @importFrom tools Rd_db\n#' @importFrom jsonlite fromJSON\n#'\n#' @export\n#'\nget_params &lt;- function(n, f) {\n  db &lt;- tools::Rd_db(n)\n  fn_rd &lt;- db[[paste0(f, \".Rd\")]]\n  \n  ## get list of attributes\n  fn_attributes &lt;- lapply(fn_rd, attributes)\n  \n  ## get sections\n  fn_sections &lt;- which(\n    sapply(fn_attributes, function(x) {\n      x$Rd_tag == \"\\\\section\"\n    })\n  )\n  \n  ## get param section\n  fn_params &lt;- which(\n    sapply(fn_rd[fn_sections], function(x) {\n      x[[1]] == \"Metadata\"\n    })\n  )\n  \n  if (length(fn_params) &gt; 0) {\n    \n    input_tags &lt;- fn_rd[[fn_sections[fn_params]]]\n    param_tag &lt;- input_tags[[2]][[2]]\n    return(jsonlite::fromJSON(as.character(param_tag), simplifyVector = FALSE))\n    \n  } else {\n    \n    return(NULL)\n    \n  }\n  \n}\n\nThis function simply retrieves the Rd file and parses it, retrieving the json-encoded metadata and returning a list.\n\nout &lt;- get_params('roxymetatest', 'my_function')\nout\n\n\n\n$a\n[1] 1\n\n$b\n[1] \"text string\"\n\n$c\n$c[[1]]\n[1] 4\n\n$c[[2]]\n[1] 5\n\n$c[[3]]\n[1] 6\n\n\nThis is a very basic example, simply demonstrating what can be done.\nOne use-case for this approach is for self-building shiny functions. Such a function could embed shiny widget details which are used to build interactive inputs to the function. The shiny widgets could therefore be built for the function prior to running the function itself.\ncode for this example is available in\nhttps://github.com/harveyl888/roxymeta\nhttps://github.com/harveyl888/roxymetatest\nhttps://gist.github.com/harveyl888/1f043414a4102ed5f04e8ed22b73c939"
  },
  {
    "objectID": "posts/2022/2022-06-27-quarto_sas_01/index.html",
    "href": "posts/2022/2022-06-27-quarto_sas_01/index.html",
    "title": "Running SAS in Quarto. Part 1",
    "section": "",
    "text": "Quarto is a powerful web publishing system based on Pandoc. Working with jupyter kernels expands the number of languages that Quarto can work with. In this example we’ll add SAS capability to Quarto."
  },
  {
    "objectID": "posts/2022/2022-06-27-quarto_sas_01/index.html#setup",
    "href": "posts/2022/2022-06-27-quarto_sas_01/index.html#setup",
    "title": "Running SAS in Quarto. Part 1",
    "section": "Setup",
    "text": "Setup\nFirst install the saspy and the SAS kernel packages.\npip install saspy\npip install sas_kernel\nOnce installed the sas kernel should be listed when running jupyter kernelspec list:\nsas      ...\npython3  ..."
  },
  {
    "objectID": "posts/2022/2022-06-27-quarto_sas_01/index.html#configure-saspy",
    "href": "posts/2022/2022-06-27-quarto_sas_01/index.html#configure-saspy",
    "title": "Running SAS in Quarto. Part 1",
    "section": "Configure saspy",
    "text": "Configure saspy\nBefore the kernel can be used, two configuration files need to be created: - sascfg_personal.py contains details on how to connect to a SAS instance - _authinfo contains authentication details\nDetails on the configuration files are available at https://sassoftware.github.io/saspy/configuration.html.\nI’m using SAS on demand and additional information on editing these two files is available at https://support.sas.com/ondemand/saspy.html.\n\nsascfg_personal.py\nBelow is an example of a sascfg_personal.py (for a PC configuration). Here we are specifying the connection to the SAS On Demand for Academics (oda) service, US Home Region 2. The sasacfg_personal.py can be placed in the .config/saspy/ subfolder under the home folder.\n\nSAS_config_names=['oda']\noda = {'java' : 'C:\\\\Program Files (x86)\\\\Common Files\\\\Oracle\\\\Java\\\\javapath\\\\java.exe',\n#US Home Region 1\n#'iomhost' : ['odaws01-usw2.oda.sas.com','odaws02-usw2.oda.sas.com','odaws03-usw2.oda.sas.com','odaws04-usw2.oda.sas.com'],\n#US Home Region 2\n'iomhost' : ['odaws01-usw2-2.oda.sas.com','odaws02-usw2-2.oda.sas.com'],\n#European Home Region 1\n#'iomhost' : ['odaws01-euw1.oda.sas.com','odaws02-euw1.oda.sas.com'],\n#Asia Pacific Home Region 1\n#'iomhost' : ['odaws01-apse1.oda.sas.com','odaws02-apse1.oda.sas.com'],\n#Asia Pacific Home Region 2\n#'iomhost' : ['odaws01-apse1-2.oda.sas.com','odaws02-apse1-2.oda.sas.com'],\n'iomport' : 8591,\n'authkey' : 'oda',\n'encoding' : 'utf-8'\n}\n\n\n_authinfo\nThe _authinfo file is located in the home folder and, for SAS On Demand for Academics, looks like this:\noda user &lt;username&gt; password &lt;password&gt;\nwhere  and  are the credentials to connect to oda.\n\n\ntesting SAS in Quarto\nNow that the SAS kernel has been installed and configured, we should be able to execute SAS code in a Quarto document by specifying the kernel in the yaml:\n---\ntitle: \"Quarto Demo with SAS\"\nformat: html\njupyter: sas\nself-contained: true\n---\n\n### Jupyter SAS kernel\n\n```{sas}\nproc candisc data=sashelp.iris out=outcan distance anova;\n   class Species;\n   var SepalLength SepalWidth PetalLength PetalWidth;\nrun;\n```"
  },
  {
    "objectID": "posts/2022/2022-11-11-plumber_as_a_package/index.html",
    "href": "posts/2022/2022-11-11-plumber_as_a_package/index.html",
    "title": "plumber API as a package",
    "section": "",
    "text": "There are many advantages to building R-based code as a package. You can use the DESCRIPTION file to store metadata related to the API, separate functions from endpoints in the R/ folder, include documentation and run tests.\nIn this example we’ll build a simple plumber API as a package. The API will have two endpoints - /version will return the package version and /sum will sum two numbers."
  },
  {
    "objectID": "posts/2022/2022-11-11-plumber_as_a_package/index.html#description-namespace-and-license.md",
    "href": "posts/2022/2022-11-11-plumber_as_a_package/index.html#description-namespace-and-license.md",
    "title": "plumber API as a package",
    "section": "DESCRIPTION, NAMESPACE and license.md",
    "text": "DESCRIPTION, NAMESPACE and license.md\nDESCRIPTION is a typical DESCRIPTION file, as shown below.\n\nPackage: genericAPI\nTitle: A simple generic API\nVersion: 0.0.1\nAuthors@R: \n  person(\"Harvey\", \"Lieberman\", \"harvey.lieberman@novartis.com\", role = c(\"aut\", \"cre\"))\nDescription: An R package to demonstrate developing a plumber API as a package.\nLicense: MIT + file LICENSE\nEncoding: UTF-8\nImports:\n  pkgload,\n  plumber\nRoxygenNote: 7.2.1\nSuggests: \n    testthat (&gt;= 3.0.0)\nConfig/testthat/edition: 3\n\nNAMESPACE is built using roxygen2::roxygenise().\n\n# Generated by roxygen2: do not edit by hand\n\nimport(pkgload)\nimport(plumber)"
  },
  {
    "objectID": "posts/2022/2022-11-11-plumber_as_a_package/index.html#entrypoint.r",
    "href": "posts/2022/2022-11-11-plumber_as_a_package/index.html#entrypoint.r",
    "title": "plumber API as a package",
    "section": "entrypoint.R",
    "text": "entrypoint.R\nWhen starting an API, the plumber package looks for plumber.R to parse as the plumber router definition. Alternatively, if an entrypoint.R file is found it will take precedence and be responsible for returning a runnable router.\nThe entrypoint.R is simple. It loads all function definitions and then points to the plumber.R file under the R/ folder.\n\n## load all functions\npkgload::load_all()\n\n## start plumber\npr &lt;- plumber::plumb(\"./R/plumber.R\")"
  },
  {
    "objectID": "posts/2022/2022-11-11-plumber_as_a_package/index.html#rplumber.r",
    "href": "posts/2022/2022-11-11-plumber_as_a_package/index.html#rplumber.r",
    "title": "plumber API as a package",
    "section": "R/plumber.R",
    "text": "R/plumber.R\nThere is no difference between this and the plumber.R file in a traditional plumber API. It holds the endpoints for the API. One advantage of building a package, however, is that the functions can be separated into other files. This makes the plumber.R file more succint, holding just the API endpoints.\nIn the code below we include a NULL function so that any packages required by the API are added to NAMESPACE. The /version endpoint returns the package version and the /sum endpoint calls a function called sum_numbers().\n\n#* @apiTitle My generic plumber API\n\n#' plumber functions\n#' \n#' plumber endpoints\n#' \n#' @name plumber\n#' @import pkgload\n#' @import plumber\nNULL\n\n#* API version\n#* \n#* return an API version\n#* \n#* @serializer unboxedJSON\n#* \n#* @get /version\nfunction() {\n  list(version = as.character(packageVersion(\"genericAPI\")))\n}\n\n#* Sum\n#* \n#* Sum two numbers\n#* \n#* @param a a number\n#* @param b a number\n#* \n#* @serializer unboxedJSON\n#* \n#* @get /sum\nfunction(a, b) {\n  list(sum = sum_numbers(a, b))\n}"
  },
  {
    "objectID": "posts/2022/2022-11-11-plumber_as_a_package/index.html#rsum-_-numbers.r",
    "href": "posts/2022/2022-11-11-plumber_as_a_package/index.html#rsum-_-numbers.r",
    "title": "plumber API as a package",
    "section": "R/sum _ numbers.R",
    "text": "R/sum _ numbers.R\nsum_numbers() is a simple function returning the sum of two numbers. Since it’s included in a package we can take advantage of roxygen2 documentation. As it is only used within the API, this function does not have to be exported.\n\n#' my simple function\n#' \n#' A simple addition function\n#' \n#' @param a numeric\n#' @param b numeric\n#' \nsum_numbers &lt;- function(a, b) {\n  tryCatch({\n    as.numeric(a) + as.numeric(b)\n  }, \n  warning = function(e) {\n    \"not numeric\"\n  },\n  error = function(e) {\n    \"error\"\n  })\n}"
  },
  {
    "objectID": "posts/2022/2022-11-11-plumber_as_a_package/index.html#testthattest-sum-_-numbers.r",
    "href": "posts/2022/2022-11-11-plumber_as_a_package/index.html#testthattest-sum-_-numbers.r",
    "title": "plumber API as a package",
    "section": "testthat/test-sum _ numbers.R",
    "text": "testthat/test-sum _ numbers.R\nFinally, we can add tests. The test-sum_numbers.R runs three simple tests to ensure our function is performing correctly.\n\ntest_that(\"summation works\", {\n  expect_equal(sum_numbers('1', '2'), 3)\n  expect_equal(sum_numbers(1, 2), 3)\n  expect_equal(sum_numbers(1, \"A\"), \"not numeric\")\n})"
  },
  {
    "objectID": "posts/2023/2023-02-16-shiny_framework_01/index.html",
    "href": "posts/2023/2023-02-16-shiny_framework_01/index.html",
    "title": "Shiny Frameworks 01 - Introduction",
    "section": "",
    "text": "This is the first in a series of blog posts tagged Shiny Framekworks The goal is to provide a some loosely connected articles related to building shiny frameworks with the ultimate goal of turning them into an eBook. Inspiration comes from a presentation I gave at R/Pharma 2022 (https://youtu.be/bkKe_kC83iQ).\n\n\nImagine you’ve built a killer shiny app and you need to change the data. Most apps are adaptable to a degree. If you want to upload a different set of data, the app should be able to accommodate if the data are in an expected format.\nBut what if:\n\nyour data are in a completely different format?\nyou want to manipulate your data in some way (filter or add a new variable)?\nyou want to use a completely different visualization?\n\nIt’s unlikely that the app can cope with these situations unless choices were made at the design stage.\nA shiny framework is an approach to building shiny apps which allows for:\n\nflexibility: being able to offer choices after the app has been built.\nextensibility: ability to readily extend the framework for unmet needs.\nscalability: easily scale beyond the current needs of the app.\n\nThe basic premise is to build the app using instructions. These instructions are parsed through an interpreter, or an engine, which converts the instructions into R code. An interpreter can do many things, such as:\n\nreading and understanding files of different formats\ndata wrangling and manipulation\nbuilding static or dynamic outputs\nbuiding and/or responding to shiny reactives\n\nTaken to the extreme, a shiny framework can be used to build any part of an app. It’s a powerful resource to simplify the build for a series of similar apps. In effect you could build a framework that builds other frameworks or an app that builds other apps.\n\n\n\nWhen working with a framework its a good programming practice to take on a three layer approach:\n\nData Layer. This is where the data reside along with any functions that interact with the data.\nApplication Layer. This is where the data are processed and any analyses are performed.\nPresentation Layer. This is where the output is generated and presented to the user.\n\nIt’s important to note that layers can only interact with adjacent layers, meaning that information may pass from the data layer to the application layer and from the application layer to the presentation layer but NOT from the data layer directly to the presentation layer - it must pass through the application layer first.\nWhy is this an effective way of working? Well, firstly it forces you to separate out the tasks. From an R-perspective it’s easier to maintain once you realize that data interaction, processing and presentation can each exist in their own separate packages. Secondly it allows for simpler scalability - data retrieval and processing can be accomplished using an API running on a different architecture, releasing burden from a shiny app. Taking this a step further, each of these layers may be a different language (python API to access data, R to process and javascript to display)."
  },
  {
    "objectID": "posts/2023/2023-02-16-shiny_framework_01/index.html#shiny-frameworks",
    "href": "posts/2023/2023-02-16-shiny_framework_01/index.html#shiny-frameworks",
    "title": "Shiny Frameworks 01 - Introduction",
    "section": "",
    "text": "This is the first in a series of blog posts tagged Shiny Framekworks The goal is to provide a some loosely connected articles related to building shiny frameworks with the ultimate goal of turning them into an eBook. Inspiration comes from a presentation I gave at R/Pharma 2022 (https://youtu.be/bkKe_kC83iQ).\n\n\nImagine you’ve built a killer shiny app and you need to change the data. Most apps are adaptable to a degree. If you want to upload a different set of data, the app should be able to accommodate if the data are in an expected format.\nBut what if:\n\nyour data are in a completely different format?\nyou want to manipulate your data in some way (filter or add a new variable)?\nyou want to use a completely different visualization?\n\nIt’s unlikely that the app can cope with these situations unless choices were made at the design stage.\nA shiny framework is an approach to building shiny apps which allows for:\n\nflexibility: being able to offer choices after the app has been built.\nextensibility: ability to readily extend the framework for unmet needs.\nscalability: easily scale beyond the current needs of the app.\n\nThe basic premise is to build the app using instructions. These instructions are parsed through an interpreter, or an engine, which converts the instructions into R code. An interpreter can do many things, such as:\n\nreading and understanding files of different formats\ndata wrangling and manipulation\nbuilding static or dynamic outputs\nbuiding and/or responding to shiny reactives\n\nTaken to the extreme, a shiny framework can be used to build any part of an app. It’s a powerful resource to simplify the build for a series of similar apps. In effect you could build a framework that builds other frameworks or an app that builds other apps.\n\n\n\nWhen working with a framework its a good programming practice to take on a three layer approach:\n\nData Layer. This is where the data reside along with any functions that interact with the data.\nApplication Layer. This is where the data are processed and any analyses are performed.\nPresentation Layer. This is where the output is generated and presented to the user.\n\nIt’s important to note that layers can only interact with adjacent layers, meaning that information may pass from the data layer to the application layer and from the application layer to the presentation layer but NOT from the data layer directly to the presentation layer - it must pass through the application layer first.\nWhy is this an effective way of working? Well, firstly it forces you to separate out the tasks. From an R-perspective it’s easier to maintain once you realize that data interaction, processing and presentation can each exist in their own separate packages. Secondly it allows for simpler scalability - data retrieval and processing can be accomplished using an API running on a different architecture, releasing burden from a shiny app. Taking this a step further, each of these layers may be a different language (python API to access data, R to process and javascript to display)."
  },
  {
    "objectID": "posts/2023/2023-03-10-shiny_framework_03/index.html",
    "href": "posts/2023/2023-03-10-shiny_framework_03/index.html",
    "title": "Shiny Frameworks 03 - A Simple Interpreter",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover the concept of interpreters with a simple example."
  },
  {
    "objectID": "posts/2023/2023-03-10-shiny_framework_03/index.html#introduction",
    "href": "posts/2023/2023-03-10-shiny_framework_03/index.html#introduction",
    "title": "Shiny Frameworks 03 - A Simple Interpreter",
    "section": "",
    "text": "Continuing the series on shiny frameworks, this post will cover the concept of interpreters with a simple example."
  },
  {
    "objectID": "posts/2023/2023-03-10-shiny_framework_03/index.html#shiny-framework-interpreters",
    "href": "posts/2023/2023-03-10-shiny_framework_03/index.html#shiny-framework-interpreters",
    "title": "Shiny Frameworks 03 - A Simple Interpreter",
    "section": "Shiny Framework Interpreters",
    "text": "Shiny Framework Interpreters\nWhere instructions are the soul of a shiny framework, interpreters are the heart. An interpreter takes input instructions, parses them and generates an output. An ideal interpreter should be data agnostic, meaning that it can take multiple, different types of data and work with them accordingly. The instructions tell the interpreter what to do and how to handle the data.\nIn one simple example below we’ll read in an instruction file and parse its contents to build a plot.\nThe instructional file (instructions.json) looks like this:\n{\n  \"build\": \"plot\",\n  \"data\": \"mtcars\",\n  \"type\": \"scatter\",\n  \"x\": \"mpg\",\n  \"y\": \"wt\"\n}\nThe interpreter is a parser that can read this input and act upon it.\n\n## import json to R list\ninstr &lt;- jsonlite::fromJSON(\"instructions.json\", simplifyVector = FALSE)\n\n## parse contents and build plot\nif (isTRUE(instr$build == \"plot\")) {\n  data &lt;- get(instr$data)\n  if (isTRUE(instr$type == \"scatter\")) {\n    plot(data[[instr$x]],\n         data[[instr$y]],\n         xlab = instr$x,\n         ylab = instr$y,\n         type = \"p\")\n  }\n}\n\nUpon running we get a plot that has been built using the parameters from the json file.\n\nUnpacking the code above we first import the json file using the jsonlite library. The file will be interpreted as a list by R:\n\ninstr\n\n$build\n[1] \"plot\"\n\n$data\n[1] \"mtcars\"\n\n$type\n[1] \"scatter\"\n\n$x\n[1] \"mpg\"\n\n$y\n[1] \"wt\"\n\n\n&gt; instr\n$build\n[1] \"plot\"\n\n$data\n[1] \"mtcars\"\n\n$type\n[1] \"scatter\"\n\n$x\n[1] \"mpg\"\n\n$y\n[1] \"wt\"\nThe parser works by first identifying if instr$build is plot and then generating the plot. We use isTRUE to check the value of instr$build as it returns false if there is no match or if the list instr does not have an element named build. The parser then assigns the data to a variable using the get function and builds a scatterplot, assigning parameters as applicable.\nThis simple example does not include error checking for missing parameters. The parser would fail if, for example, x or y were missing or referenced a column in the data that does not exist. This can be easily mitigated by validating inputs or using tryCatch to handle errors.\nFrom this simple example it’s easy to see how our parser can be extended:\n\n## import json to R list\ninstr &lt;- jsonlite::fromJSON(\"instructions.json\", simplifyVector = FALSE)\n\n## parse contents and build plot\nif (isTRUE(instr$build == \"plot\")) {\n  data &lt;- get(instr$data)\n  if (isTRUE(instr$type == \"scatter\")) {\n    plot(data[[instr$x]],\n         data[[instr$y]],\n         xlab = instr$x,\n         ylab = instr$y,\n         type = \"p\")\n  } else if (isTRUE(instr$type == \"line\")) {\n    plot(data[[instr$x]],\n         data[[instr$y]],\n         xlab = instr$x,\n         ylab = instr$y,\n         type = \"l\")\n  }\n}\n\nand simplified:\n\n## import json to R list\ninstr &lt;- jsonlite::fromJSON(\"instructions.json\", simplifyVector = FALSE)\n\n## list of plot types\nplot_type &lt;- list(scatter = \"p\", line = \"l\", both = \"b\")\n\n## parse contents and build plot\nif (isTRUE(instr$build == \"plot\")) {\n  data &lt;- get(instr$data)\n  plot(data[[instr$x]],\n        data[[instr$y]],\n        xlab = instr$x,\n        ylab = instr$y,\n        type = plot_type[[instr$type]])\n}\n\nThis post introduced the concept of an interpreter, or parser, with a simple example."
  },
  {
    "objectID": "posts/2023/2023-09-04-internal_label/index.html",
    "href": "posts/2023/2023-09-04-internal_label/index.html",
    "title": "Internal labels in textInput box",
    "section": "",
    "text": "Shiny textInput label\nThis is just a short post highlighing how you can move a textInput label so that it is within the textbox textInput box itself. This is a style that can be used when you have multiple textInputs and wish to preserve screen height.\nFirst we define a css class to reduce the size of the label text and reposition it relative to the text box.\n.internal-label .control-label {\n  position: relative;\n  display: inline-block;\n  width: 100%;\n  top: 20px;\n  right: 5px;\n  text-align: right;\n  font-size: 50%;\n  color: #888;\n  z-index: 2;\n}\nThen add the class to a textInput widget to move the label.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  tags$head(tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"style.css\")),\n  br(),\n  fluidRow(column(6, offset = 1, textInput(\"txt1\", label = \"Original Textbox Label\", value = \"Textbox Text\"))),\n  fluidRow(column(6, offset = 1, textInput(\"txt1\", label = \"Internal Textbox Label\", value = \"Textbox Text\") |&gt;\n      tagAppendAttributes(class = \"internal-label\")))\n)\n\nserver &lt;- function(input, output, session) {}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "posts/2023/2023-11-10-sortable_add/index.html",
    "href": "posts/2023/2023-11-10-sortable_add/index.html",
    "title": "Adding to a sortable bucketlist",
    "section": "",
    "text": "The {sortable} package\n{sortable} is an incredibly useful R package built upon the sortbale.js javascript library, allowing drag-and-drop features to be incorporated into shiny apps. The package works with two types of sortable lists:\n\nrank list: items can be sorted within a list\nbucket list: a single object containing multiple rank lists, allowing for drag-and-drop between lists.\n\nThe second option (bucket list) is useful when a user wishes to divide a set of values between two or more buckets. {sortable} integrates well within shiny but requires a few tweaks if data are added to the sortable object once it has been created.\n\n\n\n\n\n\nNote\n\n\n\n{sortable} includes a function, update_bucket_list() which is used to update header text but not list items.\n\n\n\n\nCase One. Dragging Existing Values Between Lists\nHere’s a simple scenario. Suppose you have a list of objects in list 1 and you wish to subset to list 2, returning the values in list 2. Using {sortable} you could define a bucket list containing two rank lists (list 1 and list 2), populate list 1 and drag-and-drop values to list 2. In a shiny app this could be coded as follows:\n\nlibrary(shiny)\nlibrary(sortable)\n\nui &lt;- fluidPage(\n  uiOutput(\"ui_sort\"),\n  verbatimTextOutput(\"txt_output\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$ui_sort &lt;- renderUI({\n    \n    ## create styled list 1\n    list_1_tags &lt;- lapply(LETTERS[1:5], function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    ## create styled list 2\n    list_2_tags &lt;- lapply(LETTERS[6:8], function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    ## sortbale bucket list\n    sortable::bucket_list(\n      header = \"Move values from list 1 to list 2\",\n      group_name = \"reorder_list\",\n      sortable::add_rank_list(\n        input_id = \"reorder_list_1\",\n        text = \"list 1\",\n        labels = list_1_tags\n      ),\n      sortable::add_rank_list(\n        input_id = \"reorder_list_2\",\n        text = \"list 2\",\n        labels = list_2_tags\n      ))\n  })\n  \n  output$txt_output &lt;- renderPrint({\n    print(input$reorder_list)\n  })\n  \n}\n\nshinyApp(ui, server)\n\nIn this example, every time list 1 or list 2 changes, input$reorder_list updates with the ordered values for each list.\n\n\nCase Two. Adding a New Value to an Existing List\nUpdating the code above with an actionButton linked to insertUI allows us to add a new option to list 2 when the button is pressed. This approach works but you’ll see that it does not update input$reorder_list until the list is updated (by moving an item).\n\nlibrary(shiny)\nlibrary(sortable)\n\nui &lt;- fluidPage(\n  uiOutput(\"ui_sort\"),\n  actionButton(\"but_add\", \"Add\"),\n  verbatimTextOutput(\"txt_output\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$ui_sort &lt;- renderUI({\n    \n    ## create styled list 1\n    list_1_tags &lt;- lapply(LETTERS[1:5], function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    ## create styled list 2\n    list_2_tags &lt;- lapply(LETTERS[6:8], function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    ## sortbale bucket list\n    sortable::bucket_list(\n      header = \"Move values from list 1 to list 2\",\n      group_name = \"reorder_list\",\n      sortable::add_rank_list(\n        input_id = \"reorder_list_1\",\n        text = \"list 1\",\n        labels = list_1_tags\n      ),\n      sortable::add_rank_list(\n        input_id = \"reorder_list_2\",\n        css_id = \"css_reorder_list_2\",\n        text = \"list 2\",\n        labels = list_2_tags\n      ))\n  })\n  \n  observeEvent(input$but_add, {\n    ## insert a new value into list 2\n    val &lt;- \"ZZ\"\n    new_tag &lt;- tags$div(class = \"rank-list-item\", draggable = FALSE,\n                        tags$span(id = paste0('lab_', val), val, class = \"label label-primary\", `data-rank-id` = val)\n    )\n    insertUI(selector = \"#css_reorder_list_2\", where = \"beforeEnd\", ui = new_tag, immediate = TRUE)\n  })\n  \n  output$txt_output &lt;- renderPrint({\n    print(input$reorder_list)\n  })\n  \n}\n\nshinyApp(ui, server)\n\n\nIn order to make this approach work we can manage the ordered list, list 2 through a shiny input, input$sort_list_2. This shiny variable is kept up to date through two methods:\n\nsortable::sortable_options() updates input$sort_list_2 when list 2 is first initialized, a new item is dragged from list 1 or the order is changed.\nWhen the new item is added, a javascript function is executed, updating input\\(sort_list_2* with the newly ordered list.  The javascript function works but identifying the identifer of the list and looping through its members, populating *input\\)sort_list_2.\n\n\nlibrary(shiny)\nlibrary(sortable)\n\nui &lt;- fluidPage(\n  \n  tagList(\n    tags$head(tags$script(src = \"script.js\")),\n    uiOutput(\"ui_sort\"),\n    actionButton(\"but_add\", \"Add\"),\n    verbatimTextOutput(\"txt_output\")\n  )\n  \n)\n\nl1 &lt;- LETTERS[1:5]\nl2 &lt;- LETTERS[6:8]\n\nserver &lt;- function(input, output, session) {\n  \n  output$ui_sort &lt;- renderUI({\n    \n    list_1_tags &lt;- lapply(l1, function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    list_2_tags &lt;- lapply(l2, function(x) {\n      tags$span(id = paste0('lab_', x), x, class = \"label label-primary\", `data-rank-id` = x)\n    })\n    \n    sortable::bucket_list(\n      header = \"Reorder values in 'ordered values' column\",\n      group_name = \"reorder_list\",\n      sortable::add_rank_list(\n        input_id = \"reorder_list_1\",\n        text = \"list 1\",\n        labels = list_1_tags\n      ),\n      sortable::add_rank_list(\n        input_id = \"reorder_list_2\",\n        css_id = \"css_reorder_list_2\",\n        text = \"list 2\",\n        labels = list_2_tags,\n        options = sortable_options(\n          onSort = sortable_js_capture_input(\"sort_list_2\"),\n          onLoad = sortable_js_capture_input(\"sort_list_2\"))\n      ))\n  })\n  \n  observeEvent(input$but_add, {\n    print(\"adding ZZ\")\n    val &lt;- \"ZZ\"\n    new_tag &lt;- tags$div(class = \"rank-list-item\", draggable = FALSE,\n                        tags$span(id = paste0('lab_', val), val, class = \"label label-primary\", `data-rank-id` = val)\n    )\n    insertUI(selector = \"#css_reorder_list_2\", where = \"beforeEnd\", ui = new_tag, immediate = TRUE)\n    session$sendCustomMessage('update_sortable', list(id = \"css_reorder_list_2\", shinyinput = \"sort_list_2\"))\n  })\n  \n  output$txt_output &lt;- renderPrint({\n    print(input$sort_list_2)\n  })\n  \n}\n\nshinyApp(ui, server)\n\nShiny.addCustomMessageHandler('update_sortable', function(x) {\n  if (typeof Shiny !== 'undefined') {\n    el = document.getElementById(x.id);\n    shinyinputname = x.shinyinput + ':sortablejs.rank_list'\n    Shiny.setInputValue(shinyinputname, $.map(el.children, function(child) {\n      return $(child).attr('data-rank-id') || $.trim(child.innerText);\n    }))\n  }\n})\n\n\n\nConclusion\nThe code above demonstrates a suitable approach to add items to a sortable bucket list in a shiny app. The concept can be extended to work with multiple lists, returning the content of each."
  },
  {
    "objectID": "posts/2024/2024-02-02-passing_R6_quarto/index.html",
    "href": "posts/2024/2024-02-02-passing_R6_quarto/index.html",
    "title": "Passing and R6 Class to Quarto",
    "section": "",
    "text": "Quarto has many improvements over RMarkdown, plus a couple of limitations, one being that you cannot pass R objects as parameters to a Quarto document in the way the RMarkdown would accept them. Quarto receives parameters serialized as yaml, so only text, numeric, boolean (received as TRUE=“yes” and FALSE=“no”) and lists can be passed. There are instances when you may wish to pass a complex object, for example an R6 class instance, as a paramater for Quarto. One way to do this is to first serialize the object and then pass it as a serialized JSON object."
  },
  {
    "objectID": "posts/2024/2024-02-02-passing_R6_quarto/index.html#quarto-doc-1---sending-data-frame-and-list-as-parameters",
    "href": "posts/2024/2024-02-02-passing_R6_quarto/index.html#quarto-doc-1---sending-data-frame-and-list-as-parameters",
    "title": "Passing and R6 Class to Quarto",
    "section": "Quarto Doc 1 - sending data frame and list as parameters",
    "text": "Quarto Doc 1 - sending data frame and list as parameters\nThe first Quarto document, quarto_01.qmd accepts two parameters - a data frame and a list.\n\n---\ntitle: \"data test 01\"\nformat: html\nengine: knitr\nparams:\n  mydata: NULL\n  mylist: NULL\n---\n\nImported two items: tibble and list.  \nNumber of rows in tibble: `r nrow(params$mydata)`\n\nNumber of items in list: `r length(params$mylist)`\n\nRendering the Quarto document produces the following output. It should be noted that when rendered, the data frame is passed as a list since Quarto does not have a concept of data frames and therefore the term nrow(params$mydata) fails to report the number of rows.\n\nquarto::quarto_render(\"quarto_01.qmd\", execute_params = list(mydata = d, mylist = l))\n\n\nIn order to pass the data frame we’ll need to serialize it to a JSON representation and unserialize it once passed. We can do this using {jsonlite} as follows:\n\n---\ntitle: \"data test 01A\"\nformat: html\nengine: knitr\nparams:\n  mydata: NULL\n  mylist: NULL\n---\n\n```{r}\n#| echo: false\ndf &lt;- jsonlite::fromJSON(params$mydata)\n```\n\nImported two items: data frame and list.  \nNumber of rows in data frame: `r nrow(df)`  \nNumber of items in list: `r length(params$mylist)`\n\nNow when rendered, we get the following output:\n\nquarto::quarto_render(\"quarto_01A.qmd\", execute_params = list(mydata = jsonlite::toJSON(d), mylist = l))"
  },
  {
    "objectID": "posts/2024/2024-02-02-passing_R6_quarto/index.html#quarto-doc-2---sending-the-r6-class-instance-as-a-parameter",
    "href": "posts/2024/2024-02-02-passing_R6_quarto/index.html#quarto-doc-2---sending-the-r6-class-instance-as-a-parameter",
    "title": "Passing and R6 Class to Quarto",
    "section": "Quarto Doc 2 - sending the R6 class instance as a parameter",
    "text": "Quarto Doc 2 - sending the R6 class instance as a parameter\nThe final Quarto document, quarto_02.qmd accepts just a single parameter for the R6 class instance. In this case we serialize the R6 class and then pass it using jsonlite::JSONserialize(). When received by the Quarto document we simply reverse the procedure. The class itself has to be serialized first as using jsonlite::JSONserialize() on the class instance, r results in passing the class structure as a parameter and not the class instance.\n\n---\ntitle: \"data test 02\"\nformat: html\nengine: knitr\nparams:\n  my_serialized_class: NULL\n---\n\n```{r}\n#| echo: false\nr_class &lt;- unserialize(jsonlite::unserializeJSON(params$my_serialized_class))\n```\n\nImported one items: R6 class.  \nNumber of rows in data frame: `r nrow(r_class$data)`  \nNumber of items in list: `r length(r_class$list)`\n\nRendering the document leads to the expected output.\n\nparam_r6 &lt;- jsonlite::serializeJSON(serialize(r, connection = NULL))\nquarto::quarto_render(\"quarto_02.qmd\", execute_params = list(my_serialized_class = param_r6))"
  },
  {
    "objectID": "posts/2024/2024-02-02-passing_R6_quarto/index.html#performance",
    "href": "posts/2024/2024-02-02-passing_R6_quarto/index.html#performance",
    "title": "Passing and R6 Class to Quarto",
    "section": "Performance",
    "text": "Performance\nTimes to render (including serializing and deserializing) are shown below. Surprisingly passing the R6 class was faster than than the data frame.\n\n\n\ndescription\ntime (secs)\n\n\n\n\ndata frame and list, no serialization\n9.0\n\n\ndata frame and list, data frame serialized\n13.9\n\n\nR6 class, serialized\n5.4\n\n\n\nThe effect is even more pronounced as the quantity of data increases. When n_row is increased 10-fold to 10000, the times become:\n\n\n\ndescription\ntime (secs)\n\n\n\n\ndata frame and list, no serialization\n43.5\n\n\ndata frame and list, data frame serialized\n80.3\n\n\nR6 class, serialized\n14.3"
  },
  {
    "objectID": "posts/2024/2024-02-02-passing_R6_quarto/index.html#conclusion",
    "href": "posts/2024/2024-02-02-passing_R6_quarto/index.html#conclusion",
    "title": "Passing and R6 Class to Quarto",
    "section": "Conclusion",
    "text": "Conclusion\nComplex objects, such as R6 classes, can be used in parameterized Quarto documents if properly serialized. Passing a serialized R6 class is more efficient than passing an equivalent data frame / list combination."
  },
  {
    "objectID": "posts/2024/2024-04-28-fun_with_R6_classes/index.html",
    "href": "posts/2024/2024-04-28-fun_with_R6_classes/index.html",
    "title": "Fun With R6 Classes",
    "section": "",
    "text": "R has several object-oriented systems and I’m a big fan of R6. Detailed below is a specific use-case. I wanted a parent class that held a list of child classes with thet specification that the child class instances could update the parent class instance."
  },
  {
    "objectID": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#parent-class",
    "href": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#parent-class",
    "title": "Fun With R6 Classes",
    "section": "Parent Class",
    "text": "Parent Class\nThe parent class is shown below along with a table detailing the public and private fields and methods. the purpose of the parent class is to hold a series of steps along with methods to interact with them. In addition, the parent class has a private field called accumulator which we will update from the child classes.\n\n\n\n\n\n\n\n\npublic/private\nfield/method\ndescription\n\n\n\n\npublic\nname\na label\n\n\npublic\ninitialize()\ncreate a new instance\n\n\npublic\nupdate(n)\nupdate the accumulator by n (default n = 1)\n\n\npublic\ncount()\nreturn the value of the accumulator\n\n\npublic\nadd(step)\nadd a new step to the parent class (steps are child classes)\n\n\npublic\nrun()\nexecute all the steps (child classes)\n\n\npublic\nstatus()\nreturn the status of each step\n\n\npublic\naccumulator\nan accumulator, intially set to 0\n\n\nprivate\nsteps\nlist of steps\n\n\n\n\n#' R6 parent class\nparent_class &lt;- R6::R6Class(\n  \"parent_class\",\n  public = list(\n    \n    #' @field name Class label\n    name = \"\",\n    \n    #' @description\n    #' Initialize the class\n    initialize = function(name) {\n      self$name = name\n      invisible(self)\n    },\n    \n    #' @description\n    #' Update accumulator by value\n    update = function(n = 1) {\n      private$accumulator &lt;- private$accumulator + n\n    },\n    \n    #' @description\n    #' Return the value of the accumulator\n    count = function() {\n      return(private$accumulator)\n    },\n    \n    #' @description\n    #' Add a new step\n    #' @param step type of step to add\n    add = function(step) {\n      new_name &lt;- paste0(sample(LETTERS, size = 8), collapse = \"\")\n      new_step &lt;- get(step)$new(name = new_name)\n      private$steps[[new_name]] &lt;- new_step\n    },\n    \n    #' @description\n    #' Run the steps\n    run = function() {\n      for (s in private$steps) {\n        s$execute(parent = self)\n      }\n    },\n    \n    #' @description\n    #' Return status of steps\n    status = function() {\n      lapply(private$steps, function(s) {\n        list(name = s$name, value = s$val, status = s$status)\n      }) |&gt; dplyr::bind_rows()\n    }\n    \n  ),\n  \n  private = list(\n    accumulator = 0,\n    steps = list()\n  )\n)"
  },
  {
    "objectID": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#child-class---generic",
    "href": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#child-class---generic",
    "title": "Fun With R6 Classes",
    "section": "Child Class - Generic",
    "text": "Child Class - Generic\nFor child classes we first build a generic class that can manage any function that is common across the child classes. We can then use the property of inheritance so that the generic child class methods are available for all child classes, adding any specific methods. The generic class is shown below along with a list of public fields and methods.\n\n\n\n\n\n\n\nfield/method\ndescription\n\n\n\n\nname\na label\n\n\nval\nnumeric to store a class value (intial = NA)\n\n\nstatus\nstatus notification - possible values are initialized and run\n\n\ninitialize()\ncreate a new instance\n\n\nexecute()\nexecute the class - set val equal to parent$count() and change status to run\n\n\n\n\nchild_class &lt;- R6::R6Class(\n  \"child_class\",\n  public = list(\n    \n    #'  @field name class label\n    name = NULL,\n    \n    #' @field val class value\n    val = NA,\n    \n    #' @field status class status\n    status = \"initialized\",\n    \n    #' @description\n    #' Initialize class\n    initialize = function(name) {\n      self$name &lt;- name\n    },\n    \n    #' @description\n    #' Execute the class.  Set internal value equal to the\n    #'     parent class `accumulator`\n    #' @param parent Parent class\n    execute = function(parent) {\n      self$val &lt;- parent$count()\n      self$status &lt;- \"run\"\n    }\n  )\n)"
  },
  {
    "objectID": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#child-class---child-classes",
    "href": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#child-class---child-classes",
    "title": "Fun With R6 Classes",
    "section": "Child Class - Child Classes",
    "text": "Child Class - Child Classes\nWe define two child classes. The first increases the parent accumulator field by one, and the second doubles it. Each child class inherits the generic class to avoid repetition. The only change from the generic class is the public execute() method.\n\n\n\n\n\n\n\nfield/method\ndescription\n\n\n\n\nexecute()\nexecute the class - set val equal to parent$count(), change parent accumulator according to the step, and change status to run\n\n\n\n\nstep_add_one &lt;- R6::R6Class(\n  \"step_add_one\",\n  \n  inherit = child_class,\n  \n  public = list(\n    \n    #' @description\n    #' Execute the class.  Set internal value equal to the\n    #'     parent class `accumulator` and increase the parent\n    #'     class `accumulator` by 1.\n    #' @param parent Parent class\n    execute = function(parent) {\n      self$val &lt;- parent$count()\n      parent$update()\n      self$status &lt;- \"run\"\n    }\n  )\n)\n\n\nstep_double &lt;- R6::R6Class(\n  \"step_double\",\n  \n  inherit = child_class,\n  \n  public = list(\n    \n    #' @description\n    #' Execute the class.  Set internal value equal to the\n    #'     parent class `accumulator` and multiply the parent\n    #'     class `accumulator` by 2.\n    #' @param parent Parent class\n    execute = function(parent) {\n      self$val &lt;- parent$count()\n      parent$update(n = parent$count())\n      self$status &lt;- \"run\"\n    }\n  )\n)"
  },
  {
    "objectID": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#execution",
    "href": "posts/2024/2024-04-28-fun_with_R6_classes/index.html#execution",
    "title": "Fun With R6 Classes",
    "section": "Execution",
    "text": "Execution\n\n# initialize the parent class\nmy_parent &lt;- parent_class$new('parent class')\n\n# step_add_one - add a single number to the counter\nmy_parent$add('step_add_one')\nmy_parent$add('step_add_one')\n\n# step_double - double the counter\nmy_parent$add('step_double')\nmy_parent$add('step_double')\n\n# return the counter value\nmy_parent$count() \n\n[1] 0\n\n\n\n# print the status of each step\nmy_parent$status() \n\n# A tibble: 4 × 3\n  name     value status     \n  &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt;      \n1 UWDIGVYP NA    initialized\n2 WXYRAUTM NA    initialized\n3 PKBNVDQW NA    initialized\n4 QLAVHOKG NA    initialized\n\n\n\n# run - execute each step in turn\nmy_parent$run()\n\n# return the counter value\nmy_parent$count()\n\n[1] 8\n\n\n\n# print the status of each step\nmy_parent$status()\n\n# A tibble: 4 × 3\n  name     value status\n  &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; \n1 UWDIGVYP     0 run   \n2 WXYRAUTM     1 run   \n3 PKBNVDQW     2 run   \n4 QLAVHOKG     4 run   \n\n\nRunning the code above creates a parent class instance called my_parent. Four steps are added to the parent class (step_add_one twice and step_double twice). At this point, the accumulator (my_parent$count()) is 0 and my_parent$status() shows all steps are initialized as no steps have been executed. After my_parent$run() is run and all steps executed, the accumulator is 8 (add 1, add 1, double, double) and my_parent$status() shows all steps are run.\nThe accumulator is a field in the parent and it is updated through the child classes."
  },
  {
    "objectID": "posts/2024/2024-06-09-plotly_group_select/index.html",
    "href": "posts/2024/2024-06-09-plotly_group_select/index.html",
    "title": "Selectable Groups in Plotly",
    "section": "",
    "text": "This is a short tutorial on building a plotly stripchart with a dropdown to select a dataset. It covers a few points such as how to handle stripcharts with jitter in plotly, building the plotly menu programatically and how to format a dataset to work with plotly dropdowns.\nOf course, the same effect can be accomplished with a selectizeInput in shiny but this method does not rely on the use of a server 1 and can be embedded in an HTML report."
  },
  {
    "objectID": "posts/2024/2024-06-09-plotly_group_select/index.html#generating-some-dummy-data",
    "href": "posts/2024/2024-06-09-plotly_group_select/index.html#generating-some-dummy-data",
    "title": "Selectable Groups in Plotly",
    "section": "Generating Some Dummy Data",
    "text": "Generating Some Dummy Data\nFirst, we build some dummy data for the plots.\n\n## build a data frame for demo\ndf &lt;- data.frame(\n  id = rep(seq(30), 3),\n  group_name = rep(rep(c(\"A\", \"B\", \"C\"), each = 10), 3),\n  time = rep(paste(\"Time\", seq(3)), each = 30),\n  value = lapply(seq(9), function(x) runif(min=x, max=x+1, n=10)) |&gt; unlist()\n) |&gt; \n  dplyr::mutate(group_name = as.factor(group_name))\n\nhead(df)\n\n  id group_name   time    value\n1  1          A Time 1 1.704949\n2  2          A Time 1 1.663189\n3  3          A Time 1 1.104930\n4  4          A Time 1 1.380122\n5  5          A Time 1 1.334283\n6  6          A Time 1 1.426187"
  },
  {
    "objectID": "posts/2024/2024-06-09-plotly_group_select/index.html#programatically-building-plotly-dropdown",
    "href": "posts/2024/2024-06-09-plotly_group_select/index.html#programatically-building-plotly-dropdown",
    "title": "Selectable Groups in Plotly",
    "section": "Programatically Building Plotly Dropdown",
    "text": "Programatically Building Plotly Dropdown\nChanging a dataset interactively in plotly is not as straightforward as a shiny approach of linking a selectizeInput to a parameter. Plotly’s approach requires passing all data to the plot and toggling visibility. The updatemenus parameter in plotly::layout() is used to build menus (see https://plotly.com/r/dropdowns/).\nThe examples on the plotly site show how to restyle a graph, passing a series of parameters through updatemenus. updatemenus itself is a list and can therefore be built programatically. The code below shows how we can build the UI and logic required to select one of the three values of time in our dataset.\n\n## identify the unique values in the time column\ntime_vals &lt;- df$time |&gt; \n  unique() |&gt; \n  sort()\n\n## count the number of values for each time\nv_time_group &lt;- df |&gt;\n  dplyr::select(time, group_name) |&gt;\n  dplyr::distinct() |&gt;\n  dplyr::arrange(time) |&gt;\n  dplyr::group_by(time) |&gt;\n  dplyr::summarise(count = dplyr::n()) |&gt;\n  dplyr::pull(count)\n\n## build a set of vectors to send to updatemenus.\n## each member is a set of TRUE/FALSE values denoting visibility.\nTF_time_vals &lt;- lapply(seq(length(v_time_group)), function(i) {\n  if (i == 1) {\n    values_false_start &lt;- 0\n  } else {\n    values_false_start &lt;- sum(v_time_group[1:(i-1)])\n  }\n\n  if (i == length(v_time_group)) {\n    values_false_end &lt;- 0\n  } else {\n    values_false_end &lt;- sum(v_time_group[(i+1):length(v_time_group)])\n  }\n  c(rep(FALSE, values_false_start), rep(TRUE, v_time_group[i]), rep(FALSE, values_false_end))\n})\n\n\n### OUTPUTS for updatemenus\ntime_vals\n\n[1] \"Time 1\" \"Time 2\" \"Time 3\"\n\nTF_time_vals\n\n[[1]]\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n[[2]]\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\n[[3]]\n[1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n\nThe updatemenus list is built using the code below. Essentially it is a list of a label, for each time point, and vector of boolean values denoting visibility, for each group at each time point. It should be noted that each vector for visibility has nine values denoting the three groups (A, B and C) at the three time points (Time 1, Time 2 and Time 3). In the first, TF_time_vals[[1]], we specify that all three groups are visible for Time 1 but not Time 2 or Time 3.\n\nupdate_menus_buttons &lt;- lapply(seq_along(time_vals), function(i) {\n  list(method = \"update\",\n       args = list(list(visible = TF_time_vals[[i]])),\n       label = time_vals[i]\n  )\n})"
  },
  {
    "objectID": "posts/2024/2024-06-09-plotly_group_select/index.html#build-the-chart",
    "href": "posts/2024/2024-06-09-plotly_group_select/index.html#build-the-chart",
    "title": "Selectable Groups in Plotly",
    "section": "Build the Chart",
    "text": "Build the Chart\nIf we build our plot, passing all data at once, the dropdown menu logic fails. This is because plotly expects a series of separate traces for the dropdown menu.\nTherefore this code will not work:\np &lt;- plotly::plot_ly(\n  data = df, x = ~jitter(as.numeric(group_name)), y = ~value, type = \"scatter\", mode = \"markers\", color = ~group_name\n)\n\np\n\n\nBut this will:\n## start with an empty plotly object\np &lt;- plotly::plot_ly(data = df)\n\nfor (t in time_vals) {\n  d &lt;- df |&gt; dplyr::filter(time == t)\n  p &lt;- p |&gt;\n    plotly::add_trace(data = d,\n                      x = ~jitter(as.numeric(group_name)),\n                      y = ~value,\n                      type = 'scatter', mode = 'markers',\n                      color = ~group_name, visible = t==time_vals[1])\n}\n\np\n\n\nSince we’ll be selecting by time, we neede to create a separate trace, one for each time. A small amount of jitter is added to the x values. This is achieved by taking the numeric value of group_name (a factor) and applying the base R jitter() function. A caveat to this approach is that the x-axis value are now numeric as opposed to the group name. Initial visibility is defined as t==time_vals[1], which will take the first value in the time_vals vector, namely Time 1.\nFinally, we add some axis labels and dropdown, and return the plot.\np &lt;- p |&gt; plotly::layout(\n  xaxis = list(title = \"Group\", showticklabels = FALSE, showgrid = FALSE),\n  yaxis = list(title = \"Values\"))\n\np &lt;- p |&gt; plotly::layout(\n  updatemenus = list(\n    list(x = 0.1, y = 1.1, buttons = update_menus_buttons)\n  )\n)\n\np"
  },
  {
    "objectID": "posts/2024/2024-06-09-plotly_group_select/index.html#footnotes",
    "href": "posts/2024/2024-06-09-plotly_group_select/index.html#footnotes",
    "title": "Selectable Groups in Plotly",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nshiny apps can now be built server-free using webR.↩︎"
  },
  {
    "objectID": "posts/2024/2024-10-15-comparing_numerics/index.html",
    "href": "posts/2024/2024-10-15-comparing_numerics/index.html",
    "title": "Testing for a Float in a Vector",
    "section": "",
    "text": "Equality between floating points is always challening when programming (see https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems). One way to determine if two numbers are equal is to set a precision. In this short snippet I create a function (%noVwithin%) to determine if a number exists in a vector of floating point numbers. The function is then vectorized so that it can be used in tidyverse expressions."
  },
  {
    "objectID": "posts/2024/2024-10-15-comparing_numerics/index.html#function---novwithin",
    "href": "posts/2024/2024-10-15-comparing_numerics/index.html#function---novwithin",
    "title": "Testing for a Float in a Vector",
    "section": "Function - %noVwithin%",
    "text": "Function - %noVwithin%\n\nprecision &lt;- 1e-10\n\n`%noVwithin%` &lt;- function(x, y) {\n  any(\n    sapply(y, function(z) {\n      abs(x - z) &lt;= precision\n    })\n  )\n}\n\nThe function %noVwithin% takes two variables, checking to see if x is within the vector y. It is similar to the R function %in% but works with floating point numbers. The example below illustrates both %in% and %noVwithin%\n\na &lt;- 0.8\nb &lt;- 0.4\nval &lt;- a + b\n\nprint(val %in% c(1.1, 1.2, 1.3))\n\n[1] FALSE\n\nprint(val %noVwithin% c(1.1, 1.2, 1.3))\n\n[1] TRUE"
  },
  {
    "objectID": "posts/2024/2024-10-15-comparing_numerics/index.html#vectorizing-the-function",
    "href": "posts/2024/2024-10-15-comparing_numerics/index.html#vectorizing-the-function",
    "title": "Testing for a Float in a Vector",
    "section": "Vectorizing the Function",
    "text": "Vectorizing the Function\nOur function works but fails when used in a tidyverse pipe:\n\nd &lt;- tibble::tibble(\n  a = seq(0.1, 0.5, 0.1),\n  b = seq(1.1, 1.5, 0.1), \n  val = a + b\n)\n\nprint(d)\n\n# A tibble: 5 × 3\n      a     b   val\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1   0.1   1.1   1.2\n2   0.2   1.2   1.4\n3   0.3   1.3   1.6\n4   0.4   1.4   1.8\n5   0.5   1.5   2  \n\nmyVals &lt;- seq(1, 1.6, 0.2)\nprint(myVals)\n\n[1] 1.0 1.2 1.4 1.6\n\nd |&gt;\n  dplyr::mutate(in_myVals = val %noVwithin% myVals)\n\n# A tibble: 5 × 4\n      a     b   val in_myVals\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;    \n1   0.1   1.1   1.2 TRUE     \n2   0.2   1.2   1.4 TRUE     \n3   0.3   1.3   1.6 TRUE     \n4   0.4   1.4   1.8 TRUE     \n5   0.5   1.5   2   TRUE     \n\n\nHere, val is identified as present in myVals even when it is not.\nVectorizing is simple. We just pass the function to Vectorize(), passing a list of argument names that we wish to vectorize. In this case we are passing just the x variable as y is fixed when calling.\n\n`%within%` &lt;- Vectorize(`%noVwithin%`, vectorize.args = \"x\")\n\nOur new function, %within%, is the vectorized version. Running the code above with %within% gives the expected result.\n\nd |&gt;\n  dplyr::mutate(in_myVals = val %within% myVals)\n\n# A tibble: 5 × 4\n      a     b   val in_myVals\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;    \n1   0.1   1.1   1.2 TRUE     \n2   0.2   1.2   1.4 TRUE     \n3   0.3   1.3   1.6 TRUE     \n4   0.4   1.4   1.8 FALSE    \n5   0.5   1.5   2   FALSE"
  },
  {
    "objectID": "posts/2024/2024-10-15-comparing_numerics/index.html#using-the-in-function",
    "href": "posts/2024/2024-10-15-comparing_numerics/index.html#using-the-in-function",
    "title": "Testing for a Float in a Vector",
    "section": "Using the %in% Function",
    "text": "Using the %in% Function\nRunning the above code with the base R %in% function (which, like many base R functions, is vectorized) in place of %within% produces an interesting output:\n\nd |&gt;\n  dplyr::mutate(in_myVals = val %in% myVals)\n\n# A tibble: 5 × 4\n      a     b   val in_myVals\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;    \n1   0.1   1.1   1.2 FALSE    \n2   0.2   1.2   1.4 FALSE    \n3   0.3   1.3   1.6 TRUE     \n4   0.4   1.4   1.8 FALSE    \n5   0.5   1.5   2   FALSE    \n\n\nEverything is false, as expected, except for 1.6. Looking at val and myVals illustrates why.\nHere are the values of val at 20 decimal places:\n\nd$val  |&gt; formatC(digits = 20, format = 'f')\n\n[1] \"1.20000000000000017764\" \"1.40000000000000013323\" \"1.60000000000000008882\"\n[4] \"1.80000000000000026645\" \"2.00000000000000000000\"\n\n\nand here are the values stored in the myVals vector:\n\nmyVals |&gt; formatC(digits = 20, format = 'f')\n\n[1] \"1.00000000000000000000\" \"1.19999999999999995559\" \"1.39999999999999991118\"\n[4] \"1.60000000000000008882\"\n\n\nIt’s interesting to note that both values for 1.6 (d[3, ]$val and myvals[4]) are identical, hence the %in% comparison works for 1.6."
  },
  {
    "objectID": "posts/2024/2024-10-15-comparing_numerics/index.html#alternative-approaches",
    "href": "posts/2024/2024-10-15-comparing_numerics/index.html#alternative-approaches",
    "title": "Testing for a Float in a Vector",
    "section": "Alternative approaches",
    "text": "Alternative approaches\n\ndplyr::rowwise()\nThe non-vectorized version works when used in conjunction with dplyr::rowwise() as rowwise computes one row at a time.\n\nd |&gt;\n  dplyr::rowwise() |&gt;\n  dplyr::mutate(in_myVals = val %noVwithin% myVals)\n\n# A tibble: 5 × 4\n# Rowwise: \n      a     b   val in_myVals\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;    \n1   0.1   1.1   1.2 TRUE     \n2   0.2   1.2   1.4 TRUE     \n3   0.3   1.3   1.6 TRUE     \n4   0.4   1.4   1.8 FALSE    \n5   0.5   1.5   2   FALSE    \n\n\n\n\npurrr::map\nThe purrr::map() functions can work with non-vectorized functions within a mutate().\n\nd |&gt;\n  dplyr::mutate(in_myVals = purrr::map_lgl(val, `%noVwithin%`, myVals))\n\n# A tibble: 5 × 4\n      a     b   val in_myVals\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;    \n1   0.1   1.1   1.2 TRUE     \n2   0.2   1.2   1.4 TRUE     \n3   0.3   1.3   1.6 TRUE     \n4   0.4   1.4   1.8 FALSE    \n5   0.5   1.5   2   FALSE"
  },
  {
    "objectID": "posts/2025/2025-01-13-gt_extensions/index.html",
    "href": "posts/2025/2025-01-13-gt_extensions/index.html",
    "title": "gt Extensions",
    "section": "",
    "text": "The {gt} package is a great R package for building tables and the outputs that can be generated, particularly in HTML, are stunning. The {gtExtras} pacakge, from Tom Mock, extends the functionality of {gt}. In developing a Quarto report, I found that I needed some tabular outputs that were not present in {gt}. Taking inspiration from {gtExtras}, here’s some code and explanation, on adding additional functions to {gt}."
  },
  {
    "objectID": "posts/2025/2025-01-13-gt_extensions/index.html#introduction",
    "href": "posts/2025/2025-01-13-gt_extensions/index.html#introduction",
    "title": "gt Extensions",
    "section": "",
    "text": "The {gt} package is a great R package for building tables and the outputs that can be generated, particularly in HTML, are stunning. The {gtExtras} pacakge, from Tom Mock, extends the functionality of {gt}. In developing a Quarto report, I found that I needed some tabular outputs that were not present in {gt}. Taking inspiration from {gtExtras}, here’s some code and explanation, on adding additional functions to {gt}."
  },
  {
    "objectID": "posts/2025/2025-01-13-gt_extensions/index.html#tldr",
    "href": "posts/2025/2025-01-13-gt_extensions/index.html#tldr",
    "title": "gt Extensions",
    "section": "TL/DR",
    "text": "TL/DR\nHere’s a quick illustration of the extensions discussed in the blog post.\n\n## table of dates\ndf_dates &lt;- tibble::tibble(\n  name = c(\"Alice\", \"Bob\", \"Carol\", \"Carol\", \"Dan\", \"Alice\", \"Bob\", \"Carol\", \"Carol\", \"Dan\", \"Alice\"),\n  var = c(rep(c(\"start\", \"end\"), each = 5), \"empty\"),\n  date = c(\"2024-10-05\", \"2024-10-13\", \"2024-09-10\", \"2024-11-11\", \"2024-10-01\", \"2025-01-03\", \"2024-12-20\", \"2025-01-04\", \"2024-12-20\", \"2025-01-10\", \"2024-12-05\")\n) |&gt;\n  tidyr::nest(dates = c(var, date))\n\n## table of employee details (inc. dates)\ndf &lt;- tibble::tibble(\n  name = c(\"Alice\", \"Bob\", \"Carol\", \"Dan\"),\n  level = c(\"Director\", \"VP\", \"Director\", \"Assoc Director\"),\n  division = c(\"HR\", \"sales\", \"sales\", \"HR\"),\n    notes = c(\"n/a\", \"n/a\", \"n/a\", \"Dan has been with us for 5 years\"),\n  projects = c(\"project 1;project 2;project 3\", \"project 2\", \"project 1;project 3\", \"project 2;project 3;project 4\"),\n  division_badge = c(\"HR\", \"sales\", \"sales\", \"HR\"),\n  alert = c(TRUE, TRUE, FALSE, FALSE)\n) |&gt;\n  dplyr::left_join(df_dates, by = \"name\")\n\n## create gt table\ndf |&gt;\n  gt::gt() |&gt; \n  gt_subtitle(col_title = name, col_subtitle = level, col_parenthesis = division, col_tootlip = notes) |&gt;\n  gt_dots(projects, items = c(\"project 1\", \"project 2\", \"project 3\", \"project 4\"), sep = \";\", tooltip = TRUE) |&gt;\n  gt_alert(alert) |&gt;\n  gt_badge(division_badge, palette = c(HR = \"#2244CC\", sales = \"#22CC44\")) |&gt;\n  gt_timeline(dates, min_date = \"2024-09-01\", max_date = \"2025-01-13\", palette = c(start = \"#00AA00\", end = \"#AA0000\"))\n\n\n\nHelper FunctionBadgesAlertsDotsSubtitle StackTimeline\n\n\n\n.gtIndex()\nThe gt_index() function is a useful function lifted from the {gtExtras} package. It returns the underlying data of a column and is used extensively in gtExtras functions. Rather than rely on a dependence to {gtExtras} I’ve extracted the function, included here as .gtindex().\n\n#' gtindex taken from gtExtras package\n#'\n.gtindex &lt;- function(gt_object, column, as_vector = TRUE) {\n  stopifnot(\"'gt_object' must be a 'gt_tbl', have you accidentally passed raw data?\" = \"gt_tbl\" %in% class(gt_object))\n  stopifnot(\"'as_vector' must be a TRUE or FALSE\" = is.logical(as_vector))\n\n  if (length(gt_object[[\"_row_groups\"]]) &gt;= 1) {\n    # if the data is grouped you need to identify the group column\n    # and arrange by that column. I convert to a factor so that the\n    # columns don't default to arrange by other defaults\n    #  (ie alphabetical or numerical)\n    gt_row_grps &lt;- gt_object[[\"_row_groups\"]]\n\n    grp_vec_ord &lt;- gt_object[[\"_stub_df\"]] |&gt;\n      dplyr::mutate(group_id = factor(group_id, levels = gt_row_grps)) |&gt;\n      dplyr::arrange(group_id) |&gt;\n      dplyr::pull(rownum_i)\n\n    df_ordered &lt;- gt_object[[\"_data\"]] |&gt;\n      dplyr::slice(grp_vec_ord)\n  } else {\n    # if the data is not grouped, then it will just \"work\"\n    df_ordered &lt;- gt_object[[\"_data\"]]\n  }\n\n  # return as vector or tibble in correct, gt-indexed ordered\n  if (isTRUE(as_vector)) {\n    df_ordered |&gt;\n      dplyr::pull({{ column }})\n  } else {\n    df_ordered\n  }\n}\n\n\n\n\n\ngt_badge\nthis first function simply replaces a column with colored badges. {gtExtras} includes a gt_badge() function itself but\n\nFor some reason it’s missing from the pkgdown site so I did not know it existed.\nI required additional functionality - for example, the ability to work with missing data.\nIt was a good first example to sink my teeth into.\n\nThe function is shown below followed by some explanatory text.\n\n#' Add a badge based on values\n#'\n#' This function differs from gtExtras::gt_badge() in that it accounts for values\n#'     missing in the color palette and missing in the data.  Those missing in the\n#'     color palette are displayed as a white badge with grey border and those missing\n#'     in the data are represented as an empty white badge.\n#'\n#' @param gt_object An existing gt object\n#' @param column The column to convert to dots\n#' @param palette Named vector of values and colors. \n#' \n#' @export\n#'\ngt_badge &lt;- function(gt_object, column, palette = c()) {\n  stopifnot(\"Table must be of class 'gt_tbl'\" = \"gt_tbl\" %in% class(gt_object))\n\n  cell_contents &lt;- .gtindex(gt_object, {{ column }})\n\n  gt::text_transform(\n    gt_object,\n    locations = gt::cells_body(columns = {{ column }}),\n    fn = function(x) {\n      purrr::map(cell_contents, function(y) {\n        if (is.na(y)) {\n          '&lt;span class = \"gtbadge gtbadge-empty\"&gt;none&lt;/span&gt;'\n        } else if (y %in% names(palette)) {\n          glue::glue('&lt;span class = \"gtbadge\" style = \"background-color: {palette[y]};\"&gt;{y}&lt;/span&gt;')\n        } else {\n          glue::glue('&lt;span class = \"gtbadge gtbadge-clear\"&gt;{y}&lt;/span&gt;')\n        }\n      })\n    }\n  ) |&gt;\n    gt::opt_css(\n      css = \"\n        .gtbadge {\n          display: inline-block;\n          color: #ffffff;\n          min-width: 30px;\n          padding: 2px 4px;\n          text-align: center;\n          border-radius: 7px;\n          font-size: .8em;\n        }\n        .gtbadge-empty {\n          background-color: #ffffff;\n          border: 1px solid #dddddd;\n        }\n        .gtbadge-clear {\n          background-color: #ffffff;\n          color: #999999;\n          border: 1px solid #dddddd;\n        }\n      \"\n    )\n}\n\nFirst we capture the contents of column by using the .gtindex() function:\ncell_contents &lt;- .gtindex(gt_object, {{ column }}) - return the contents of column column as a vector (this function is taken from {gtExtras}).\nNext, gt::text_transform() is used to replace the data in column with new values returned by a function. gt::text_transform() is a powerful function that takes three arguments: a gt table, locations for transformation (in this case a column identifier) and a function that returns a character vector the same length as the column entries. Here, our function iterates over cell_contents, the vector of data in column and returns a badge. Badges are colored according to a palette passed to gt_badge(), accounting for values missing in the palette as well as empty values.\nFinally, the output from gt::text_transform() is formatted by declaring the column as markdown and adding css classes.\n\n\nExample Output\n\ndf &lt;- data.frame(ref = seq(1:5), data = c(\"badge_1\", \"badge_2\", \"badge_1\", NA, \"badge_3\"))\ndf |&gt; gt::gt() |&gt; gt_badge(data, palette = c(badge_1 = \"#990000\", badge_2 = \"#009900\"))\n\n\n\n\n\n\n\nref\ndata\n\n\n\n\n1\nbadge_1\n\n\n2\nbadge_2\n\n\n3\nbadge_1\n\n\n4\nnone\n\n\n5\nbadge_3\n\n\n\n\n\n\n\n\n\n\n\ngt_alert()\nThis is another simple example. Here an icon is returned in a column based on TRUE/FALSE values.\n\n#' Replace a logical column with an alert indicator\n#'\n#' Replace TRUE values with an empty circle and any other values with a red exclamation\n#'     mark in a circle.  Setting `invert`=TRUE reverses this behavior.\n#'\n#' @param gt_object An existing gt object\n#' @param column The column to convert to dots\n#' @param invert If TRUE then invert the response so that TRUE = alert.  Default is FALSE\n#'\n#' @export\n#'\ngt_alert &lt;- function(gt_object, column, invert = FALSE) {\n  stopifnot(\"Table must be of class 'gt_tbl'\" = \"gt_tbl\" %in% class(gt_object))\n\n  cell_contents &lt;- .gtindex(gt_object, {{ column }})\n\n  gt::text_transform(\n    gt_object,\n    locations = gt::cells_body(columns = {{ column }}),\n    fn = function(x) {\n      purrr::map(cell_contents, function(y) {\n        true_val &lt;- isTRUE(y)\n        if (invert == TRUE) {\n          true_val &lt;- !true_val\n        }\n        if (true_val) {\n          fontawesome::fa(\"circle\", fill = \"#cccccc\")\n        } else {\n          fontawesome::fa(\"circle-exclamation\", fill = \"#990000\")\n        }\n      })\n    }\n  ) |&gt;\n    gt::fmt_markdown(columns = {{ column }})\n}\n\n\n\nExample Output\n\ndf &lt;- data.frame(ref = seq(1:5), data = c(TRUE, FALSE, NA, TRUE, FALSE))\ndf |&gt; gt::gt() |&gt; gt_alert(data, invert = TRUE)\n\n\n\n\n\n\n\n\n\n\n\nref\ndata\n\n\n\n\n1\n\n\n\n\n\n2\n\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngt_dots()\nThis function displays a vector of values as colored dots. It’s useful for groups containing multiple categorical values. Column data may be input through a list column, eg list(c(“A”, “B”, “C”)) or character-separated, eg “A,B,C”. gt_dots() also introduces the use of tooltips. Code explanation and an example follow below.\n\n#' Replace a column with a series of colored dot rows\n#'\n#' @param gt_object An existing gt object\n#' @param column The column to convert to dots\n#' @param items Vector of values for dots.  This represents all of the possible dots in\n#'     order\n#' @param sep Optional separation character.  If NULL (default) then it is assumed that\n#'     column `column` is a list column containing vectors where the member of each vector\n#'     can be a value in `items`.  For example, if `items` is c(\"A\", \"B\", \"C\") then `column`\n#'     could contain data such as \"A\" or c(\"A\", \"B\").  If a `sep` is a character then column\n#'     `column` should be a character vector with values separated by `sep`.  For example, if\n#'     `items` is c(\"A\", \"B\", \"C\") and `sep` is \";\" then `column` could contain data such as\n#'     \"A\" or \"A;B\".\n#' @param tooltip If TRUE then add a tooltip indicating the active values\n#'    \n#' @return gt table\n#'\n#' @export\n#'\ngt_dots &lt;- function(gt_object, column, items = c(), sep = NULL, tooltip = FALSE) {\n  stopifnot(\"Table must be of class 'gt_tbl'\" = \"gt_tbl\" %in% class(gt_object))\n  \n  cell_contents &lt;- .gtindex(gt_object, {{ column }})\n  \n  pal &lt;- colorRampPalette(c(\"#89CFF1\", \"#003A6B\"))\n  cols &lt;- pal(length(items))\n  l_dots &lt;- lapply(seq_along(items), function(i) {\n    fontawesome::fa(\"fas fa-circle\", fill = cols[i], margin_left = '.05em', margin_right = '.05em')\n  }) |&gt;\n    setNames(items)\n  blank &lt;- fontawesome::fa(\"far fa-circle\", fill = \"#cccccc\", margin_left = '.05em', margin_right = '.05em')\n  \n  col_name &lt;- rlang::quo_name(rlang::quo({{column}}))\n  width_val &lt;- length(items) * 1.1 + 1\n  colwidth &lt;- as.formula(paste0(col_name, \" ~ '\", width_val, \"em'\"))\n  \n  gt::text_transform(\n    gt_object,\n    locations = gt::cells_body(columns = {{ column }}),\n    fn = function(x) {\n      lapply(cell_contents, function(y) {\n        \n        # split to create a vector\n        if (!is.null(sep)) {\n          y &lt;- unlist(strsplit(y, sep, fixed = TRUE))\n        }\n        \n        # find matches\n        dot_matches &lt;- match(y, items)\n        dots &lt;- rep(blank, times = length(items))\n        if (!is.na(dot_matches[1])) {\n          for (i in dot_matches) {\n            dots[i] &lt;- l_dots[[i]]\n          }\n        }\n        \n        output_dots &lt;- paste(dots, collapse = \"\")\n        \n        if (tooltip == TRUE) {\n          if (!is.na(dot_matches[1])) {\n            tooltip_text &lt;- paste(items[dot_matches], collapse = \", \")\n          } else {\n            tooltip_text &lt;- NA\n          }\n          \n          glue::glue(\n            \"&lt;div data-bs-toggle='tooltip' data-bs-placement='right' data-bs-title=\\\"{tooltip_text}\\\"&gt;{output_dots}&lt;/div&gt;\"\n          )\n          \n        } else {\n          output_dots\n        }\n      })\n    }\n  ) |&gt;\n    gt::fmt_markdown(columns = {{ column }}) |&gt;\n    gt::cols_width(colwidth)\n}\n\nAt the beginning of the function we build a named vector of colors. We’ve hardcoded shades of blue but could easily pass the two color-extremes as parameters to gt_dots(). The output is l_dots, a named list of colored icons, and blank, an empty icon.\n  pal &lt;- colorRampPalette(c(\"#89CFF1\", \"#003A6B\"))\n  cols &lt;- pal(length(items))\n  l_dots &lt;- lapply(seq_along(items), function(i) {\n    fontawesome::fa(\"fas fa-circle\", fill = cols[i], margin_left = '.05em', margin_right = '.05em')\n  }) |&gt;\n    setNames(items)\n  blank &lt;- fontawesome::fa(\"far fa-circle\", fill = \"#cccccc\", margin_left = '.05em', margin_right = '.05em')\nThe next part of the code builds a formula defining the column width. The column width is defined by the number of dots. This keeps all the dots on a single line.\n  col_name &lt;- rlang::quo_name(rlang::quo({{column}}))\n  width_val &lt;- length(items) * 1.1 + 1\n  colwidth &lt;- as.formula(paste0(col_name, \" ~ '\", width_val, \"em'\"))\nFinally we run the gt::text_transform() function, looping over each vector of data. The output is a series of colored dots, corresponding to matches against a vector. If requested, a tootlip is added for each column cell.\n\n\n\n\n\n\nTooltips in Quarto\n\n\n\nNote, to use tooltips in a quarto HTML document, Bootstrap tooltips need to first be activated. This can be done by adding the following in the document’s yaml header:\ninclude-after-body:\n- text: \"&lt;script&gt;\\n  const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle=\\\"tooltip\\\"]')\\n\n    \\ const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl =&gt; new bootstrap.Tooltip(tooltipTriggerEl, {html: true}))\\n&lt;/script&gt;\\n\"\n\n\n\n\nExample Output\n\ndf &lt;- data.frame(ref = seq(1:5), data = c(\"p1,p2\", \"p1\", NA, \"p3\", \"p2,p3\"))\ndf |&gt; gt::gt() |&gt; gt_dots(data, items = c(\"p1\", \"p2\", \"p3\", \"p4\"), sep = \",\", tooltip = TRUE)\n\n\n\n\n\n\n\nref\ndata\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngt_subtitle()\nThis function is very similar to the {gtExtras} function gt_merge_stack(), taking two columns and stacking the text of the first above the second. This adds optional text in parenthesis (useful in the case of a grouping value or tag) and a tooltip. It demonstrates how a relatively simple function may be used to build some creative table columns.\n\n#' Add subtitle and tooltip to column\n#'\n#' This function is similar to gtExtras::gt_merge_stack().  It replaces the `col_title`\n#'     column with a formatted column that stacks `col_title` on top of `col_subtitle`. \n#'     The upper text is converted to small caps and the lower text is smaller and grey. \n#'     If `col_parenthesis` is included, values from an additional column are added to\n#'     the title in parenthesis.  This can be used to include a column grouping or tag.\n#'     If `col_tooltip` is included then values from this column will be used as data for\n#'     tooltips.  Output is returned in column `col_title` with columns `col_subtitle`,\n#'     `col_parenthesis` and `col_tooltip` removed.\n#'\n#' @param gt_object An existing gt object\n#' @param col_title The column holding the title\n#' @param col_subtitle The column holding the subtitle\n#' @param col_parenthesis Optional column holding data to be added in parentheses after\n#'     the title.  Often used to include a grouped column or tag\n#' @param col_tootlip Optional column holding data to be used as tooltip text\n#'\n#' @export\n#'\ngt_subtitle &lt;- function(gt_object, col_title, col_subtitle, col_parenthesis = NULL, col_tootlip = NULL) {\n  stopifnot(\"Table must be of class 'gt_tbl'\" = \"gt_tbl\" %in% class(gt_object))\n\n  col_subtitle_contents &lt;- .gtindex(gt_object, {{ col_subtitle }})\n  col_parenthesis_missing &lt;- rlang::quo_is_null(rlang::enquo(col_parenthesis))\n  col_tootlip_missing &lt;- rlang::quo_is_null(rlang::enquo(col_tootlip))\n\n  if (!col_parenthesis_missing) {\n    col_parenthesis_contents &lt;- .gtindex(gt_object, {{ col_parenthesis }})\n  }\n\n  if (!col_tootlip_missing) {\n    col_tootlip_contents &lt;- .gtindex(gt_object, {{ col_tootlip }})\n  }\n\n  rtn &lt;- gt::text_transform(\n    gt_object,\n    locations = gt::cells_body(columns = {{ col_title }}),\n    fn = function(x) {\n\n      if (!col_parenthesis_missing) {\n        txt &lt;- glue::glue(\"{x} ({col_parenthesis_contents})\")\n      } else {\n        txt &lt;- x\n      }\n      \n      if (!col_tootlip_missing) {\n        glue::glue(\n          \"&lt;div data-bs-toggle='tooltip' data-bs-placement='right' data-bs-title=\\\"{col_tootlip_contents}\\\"&gt;\n             &lt;div class='subtitle-top'&gt;\n               &lt;span&gt;{txt}&lt;/span&gt;\n             &lt;/div&gt;\n             &lt;div class='subtitle-bottom'&gt;\n               &lt;span&gt;{col_subtitle_contents}&lt;/span&gt;\n             &lt;/div&gt;\n           &lt;/div&gt;\"\n        )\n\n      } else {\n\n        glue::glue(\n          \"&lt;div class='subtitle-top'&gt;\n             &lt;span&gt;{txt}&lt;/span&gt;\n           &lt;/div&gt;\n           &lt;div class='subtitle-bottom'&gt;\n             &lt;span&gt;{col_subtitle_contents}&lt;/span&gt;\n           &lt;/div&gt;\"\n        )\n      }\n    }\n  ) |&gt;\n    gt::opt_css(\n      css = \"\n        .subtitle-top {\n          line-height:10px;\n          text-align:left;\n        }\n        .subtitle-top span {\n          font-weight: bold;\n          font-variant: small-caps;\n          font-size: 14px;\n        }\n        .subtitle-bottom {\n          line-height:12px;\n          text-align:left;\n        }\n        .subtitle-bottom span {\n          font-weight: bold;\n          color: grey;\n          font-size: 10px\n        }\n\n      \"\n    )\n\n  rtn &lt;- rtn  |&gt;\n    gt::cols_hide({{col_subtitle}})\n  if (!col_parenthesis_missing) {\n    rtn &lt;- rtn |&gt;\n      gt::cols_hide({{col_parenthesis}})\n  }\n  if (!col_tootlip_missing) {\n    rtn &lt;- rtn |&gt;\n      gt::cols_hide({{col_tootlip}})\n  }\n\n  rtn\n\n}\n\n\n\nExample Output\n\ndf &lt;- data.frame(name = c(\"Name 1\", \"Name 2\"), title = c(\"VP\", \"Chair\"), gp = c(\"AAA\", \"AAA\"), tt = c(\"First Person\", \"Second Person\"))\ndf |&gt; gt::gt() |&gt; gt_subtitle(col_title = name, col_subtitle = title, col_parenthesis = gp, col_tootlip = tt)\n\n\n\n\n\n\n\n\n\n\nname\n\n\n\n\n\n\nName 1 (AAA)\n\n\nVP\n\n\n\n\n\n\nName 2 (AAA)\n\n\nChair\n\n\n\n\n\n\n\n\n\n\n\n\n\ngt_timeline()\nThis function adds a timeline. Dates are plotted as markers along a time axis for each cell in a column. The dates are stored as tibbles for each row. The dates tibbles contain a var column for labels and a date column for dates. Dates can be color-coded by var and also include a hover to highlight var and date characteristics.\n\n#' Create a timeline\n#'\n#' Create a linear date line with markers representing dates.  The input column is\n#'     expected to be a list column of tibbles, each with a `var` column holding labels\n#'     and a `date` column holding dates.\n#'\n#' @param gt_object An existing gt object\n#' @param column The column to convert to a timeline\n#' @param min_date Minimum date (format = yyyy-mm-dd).  If missing then the minimum date\n#'     is determined from the data\n#' @param max_date Maximum date (format = yyyy-mm-dd).  If missing then the maximum date\n#'     is determined from the data\n#' @param palette Named vector of colors (optional).  If included then color named values\n#'     from the `var` column accordingly\n#' @param add_key If TRUE and a palette is included then include a color key as a table\n#'     footnote\n#'\ngt_timeline &lt;- function(gt_object, column, min_date = NULL, max_date = NULL, palette = c(), add_key = FALSE) {\n\n  stopifnot(\"Table must be of class 'gt_tbl'\" = \"gt_tbl\" %in% class(gt_object))\n\n  default_fill &lt;- \"#ADD8E6\"\n  if (length(palette) == 0) {\n    df_cols &lt;- tibble::tibble(var = character(), fill_color = character())\n  } else {\n    df_cols &lt;- tibble::enframe(palette, name = \"var\", value = \"fill_color\")\n  }\n\n  cell_contents &lt;- .gtindex(gt_object, {{ column }})\n\n  if (any(missing(min_date), missing(max_date))) {\n    v_times &lt;- cell_contents |&gt;\n      dplyr::bind_rows() |&gt;\n      dplyr::pull(date)\n    if (missing(min_date)) {\n      min_date &lt;- min(v_times)\n    }\n    if (missing(max_date)) {\n      max_date &lt;- max(v_times)\n    }\n  }\n\n  day_range &lt;- as.numeric(difftime(as.Date(max_date), as.Date(min_date), 'days'))\n  w &lt;- 150  # width\n\n  rtn &lt;- gt::text_transform(\n    gt_object,\n    locations = gt::cells_body(columns = {{ column }}),\n    fn = function(x) {\n\n      lapply(cell_contents, function(d) {\n\n        plt_d &lt;- d |&gt;\n          dplyr::mutate(days = as.numeric(difftime(as.Date(date), as.Date(min_date), 'days'))) |&gt;\n          dplyr::mutate(xval = w * days / day_range) |&gt;\n          dplyr::mutate(textanchor = dplyr::case_when(\n            xval &lt; 0.4 * w ~ \"start\",\n            xval &gt; 0.6 * w ~ \"end\",\n            .default = \"middle\"\n          )) |&gt;\n          dplyr::left_join(df_cols, by = \"var\") |&gt;\n          dplyr::mutate(fill_color = dplyr::if_else(is.na(fill_color), default_fill, fill_color))\n\n        svg_line &lt;- glue::glue('&lt;line x1=\"0\" y1=\"17\" x2=\"{w+10}\" y2=\"17\" style=\"stroke: #808080; stroke-width: 1\" /&gt;')\n\n        svg_pts &lt;- plt_d |&gt;\n          glue::glue_data('\n        &lt;g class = \"gttime\"&gt;\n        &lt;circle class=\"gttimedot\" cx=\"{xval+5}\" cy=\"17\" r=\"5\" stroke=\"#000\" stroke-width=\"1\" fill=\"{fill_color}\" /&gt;\n        &lt;text class=\"gttimelab\" x=\"{xval+5}\" y=\"9\" font-size=\".6em\" text-anchor=\"{textanchor}\"&gt;{var} ({date})&lt;/text&gt;\n        &lt;/g&gt;\n      ') |&gt;\n          glue::glue_collapse(sep = \"\")\n\n        glue::glue('&lt;svg width=\"{w+10}\" height=\"23\" xmlns=http://www.w3.org/2000/svg&gt;{svg_line}{svg_pts}&lt;/svg&gt;')\n        \n      })\n    }\n  ) |&gt;\n    gt::fmt_markdown(columns = {{ column }}) |&gt;\n    gt::opt_css(\n      css = \"\n        .gttime {\n          overflow: visible;\n        }\n        .gttimelab {\n          display: none;\n          overflow: visible;\n        }\n        .gttime:hover {\n           text {display: block;}\n        }\n      \"\n    )\n\n  if (add_key == TRUE & length(palette) &gt; 0) {\n\n    color_key &lt;- lapply(seq_along(palette), function(i) {\n      paste0(\"&lt;span style = 'margin-right: 15px'&gt;&lt;span style = 'margin-right: 5px'&gt;\", bsicons::bs_icon('circle-fill', color = palette[i]), \"&lt;/span&gt;&lt;span&gt;\", names(palette)[i], \"&lt;/span&gt;&lt;/span&gt;\")\n    }) |&gt;\n      paste(collapse = \"\")\n\n    color_key &lt;- paste0(\"&lt;span&gt;&lt;span style = 'margin-right: 20px;'&gt;Key:&lt;/span&gt;\", color_key, \"&lt;/span&gt;\")\n    \n    rtn &lt;- rtn |&gt;\n      gt::tab_footnote(footnote = gt::html(color_key), locations = gt::cells_column_labels({{column}}))\n\n  }\n\n  return(rtn)\n\n}\n\nThe function works by defining a variable day_range which is the number of days for the timeline (max - min). Next, each date is expressed as the fraction along the timeline multiplied by the width of the output. Cells are constructed by building up SVG graphics as follows:\n\nplot the timeline as a horizontal line just below the center of the cell\nfor each time point plot it on the timeline within a group of class gttime\nadd text for each timeline within the same group\n\nThe css added controls the visibility. Labels are initialized with display: none so they will be hidden. On hovering we set display: block so that the label is visible.\nHover labels are positioned so that if they fall in the first 40% of the timeline they are left-justified, if they fall in the last 40% of the timeline they are right-justified and if they fall in the middle 20% they are centered. This helps position labels within the timeline region, avoiding overflow.\n\n\nExample Output\n\ndf &lt;-  data.frame(ref = c(1, 1, 2, 2), \n                  var = c(\"start\", \"end\", \"start\", \"end\"), \n                  date = c(\"2024-10-04\", \"2024-12-05\", \"2024-10-25\", \"2024-12-07\")) |&gt;\n  tidyr::nest(dates = c(var, date))\n\ndf\n\n# A tibble: 2 × 2\n    ref dates           \n  &lt;dbl&gt; &lt;list&gt;          \n1     1 &lt;tibble [2 × 2]&gt;\n2     2 &lt;tibble [2 × 2]&gt;\n\n\n\ndf |&gt; gt::gt() |&gt; gt_timeline(dates, min_date = \"2024-10-01\", max_date = \"2024-12-31\", palette = c(start = \"#00AA00\", end = \"#AA0000\"))\n\n\n\n\n\n\n\n\n\n\n\nref\ndates\n\n\n\n\n1\n\n   start (2024-10-04)    end (2024-12-05) \n\n\n\n2\n\n   start (2024-10-25)    end (2024-12-07)"
  },
  {
    "objectID": "posts/2025/2025-04-03-testthat_covr/index.html",
    "href": "posts/2025/2025-04-03-testthat_covr/index.html",
    "title": "Running testthat within covr",
    "section": "",
    "text": "Tests and test coverage are important aspects when developing packages. {testthat} is an R package used to build and run tests and {covr} is an R package used to report code coverage, i.e. what percentage of a the code base is covered by tests. {testthat} will run the tests in a package and report testing results but does not report code coverage, whereas {covr} runs a package tests to calculate coverage but only returns the code coverage, not the test results themselves. In order to get test output and code coverage both have to be run, which means tests are run twice. As the number of tests grows this can become time-consuming.\nTypically, testing to gather output of tests, along with code coverage, might look something like:\nThere is, however, a way that both may be run together. By default, the covr::package_coverage() runs tools::testInstalledPackage() to calculate test coverage, but can use an alternative testing approach with the following syntax: covr::package_coverage(type = \"none\", code = \"my code\") where my code is the code run to perform the tests. By creating a user-defined reporter in {testthat} that sends output to a temporary file, covr::package_coverage() may be used to run both code coverage and return test output together."
  },
  {
    "objectID": "posts/2025/2025-04-03-testthat_covr/index.html#testing-the-approach",
    "href": "posts/2025/2025-04-03-testthat_covr/index.html#testing-the-approach",
    "title": "Running testthat within covr",
    "section": "Testing the Approach",
    "text": "Testing the Approach\nTo test, let’s create a simple function that takes 5 seconds to run:\nmyFunction &lt;- function(a = NULL) {\n  Sys.sleep(5)\n  return(a)\n}\nalong with a test that should pass without a problem:\ntest_that(\"my function works\", {\n  expect_equal(myFunction(\"A\"), \"A\")\n})\nExecuting testthat::test_local() takes approximately 5.5 seconds to run. Running covr::package_coverage() takes an additional 15 seconds. This leads to a total time of just over 20 seconds.\nRunning covr::package_coverage(type = \"none\", code = \"testthat::test_local(reporter = JSONReporter$new(file = 'test_results.json'), stop_on_warning = FALSE, stop_on_failure = FALSE)\") takes 15 seconds, returning package coverage along with the json file with the following contents:\n[\n  {\n    \"filename\": \"test-my_function.R\",\n    \"test_name\": \"my function works\",\n    \"pass\": true,\n    \"message\": \"myFunction(\\\"A\\\") (`actual`) not equal to \\\"A\\\" (`expected`).\\n\\n\"\n  }\n]\nBoth the coverage and test results may be parsed and returned using the following approach:\ncoverage_and_tests &lt;- function() {\n  tmp_file_test &lt;- tempfile(fileext = \".json\")\n  coverage_raw &lt;- covr::package_coverage(system.file(package = \"testPackage\"), type = 'none', code = glue::glue('testthat::test_package(\"testPackage\", reporter = JSONReporter$new(file = \"{tmp_file_test}\"), stop_on_warning = FALSE, stop_on_failure = FALSE)'))\n  coverage &lt;- capture.output(coverage_raw, type = \"message\")\n  df_tests &lt;- jsonlite::read_json(tmp_file_test, simplifyVector = TRUE)\n  unlink(tmp_file_test)\n  df_coverage &lt;- data.frame(\n    file = sub(\":.*\", \"\", coverage),\n    coverage = sub(\".*: ([0-9.]+)%\", \"\\\\1\", coverage)\n  )\n  return(list(coverage = df_coverage, tests = df_tests))\n}\nleading to the following output:\ncoverage_and_tests()\n$coverage\n                  file coverage\n1 testPackage Coverage   100.00\n2      R/my_function.R   100.00\n\n$tests\n            filename         test_name pass                                                        message\n1 test-my_function.R my function works TRUE  myFunction(\"A\") (`actual`) not equal to \"A\" (`expected`).\\n\\n"
>>>>>>> origin/HEAD
  }
]